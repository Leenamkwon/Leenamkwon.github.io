<!DOCTYPE html>
<html  lang="en">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 4.2.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>Tag: github - namkwon&#39;s tech blog</title>


    <meta name="description" content="welcome my Blog!">
<meta property="og:type" content="website">
<meta property="og:title" content="namkwon&#39;s tech blog">
<meta property="og:url" content="https://github.com/Leenamkwon/Leenamkwon.github.io/tags/github/index.html">
<meta property="og:site_name" content="namkwon&#39;s tech blog">
<meta property="og:description" content="welcome my Blog!">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/images/og_image.png">
<meta property="article:author" content="Lee namkwon">
<meta property="article:tag" content="javaScript">
<meta property="article:tag" content=" TypeScript">
<meta property="article:tag" content=" JS">
<meta property="article:tag" content=" HTML5">
<meta property="article:tag" content=" CSS3">
<meta property="article:tag" content=" SCSS">
<meta property="article:tag" content=" React">
<meta property="article:tag" content=" web">
<meta property="article:tag" content=" vue">
<meta property="article:tag" content=" git">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/monokai.css">


    
    
<style>body>.footer,body>.navbar,body>.section{opacity:0}</style>

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">

    
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">

    
    
    
    
<link rel="stylesheet" href="/css/back-to-top.css">

    
    
    
    
    
    
    
    <link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="namkwon&#39;s tech blog" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">Home</a>
                
                <a class="navbar-item"
                href="/archives">Archives</a>
                
                <a class="navbar-item"
                href="/categories">Categories</a>
                
                <a class="navbar-item"
                href="/tags">Tags</a>
                
                <a class="navbar-item"
                href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                    
                    <a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                    
                
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-8-tablet is-8-desktop is-8-widescreen has-order-2 column-main"><div class="card">
    <div class="card-content">
        <nav class="breadcrumb" aria-label="breadcrumbs">
        <ul>
            <li><a href="/tags">Tags</a></li>
            <li class="is-active"><a href="#" aria-current="page">github</a></li>
        </ul>
        </nav>
    </div>
</div>

    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-03-08T06:02:03.000Z">2020-03-08</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    28 minutes read (About 4142 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/03/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/">프로토타입 | javaScript</a>
            
        </h1>
        <div class="content">
            <p>자바스크립트는 명령형(Imperative), 함수형(Functional), 프로토타입 기반(Prototype-based) 객체지향 프로그래밍(OOP, Object Oriented Programming)을 지원하는 멀티 패러다임 프로그래밍 언어다.</p>
<p><strong>자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다.</strong> 원시타입을 제외한 모든 것(함수, 배열, 객체등)은 모두 객체이다.<br><br></p>
<h1 id="1-객체지향-프로그래밍"><a href="#1-객체지향-프로그래밍" class="headerlink" title="1. 객체지향 프로그래밍"></a>1. 객체지향 프로그래밍</h1><p>객체지향 프로그래밍(OOP)은 프로그램을 명령어 또는 함수의 목록으로 보는 전통적인 명령형 프로그래밍의 절차지향적 관점에서 벗어나 여러 개의 독립적 단위, 즉 객체(object)들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다.</p>
<p>객체지향 프로그래밍은 실세계의 실체(사물이나 개념)를 인식하는 철학적 사고를 프로그래밍에 접목하려는 시도에서 시작한다. 실체는 특징이나 성질을 나타내는 속성(attribute, property)을 가지고 있고, 이를 통해 실체를 인식하거나 구별할 수 있다.</p>
<p>예를 들어 사람은 이름, 주소, 성별, 나이, 신장, 체중, 학력, 성격, 직업 등 다양한 속성을 갖는다. 이때 “이름이 아무개이고 성별은 여성이며 나이는 20세인 사람”과 같이 속성을 구체적으로 표현하면 특정한 사람을 다른 사람과 구별하여 인식할 수 있다.</p>
<p>이러한 방식을 프로그래밍에 접목시켜보자. 사람에게는 다양한 속성이 있으나 우리가 구현하려는 프로그램에서는 사람의 “이름”, “주소”라는 속성에만 관심이 있다고 가정하자. 이처럼 다양한 속성 중에서 프로그램에 필요한 속성만을 간추려 내어 표현하는 것을 <strong>추상화(abstraction)</strong>라 한다.</p>
<p>“이름”과 “주소”라는 속성을 갖는 person이라는 객체를 자바스크립트로 표현해 보면 아래와 같다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 이름과 주소 속성을 갖는 객체</span></span><br><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">	name: <span class="string">'Lee'</span>,</span><br><span class="line">	address: <span class="string">'Seoul'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br></pre></td></tr></table></figure>

<p>이때 프로그래머(subject, 주체)는 이름과 주소 속성으로 표현된 객체(object)인 person을 다른 객체와 구별하여 인식할 수 있다. 이처럼 <strong>속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료 구조</strong>를 객체라 하며 객체 지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다.</p>
<p>이번에는 원(Circle)이라는 개념을 객체로 만들어보자. 원에는 반지름이라는 속성이 있다. 이 반지름을 가지고 원의 지름, 둘레, 넓이를 구할 수 있다. 이때 반지름은 원의 상태를 나타내는 데이터이며 원의 지름, 둘레, 넓이를 구하는 것은 동작이다.</p>
<p>이번에는 원(Circle)이라는 개념을 객체로 만들어보자. 원에는 반지름이라는 속성이 있다. 이 반지름을 가지고 원의 지름, 둘레, 넓이를 구할 수 있다. 이때 반지름은 원의 상태를 나타내는 데이터이며 원의 지름, 둘레, 넓이를 구하는 것은 <strong>동작</strong>이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle = &#123;</span><br><span class="line">	radius: <span class="number">5</span>, <span class="comment">// 반지름</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// 원의 지름: 2r</span></span><br><span class="line">	getDiameter() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 원의 둘레: 2πr</span></span><br><span class="line">	getPerimeter() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * <span class="keyword">this</span>.radius;</span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 원의 넓이: πrr</span></span><br><span class="line">	getArea() &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle.getDiameter());   <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle.getperimeter());  <span class="comment">// 31.41</span></span><br><span class="line">	<span class="built_in">console</span>.log(circle.getArea());     <span class="comment">// 78.53</span></span><br></pre></td></tr></table></figure>

<p>이처럼 객체지향 프로그래밍은 객체의 <strong>상태(state)</strong>를 나타내는 데이터와 상태 데이터를 조작할 수 있는 <strong>동작(behavior)</strong>을 하나의 논리적인 단위로 묶어 생각한다. 따라서 객체는 <strong>상태 데이터와 동작을 하나의 논리적인 단위로 묶은 복합적인 자료 구조</strong>라고 할 수 있다. 객체의 상태 데이터를 프로퍼티(property), 동작을 메소드(method)라 부른다.</p>
<p>각각의 객체는 고유의 기능을 갖는 독립적인 부품으로 볼 수 있지만 자신의 고유한 기능을 수행하면서 다른 객체와 관계성(relationship)을 갖을 수 있다. 다른 객체와 메시지를 주고 받거나 데이터를 처리할 수도 있다. 또는 다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 한다.<br><br></p>
<h1 id="2-상속과-프로토타입"><a href="#2-상속과-프로토타입" class="headerlink" title="2.상속과 프로토타입"></a>2.상속과 프로토타입</h1><p>상속은 객체지향 프로그래밍의 핵심 개념으로 어떤 객체의 프로퍼티 또는 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.</p>
<p><strong>자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다.</strong>중복을 제거하는 방법은 기존의 코드를 적극적으로 재사용하는 것이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.radius = radisu;</span><br><span class="line">	<span class="keyword">this</span>.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">		<span class="comment">// Math.pow는 첫번째 인수를 두번째 인수로 거듭제곱한 값을 반환한다.</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="comment">// 반지름이 1인 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="comment">// 반지름이 2인 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle 생성자 함수는 인스턴스를 생성할 때마다 동일한 동작을 하는</span></span><br><span class="line"><span class="comment">// getArea 메소드를 중복 생성하고 모든 인스턴스가 중복 소유한다.</span></span><br><span class="line"><span class="comment">// 따라서 getArea 메소드는 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다.</span></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea === circle2.getArea); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea()); <span class="comment">// 3.141592653589793</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getArea()); <span class="comment">// 12.566370614359172</span></span><br></pre></td></tr></table></figure>

<p>Circle 생성자 함수가 생성하는 모든 객체(인스턴스)는 radius 프로퍼티와 getArea 메소드를 갖는다. radius 프로퍼티 값은 일반적으로 인스턴스마다 다르다.(같은 상태를 갖는 여러 개의 인스턴스가 필요하다면 radius 프로퍼티 값이 같을 수도 있다.) 하지만 getArea 메소드는 모든 인스턴스가 동일한 내용의 메소드를 사용하므로 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다. 그런데 Circle 생성자 함수는 인스턴스를 생성할 때마다 getArea 메소드를 중복 생성하고 모든 인스턴스가 중복 소유한다.</p>
<p>동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리를 불필요하게 낭비한다. 또한 인스턴스를 생성할 때마다 메소드를 생성하므로 퍼포먼스에도 악영향을 준다. 만약 10개의 인스턴스를 생성하면 내용이 동일한 메소드도 10개 생성된다.</p>
<p>상속을 통해 불필요한 중복을 제거해 보자.<strong>자바스크립트는 프로토타입을 기반으로 상속을 구현한다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토타입에 추가한다.</span></span><br><span class="line"><span class="comment">// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.</span></span><br><span class="line">Circle.prototype.getArea = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는</span></span><br><span class="line"><span class="comment">// 프로토타입 Circle.prototype로부터 getArea 메소드를 상속받는다.</span></span><br><span class="line"><span class="comment">// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea === circle2.getArea); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea()); <span class="comment">// 3.141592653589793</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getArea()); <span class="comment">// 12.566370614359172</span></span><br></pre></td></tr></table></figure>

<p>“16.2 생성자 함수”에서 살펴본 바와 같이 생성자 함수는 동일한 프로퍼티(메소드 포함) 구조를 갖는 객체를 여러 개 생성할 때 유용하다. 하지만 위 예제의 생성자 함수는 문제가 있다.</p>
<p>Circle 생성자 함수가 생성하는 모든 객체(인스턴스)는 radius 프로퍼티와 getArea 메소드를 갖는다. radius 프로퍼티 값은 일반적으로 인스턴스마다 다르다.(같은 상태를 갖는 여러 개의 인스턴스가 필요하다면 radius 프로퍼티 값이 같을 수도 있다.) 하지만 getArea 메소드는 모든 인스턴스가 동일한 내용의 메소드를 사용하므로 하나만 생성하여 모든 인스턴스가 공유하는 것이 바람직하다. 그런데 Circle 생성자 함수는 인스턴스를 생성할 때마다 getArea 메소드를 중복 생성하고 모든 인스턴스가 중복 소유한다.<br></p>
<p><img src="https://poiemaweb.com/assets/fs-images/19-1.png" alt="prototye" title="메소드 중복 생성"><br><br></p>
<p>이처럼 동일한 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리를 불필요하게 낭비한다. 또한 인스턴스를 생성할 때마다 메소드를 생성하므로 퍼포먼스에도 악영향을 준다. 만약 10개의 인스턴스를 생성하면 내용이 동일한 메소드도 10개 생성된다.</p>
<p>상속을 통해 불필요한 중복을 제거해 보자. <strong>자바스크립트는 프로토타입(prototype)을 기반으로 상속을 구현한다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.radius = radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토타입에 추가한다.</span></span><br><span class="line"><span class="comment">// 프로토 타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.</span></span><br><span class="line">Circle.prototype.getArea = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">Math</span>.PI * <span class="built_in">Math</span>.pow(<span class="keyword">this</span>.radius, <span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는</span></span><br><span class="line"><span class="comment">// 프로토타입 Circle.prototype로부터 getArea 메소드를 상속받는다.</span></span><br><span class="line"><span class="comment">// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea === circle2.getArea); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getArea()); <span class="comment">// 3.141592653589793</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getArea()); <span class="comment">// 12.566370614359172</span></span><br></pre></td></tr></table></figure>
<br>

<p><img src="https://poiemaweb.com/assets/fs-images/19-2.png" alt="prototype" title="상속에 의한 메소드 공유"></p>
<p>Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입, 즉 상위(부모) 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메소드를 상속 받는다.</p>
<p>getArea 메소드는 단 하나만 생성되어 프로토타입인 Circle.prototype의 메소드로 할당되어 있다. 따라서 Circle 생성자 함수가 생성하는 모든 인스턴스는 getArea 메소드를 상속받아 사용할 수 있다. 즉, 자신의 상태를 나타내는 radius 프로퍼티만을 개별적으로 소유하고 내용이 동일한 메소드는 상속을 통해 공유하여 사용하는 것이다.</p>
<p>상속은 코드의 재사용이란 관점에서 매우 유용하다. 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 프로토타입에 미리 구현에 놓으면 생성자 함수가 생성할 모든 인스턴스는 별도의 구현없이 상위(부모) 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.<br><br></p>
<h1 id="3-프로토타입-객체"><a href="#3-프로토타입-객체" class="headerlink" title="3. 프로토타입 객체"></a>3. 프로토타입 객체</h1><p>프로토타입 객체(또는 줄여서 프로토타입)란 객체간 상속을 구현하기 위해 사용된다.<br>프로토타입은 어떤 객체의 상위(부모)객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티(메소드 포함)를 제공한다.프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다.</p>
<p>모든 객체는 Prototype이라는 내부 슬롯을 갖는다. 모든 객체는 생성될 떄  [[Prototype]] 내부 슬롯의 값으로 프로토타입의 참조를 저장한다. 즉, 모든 객체는 하나의 프로토타입을 갖으며 프로토타입은 객체의 생성 방식에 의해 결정된다.</p>
<p>예를 들어, 객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이고 생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 이에 대해서는 “객체 생성 방식과 프로토타입의 결정”에서 자세히 살펴볼 것이다.</p>
<p>모든 객체는 하나의 프로토타입을 갖는다. 프로토타입은 null이거나 객체이다. 그리고 모든 프로토타입은 생성자 함수와 연결되어 있다. 즉, 객체와 프로토타입과 생성자 함수는 서로 연결되어 있다.</p>
<p><img src="https://poiemaweb.com/assets/fs-images/19-3.png" alt="prototype" title="객체와 프로토타입과 생성자 함수는 서로 연결되어 있다."></p>
<p>위 그림처럼 객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입, 즉 자신의 [[Prototype]]내부 슬롯이 가리키는 객체에 접근할 수 있다. 그리고 프로토타입은 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있다. 생성자 함수는 Prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다.<br><br></p>
<h2 id="3-1-proto-접근자-프로퍼티"><a href="#3-1-proto-접근자-프로퍼티" class="headerlink" title="3.1. proto 접근자 프로퍼티"></a>3.1. <strong>proto</strong> 접근자 프로퍼티</h2><p><strong>모든 객체는 <strong>proto</strong> 접근자 프로퍼티를 통해 자신의 프로토타입, [[Prototype]]내부 슬롯에 접근할 수 있다.</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">'namkwon'</span> &#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://poiemaweb.com/assets/fs-images/19-4.png" alt=""></p>
<p>위 그림의 빨간 박스로 표시한 것이 person 객체의 프로토타입인 Object.prototype이다. 이는 <strong>proto</strong> 접근자 프로퍼티를 통해 person 객체의 [[Prototype]] 내부 슬롯이 가리키는 객체인 Object.prototype에 접근한 결과를 크롬 브라우저가 콘솔에 표시한 것이다. 이처럼 모든 객체는 프로토타입을 가리키는 [[Prototype]] 내부 슬롯에 접근하기 위해 <strong>proto</strong> 접근자 프로퍼티를 사용할 수 있다.</p>
<p><mark style="font-size: 20px"><strong>proto</strong>는 접근자 프로퍼티이다.</mark></p>
<p>“15.2 내부 슬롯/메소드”에서 살펴보았듯이 내부 슬롯은 프로퍼티가 아니다. 따라서 내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다. [[Prototype]] 내부 슬롯에도 직접 접근할 수 없으며 <strong>proto</strong> 접근자 프로퍼티를 통해 간접적으로 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근할 수 있다.</p>
<p>“접근자 프로퍼티”에서 살펴본 것처럼 접근자 프로퍼티는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티다.</p>
<p><img src="https://poiemaweb.com/assets/fs-images/19-5.png" alt=""><br>Object.prototype의 프로퍼티인 <strong>proto</strong> 접근자 프로퍼티는 getter/setter 함수라고 부르는 접근자 함수를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당한다. <strong>proto</strong> 접근자 프로퍼티를 통해 프로토타입에 접근하면 내부적으로 <strong>proto</strong> 접근자 프로퍼티의 getter 함수인 get <strong>proto</strong>가 호출된다. <strong>proto</strong> 접근자 프로퍼티를 통해 새로운 프로토타입을 할당하면 <strong>proto</strong> 접근자 프로퍼티의 setter 함수인 set <strong>proto</strong>가 호출된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> parent = &#123; <span class="attr">x</span>: <span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 취득</span></span><br><span class="line">obj.__proto__;</span><br><span class="line"><span class="comment">// setter함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체</span></span><br><span class="line">obj.__proto__ = parent;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.x); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p><mark style="font-size: 20px"><strong>proto</strong> 접근자 프로퍼티는 상속을 통해 사용된다.</mark></p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-03-04T04:00:03.000Z">2020-03-04</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/JavaScript/">JavaScript</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    20 minutes read (About 2942 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/03/%ED%95%A8%EC%88%98%EC%99%80%20%EC%9D%BC%EA%B8%89%20%EA%B0%9D%EC%B2%B4/">함수와 일급 객체 | javaScript</a>
            
        </h1>
        <div class="content">
            <h1 id="1-일급-객체"><a href="#1-일급-객체" class="headerlink" title="1. 일급 객체"></a>1. 일급 객체</h1><br>
아래와 같은 조건을 만족하는 객체를 일급 객체(first-class object)라 한다.

<ol>
<li>무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다.</li>
<li>변수나 자료구조(객체, 배열 등)에 저장할 수 있다.</li>
<li>함수의 매개 변수에게 전달할 수 있다.</li>
<li>함수의 결괏값으로 반환할 수 있다.</li>
</ol>
<p>자바스크립트의 함수는 아래 예제와 같이 위의 조건을 모두 만족하므로 일급 객체이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1. 함수는 무명의 리터럴로 생성할 수 있다.</span><br><span class="line">2. 함수는 변수에 저장할 수 있다.</span><br><span class="line">&#x2F;&#x2F; 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.</span><br><span class="line">const increase &#x3D; function (num) &#123;</span><br><span class="line">  return ++num</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const decrease &#x3D; function (num) &#123;</span><br><span class="line">  return --num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 함수는 객체에 저장할 수 있다.</span><br><span class="line">const predicates &#x3D; &#123; increase, decrease &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 함수의 매개 변수에게 전달할 수 있다.</span><br><span class="line">&#x2F;&#x2F; 4. 함수의 반환값으로 사용할 수 있다.</span><br><span class="line">function makeCounter(predicate) &#123;</span><br><span class="line">  let num &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  return function () &#123;</span><br><span class="line">    num &#x3D; predicate(num);</span><br><span class="line">    return num;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 함수는 매개 변수에게 함수를 전달할 수 있다.</span><br><span class="line">const increaser &#x3D; makeCounter(predicates.increase);</span><br><span class="line">console.log(increaser()); &#x2F;&#x2F; 1</span><br><span class="line">console.log(increaser()); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 함수는 매개 변수에게 함수를 전달할 수 있다.</span><br><span class="line">const decreaser &#x3D; makeCounter(predicates.decrease);</span><br><span class="line">console.log(decreaser()); &#x2F;&#x2F; -1</span><br><span class="line">console.log(decreaser()); &#x2F;&#x2F; -2</span><br></pre></td></tr></table></figure>

<p>함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다. 객체는 값이므로 함수는 값과 동일하게 취급할 수 있다. 따라서 함수는 값을 사용할 수 있는 곳(변수 할당문, 객체의 프로퍼티, 배열의 요소, 함수 호출의 인수, 함수 반환문)이라면 어디서든지 리터럴로 정의할 수 있으며 런타임(runtime)에 함수 객체로 평가된다.</p>
<p>함수 객체는 몇 가지 고유한 프로퍼티를 갖는 것을 제외하면 일반 객체와 동일하다. 따라서 함수 객체는 일반 객체와 같이 함수의 매개 변수에 전달할 수 있으며 함수의 결과값으로 반환할 수도 있다. 이는 함수형 프로그래밍을 가능케하는 자바스크립트의 장점 중에 하나이다.</p>
<pre><code>함수형 프로그래밍
함수형 프로그래밍은 순수 함수(Pure function)와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과(side-effect)를 최소화하여 불변성(Immutability)을 지향하는 프로그래밍 패러다임이다.
로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하며, 변수 사용을 억제하거나 생명주기를 최소화하여 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다. 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 하여 가독성을 해치고, 변수의 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있기 때문이다.
함수형 프로그래밍 패러다임에서 매개 변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수를 고차 함수(Higher-Order Function, HOF)라 한다. 고차 함수에 대해서는 “배열”에서 자세히 살펴볼 것이다.</code></pre><p>함수는 객체이지만 일반 객체와 차이가 있다. <strong>일반 객체는 호출을 못하지만 함수객체는 호출이 가능하다.</strong><br><br></p>
<h1 id="2-함수-객체의-프로퍼티"><a href="#2-함수-객체의-프로퍼티" class="headerlink" title="2. 함수 객체의 프로퍼티"></a>2. 함수 객체의 프로퍼티</h1><p>함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다. 브라우저 콘솔에서 console.dir 메소드를 사용하여 함수 객체의 내부를 들여다 보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function square(number) &#123;</span><br><span class="line">  return number * number;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.dir(square);</span><br></pre></td></tr></table></figure>

<p>일반 객체에는 없는 arguments, caller, length, name, prototype 프로퍼티가 함수 객체에는 존재한다. 이 프로퍼티 들의 프로퍼티 어트리뷰트를 <strong>object,getOwnpropertyDescriptor 메소드</strong>로 확인해 보면 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function square(number) &#123;</span><br><span class="line">  return number * numer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; arguments는 square 함수 객체의 데이터 프로퍼티이다.</span><br><span class="line">Object.getOwnpropertyDescriptor(square, &#39;arguments&#39;);</span><br><span class="line">&#x2F;&#x2F; &#123;value: null, writable: false, enumerable: false, configurable: false&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; caller는 square 함수 객체의 데이터 프로퍼티이다.</span><br><span class="line">Object.getOwnpropertyDescriptor(square, &#39;caller&#39;);</span><br><span class="line">&#x2F;&#x2F; &#123;value: null, writable: flase, enumarable: false, configurable: false&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; length는 square 함수 객체의 데이터 프로퍼티이다.</span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;length&#39;);</span><br><span class="line">&#x2F;&#x2F; &#123;value: 1, writable: false, enumerable: false, configurable: true&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; name은 square 함수 객체의 데이터 프로퍼티이다.</span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;name&#39;);</span><br><span class="line">&#x2F;&#x2F; &#123;value: &quot;square&quot;, writable: false, enumerable: false, configurable: true&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; prototype은 square 함수 객체의 데이터 프로퍼티이다.</span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;prototype&#39;);</span><br><span class="line">&#x2F;&#x2F; &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; __proto__는 square 함수 객체의 프로퍼티가 아니다.</span><br><span class="line">Object.getOwnPropertyDescriptor(square, &#39;__proto__&#39;);</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; __proto__는 Object.prototype 객체의 접근자 프로퍼티이다.</span><br><span class="line">&#x2F;&#x2F; square 함수 객체는 Object.prototype 객체로부터 __proto__ 접근자 프로퍼티를 상속받는다.</span><br><span class="line">Object.getOwnPropertyDescriptor(Object.prototype, &#39;__proto__&#39;);</span><br><span class="line">&#x2F;&#x2F; &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span><br></pre></td></tr></table></figure>

<p><strong>arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 데이터 프로퍼티이다.</strong><br>하지만 <strong>proto</strong>는 접근자 프로퍼티이며 함수 객체의 프로퍼티가 아닌 Object.prototype 객체의 프로퍼티를 상속받은 것을 알 수 있다.<br><br></p>
<h2 id="2-1-arguments-프로퍼티"><a href="#2-1-arguments-프로퍼티" class="headerlink" title="2.1. arguments 프로퍼티"></a>2.1. arguments 프로퍼티</h2><p>함수 객체의 arguments 프로퍼티 값은 arguments 객체이다. arguments 객체는 함수 호출 시 전달된 인수(arguemnt)들의 정보를 담고 있는 순회 가능한(iterable)유사 배열 객체이며 함수 내부에서 지역 변수처럼 사용된다. 즉, <strong>함수 외부에서는 사용할 수 없다.</strong></p>
<p>자바스크립트는 함수 호출 시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function multiply(x, y) &#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">  return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(multiply());        &#x2F;&#x2F; NaN</span><br><span class="line">console.log(multiply(1));       &#x2F;&#x2F; NaN</span><br><span class="line">console.log(multiply(1, 2));    &#x2F;&#x2F; 2</span><br><span class="line">console.log(multiply(1, 2, 3)); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>함수를 정의할 떄 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수가 할당된다.</p>
<p>선언된 매개변수의 개수보다 인수를 적게 전달했을 경우 <strong>인수가 전달되지 않은 매개변수는 undefined로 초기화된 상태를 유지한다.</strong><br><strong>매개변수의 개수보다 인수를 더 많이 전달한 경우(multiply(1, 2, 3)) 초과된 인수는 무시된다.</strong></p>
<p>그렇다고 초과된 인수가 그냥 버려지는 것은 아니다.모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.</p>
<p>arguments 객체는 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서를 나타낸다. arguments객체의 callee 프로퍼티는 호출되어 arguments 객체를 생성한 함수, 즉 함수 자신을 가리키고 arguments 객체의 length 프로퍼티는 인수의 개수를 가리킨다.</p>
<p>선언된 매개변수의 개수와 함수 호출 시에 전달하는 인수의 개수를 확인하지 않은 자바스크립트의 특성때문에 런타임 시에 호출된 함수의 인자 개수를 확인하고 이에 따라 함수의 동작을 달리 정의할 필요가 있을 수 있다. 이때 유용하게 사용되는 것이 arguments 객체이다.</p>
<p><strong>arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  let res &#x3D; 0;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다.</span><br><span class="line">  for (let i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    res +&#x3D; arguments[i];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum());        &#x2F;&#x2F; 0</span><br><span class="line">console.log(sum(1, 2));    &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1, 2, 3)); &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>

<p><strong>arguments 객체는 배열의 형태로 인자 정보를 담고 있지만 실제 배열이 아닌 유사배열객체(array-like object)이다. 유사배열객체란 length 프로퍼티를 가진 객체로 for 문으로 순회할 수 있는 객체를 말한다.</strong></p>
<p><strong>유사 배열 객체는 배열이 아니므로 메소드를 사용할 경우 에러가 발생하게 된다.</strong>따라서 배열 메소드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용해 간접 호출해야 하는 번거로움이 있다. 간접 호출과 배열에 대해 아직 살펴보지 않았으므로 지금은 참고로만 알아둡시다~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function sum() &#123;</span><br><span class="line">  const array &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line">  return array.reduce(function(pre, cur) &#123;</span><br><span class="line">    return pre + cur;</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2)); &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1, 2, 3, 4, 5)); &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>

<p>이러한 번거로움을 해결하기 위해 ES6에서는 Rest 파라미터를 도입했다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; ES6 Rest parameter</span><br><span class="line">function sum(...args) &#123;</span><br><span class="line">  return args.reduce((pre, cur) &#x3D;&gt; pre + cur, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(sum(1, 2));           &#x2F;&#x2F; 3</span><br><span class="line">console.log(sum(1, 2, 3, 4, 5));  &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>
<br>

<h2 id="2-2-length-프로퍼티"><a href="#2-2-length-프로퍼티" class="headerlink" title="2.2. length 프로퍼티"></a>2.2. length 프로퍼티</h2><p>함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킨다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  console.log(foo.length); &#x2F;&#x2F; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function bar(x) &#123;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">console.log(bar.length); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">function baz(x, y, z) &#123;</span><br><span class="line">  return x * y * z;</span><br><span class="line">&#125;</span><br><span class="line">console.log(baz.length); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있으므로 주의하여야 한다.<br><strong>arguments 객체의 length 프로퍼티는 인자(argument)의 개수를 가리키고, 함수 객체의 length 프로퍼티는 매개변수(parameter)의 개수를 가리킨다.</strong><br><br></p>
<h2 id="2-3-name-프로퍼티"><a href="#2-3-name-프로퍼티" class="headerlink" title="2.3. name 프로퍼티"></a>2.3. name 프로퍼티</h2><p>함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.<br>name 프로퍼티는 ES5와 ES6에서 동작을 달리 하므로 주의하기 바란다. 익명 함수 표현식의 경우, ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖는다. 하지만 ES6에서는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 기명 함수 표현식</span><br><span class="line">var namedFunc &#x3D; function foo () &#123;&#125;;</span><br><span class="line">console.log(namedFunc.name); &#x2F;&#x2F; foo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 익명 함수 표현식</span><br><span class="line">var anoymusFunc &#x3D; function() &#123;&#125;;</span><br><span class="line">&#x2F;&#x2F; ES5: name 프로퍼티는 빈 문자열을 값으로 갖는다.</span><br><span class="line">&#x2F;&#x2F; ES6: name 프로퍼티는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.</span><br><span class="line">console.log(anonymousFunc.name); &#x2F;&#x2F; anonymousFunc</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 선언문(Function declaration)</span><br><span class="line">function bar() &#123;&#125;</span><br><span class="line">console.log(bar.name); &#x2F;&#x2F; bar</span><br></pre></td></tr></table></figure>
<br>

<h2 id="2-5-proto-접근자-프로퍼티"><a href="#2-5-proto-접근자-프로퍼티" class="headerlink" title="2.5. proto 접근자 프로퍼티"></a>2.5. <strong>proto</strong> 접근자 프로퍼티</h2><p>모든 객체는[[prototype]]이라는 내부 슬롯을 갖는다. [[prototype]]내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다.</p>
<p><strong>proto</strong>프로퍼티는 [[Prototype]]내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다. 내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.</span><br><span class="line">console.log(obj.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.</span><br><span class="line">&#x2F;&#x2F; hasOwnProperty 메소드는 Object.prototype의 메소드이다.</span><br><span class="line">console.log(obj.hasOwnProperty(&#39;a&#39;));         &#x2F;&#x2F; true</span><br><span class="line">console.log(obj.hasOwnProperty(&#39;__proto__&#39;)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<br>

<h2 id="2-6-prototype-프로퍼티"><a href="#2-6-prototype-프로퍼티" class="headerlink" title="2.6. prototype 프로퍼티"></a>2.6. prototype 프로퍼티</h2><p>prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 객체는 prototype 프로퍼티를 소유한다.</span><br><span class="line">console.log((function() &#123;&#125;).hasOwnproperty(&#39;prototype&#39;)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 일반 객체는 prototype 프로퍼티를 소유하지 않는다.</span><br><span class="line">console.log((&#123;&#125;).hasOwnProperty(&#39;prototype&#39;)); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-03-03T11:02:03.000Z">2020-03-03</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    37 minutes read (About 5562 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/03/property_attribute/">프로퍼티 어트리뷰트 | javaScript</a>
            
        </h1>
        <div class="content">
            <h1 id="1-내부-슬롯과-내부-메소드"><a href="#1-내부-슬롯과-내부-메소드" class="headerlink" title="1.내부 슬롯과 내부 메소드"></a>1.내부 슬롯과 내부 메소드</h1><p>내부 슬롯과 내부 메소드는 자바스크립트 엔진의 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메소드이다. ECMAScript 사양에 등장하는 이중 대괄호 [[…]]로 감싼 이름들이 내부 슬롯과 내부 메소드이다.</p>
<p>내부 슬롯과 내부 메소드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작하지만 외부로 공개된 객체의 프로퍼티는 아니다. 즉, 내부 슬롯과 내부 메소드는 자바스크립트 엔진의 내부 로직이다. 그러므로 직접적으로 접근하거나 호출할 수가 없다.<br><br></p>
<h1 id="2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체"><a href="#2-프로퍼티-어트리뷰트와-프로퍼티-디스크립터-객체" class="headerlink" title="2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체"></a>2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체</h1><p>자바스크립트 엔진은 프로퍼티를 생성할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다. 프로퍼티의 상태란 프로퍼티의 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable)를 말한다.</p>
<p>프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값(meta-property)인 내부 슬롯([[Value]], [[Writable]], [[Enumerable]], [[Configurable]])이다. 따라서 프로퍼티 어트리뷰트에 직접 접근할 수 없지만, Object.getOwnPropertyDescriptor 메소드를 사용하여 간접적으로 확인할 수는 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(person, &#39;name&#39;));</span><br><span class="line">&#x2F;&#x2F; &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure>

<p>Object.getOwnPropertyDescriptor 메소드를 호출할 때, 첫번째 매개변수에는 객체의 참조를 전달하고 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다. 이때 Object.getOwnPropertyDescriptor 메소드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터(PropertyDescriptor) 객체를 반환한다. 만약 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined가 반환된다.</p>
<p>Object.getOwnPropertyDescriptor 메소드는 하나의 프로퍼티에 대해 프로퍼티 디스크립터 객체를 반환하지만 ES8에서 도입된 Object.getOwnPropertyDescriptors 메소드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 동적 생성</span><br><span class="line">person.age &#x3D; 20;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(person));</span><br><span class="line">&#x2F;*</span><br><span class="line">&#123;</span><br><span class="line">  name: &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;,</span><br><span class="line">  age: &#123;value: 20, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<br>

<h1 id="3-데이터-프로퍼티와-접근자-프로퍼티"><a href="#3-데이터-프로퍼티와-접근자-프로퍼티" class="headerlink" title="3. 데이터 프로퍼티와 접근자 프로퍼티"></a>3. 데이터 프로퍼티와 접근자 프로퍼티</h1><p>프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분할 수 있다.</p>
<ul>
<li><p>데이터 프로퍼티(Data property)<br>키와 값으로 구성된 일반적인 프로퍼티이다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티이다.</p>
</li>
<li><p>접근자 프로퍼티 (Accessor property)<br>자체적으로 값을 갖지 않고 다른 데이터의 프로퍼티 값을 읽거나 저장할 떄 호출되는 접근자 함수로 구성된 프로퍼티이다.</p>
<br>

</li>
</ul>
<h2 id="3-1-데이터-프로퍼티"><a href="#3-1-데이터-프로퍼티" class="headerlink" title="3.1 데이터 프로퍼티"></a>3.1 데이터 프로퍼티</h2><p>데이터 프로퍼티(Data property)는 아래와 같은 프로퍼티 어트리뷰트를 갖는다. 이 프로퍼티 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때, 기본값으로 자동 정의된다.</p>
<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크립터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Value]]</td>
<td>value</td>
<td>- 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값이다.<br>- 프로퍼티 키로 프로퍼티 값을 저장하면 [[Value]]에 값을 저장한다.<br>이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다.</td>
</tr>
<tr>
<td>[[Writable]]</td>
<td>writable</td>
<td>- 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다.<br>-[[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다.</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>configurable</td>
<td>- 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다.<br>- [[Configurable]]의 값이 false인 경우, 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다.<br> 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다.</td>
</tr>
</tbody></table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 취득한다.</span><br><span class="line">console.log(Object.getOwnPropertyDescriptor(person, &#39;name&#39;));</span><br><span class="line">&#x2F;&#x2F; &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure>

<p>Object.getOwnPropertyDescriptor 메소드가 반환한 프로퍼티 디스크립터 객체를 살펴보면 value 프로퍼티의 값은 ‘Lee’이다. 이는 프로퍼티 어트리뷰트 [[Value]]의 값이 ‘Lee’인 것을 의미한다. writable, enumerable, configurable 프로퍼티 모두 true를 갖는다. 이것은 프로퍼티 어트리뷰트 [[Writable]], [[Enumerable]], [[Configurable]]의 값이 모두 true인 것을 말한다.</p>
<p>이처럼 프로퍼티가 생성될 때 [[Value]]의 값은 프로퍼티 값으로 초기화되며 [[Writable]], [[Enumerable]], [[Configurable]]의 기본값 true로 초기화된다. 이것은 프로퍼티를 동적 추가하여도 마찬가지다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 동적 생성</span><br><span class="line">person.age &#x3D; 20;</span><br><span class="line"></span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(person));</span><br><span class="line">&#x2F;*</span><br><span class="line">&#123;</span><br><span class="line">  name: &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: true&#125;,</span><br><span class="line">  age: &#123;value: 20, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<br>

<h2 id="3-2-접근자-프로퍼티"><a href="#3-2-접근자-프로퍼티" class="headerlink" title="3.2. 접근자 프로퍼티"></a>3.2. 접근자 프로퍼티</h2><p>접근자 프로퍼티(Accessor property)는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티다.</p>
<p>접근자 프로퍼티는 아래와 같은 프로퍼티 어트리뷰트를 갖는다.</p>
<table>
<thead>
<tr>
<th>프로퍼티 어트리뷰트</th>
<th>프로퍼티 디스크립터 객체의 프로퍼티</th>
<th>설명</th>
</tr>
</thead>
<tbody><tr>
<td>[[Get]]</td>
<td>get</td>
<td>접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수이다.<br>즉, 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값<br>즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다.</td>
</tr>
<tr>
<td>[[Set]]</td>
<td>set</td>
<td>접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다.</td>
</tr>
<tr>
<td>[[Enumerable]]</td>
<td>enumerable</td>
<td>데이터 프로퍼티의 [[Enumerable]]와 같다.</td>
</tr>
<tr>
<td>[[Configurable]]</td>
<td>Configurable</td>
<td>데이터 프로퍼티의 [[Configurable]]와 같다.</td>
</tr>
</tbody></table>
<p>접근자 함수는 getter/setter 함수라고도 부른다. 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다. 아래 예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  &#x2F;&#x2F; 데이터 프로퍼티</span><br><span class="line">  firstName: &#39;Ungmo&#39;,</span><br><span class="line">  lastName: &#39;Lee&#39;,</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; fullName은 접근자 함수로 구성된 접근자 프로퍼티이다.</span><br><span class="line">  &#x2F;&#x2F; getter 함수</span><br><span class="line">  get fullName() &#123;</span><br><span class="line">    return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; setter 함수</span><br><span class="line">  set fullName(name) &#123;</span><br><span class="line">    [this.firstName, this.lastName] &#x3D; name.split(&#39; &#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 데이터 프로퍼티를 통한 프로퍼티 값의 참조.</span><br><span class="line">console.log(person.firstName + &#39; &#39; + person.lastName); &#x2F;&#x2F; Ungmo Lee</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 접근자 프로퍼티를 통한 프로퍼티 값의 저장</span><br><span class="line">&#x2F;&#x2F; 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.</span><br><span class="line">person.fullName &#x3D; &#39;Heegun Lee&#39;;</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;firstName: &quot;Heegun&quot;, lastName: &quot;Lee&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 접근자 프로퍼티를 통한 프로퍼티 값의 참조</span><br><span class="line">&#x2F;&#x2F; 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.</span><br><span class="line">console.log(person.fullName); &#x2F;&#x2F; Heegun Lee</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; firstName는 데이터 프로퍼티이다.</span><br><span class="line">&#x2F;&#x2F; 데이터 프로퍼티는 value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.</span><br><span class="line">let descriptor &#x3D; Object.getOwnPropertyDescriptor(person, &#39;firstName&#39;);</span><br><span class="line">console.log(descriptor);</span><br><span class="line">&#x2F;&#x2F; &#123;value: &quot;Heegun&quot;, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; fullName는 접근자 프로퍼티이다.</span><br><span class="line">&#x2F;&#x2F; 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.</span><br><span class="line">descriptor &#x3D; Object.getOwnPropertyDescriptor(person, &#39;fullName&#39;);</span><br><span class="line">console.log(descriptor);</span><br><span class="line">&#x2F;&#x2F; &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125;</span><br></pre></td></tr></table></figure>

<p>person 객체의 firstName과 lastName 프로퍼티는 일반적인 데이터 프로퍼티다. 메소드 앞에 get, set이 붙은 메소드가 있는데 이것들이 바로 getter와 setter 함수이고 getter/setter 함수의 이름 fullName이 접근자 프로퍼티이다. 접근자 프로퍼티는 자체적으로 값(프로퍼티 어트리뷰트 [[Value]])을 가지지 않으며 다만 데이터 프로퍼티의 값을 읽거나 저장할 때 관여할 뿐이다.</p>
<p>이를 내부 슬롯/메소드 관점에서 설명하면 다음과 같다. 접근자 프로퍼티 fullName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] 내부 메소드가 호출되어 아래와 같이 동작한다.</p>
<div style="background-color: #333">

<p>  ECMAScript 스펙에서 정의한 [[Get]] 내부 메소드의 사양을 만족시키는 구현체가 자바스크립트 엔진에 존재한다는 것이 중요하지 [[Get]]이란 이름으로 실제 자바스크립트 엔진이 구현되었는지는 중요하지 않다. 어차피 [[Get]] 내부 메소드에 직접 접근할 수도 없다.</p>
</div>

<ol>
<li><p>프로퍼티 키가 유효한지 확인한다. 프로퍼티 키는 문자열 또는 심볼이어야 한다. 프로퍼티 키 “fullName”은 문자열이므로 유효한 프로퍼티 키이다.</p>
</li>
<li><p>프로토타입 체인에서 프로퍼티를 검색한다. person 객체에 fullName 프로퍼티가 존재한다.</p>
<br>

<p> 프로토타입<br> 프로토타입(prototype)은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체이다. 프로토타입은 하위(자식) 객체에게 자신의 프로퍼티와 메소드를 상속한다. 프로토타입 객체의 프로퍼티나 메소드를 상속받은 하위 객체는 자신의 프로퍼티 또는 메소드인 것처럼 자유롭게 사용할 수 있다.<br> 프로토타입 체인은 프로토타입이 단방향 링크드 리스트 형태로 연결되어 있는 상속 구조를 말한다. 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 프로토타입 체인을 따라 프로토타입의 프로퍼티나 메소드를 차례대로 검색한다.<br> 프로토타입과 프로토타입 체인에 대해서는 “19. 프로토타입”에서 자세히 살펴보도록 하자.</p>
</li>
<li><p>검색된 fullName 프로퍼티가 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다. fullName 프로퍼티는 접근자 프로퍼티이다.</p>
</li>
<li><p>접근자 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하여 그 결과를 반환한다. 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDescriptor 메소드가 반환하는 프로퍼티 디스크립터(PropertyDescriptor) 객체의 get 프로퍼티 값과 같다.</p>
</li>
</ol>
<p>접근자 프로퍼티와 데이터 프로퍼티 구별 방법은 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 일반 객체의 __proto__는 접근자 프로퍼티이다.</span><br><span class="line">Object.getOwnPropertyDescriptor(Object.prototype, &#39;__proto__&#39;);</span><br><span class="line">&#x2F;&#x2F; &#123;get: ƒ, set: ƒ, enumerable: false, configurable: true&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 객체의 prototype은 데이터 프로퍼티이다.</span><br><span class="line">Object.getOwnPropertyDescriptor(function() &#123;&#125;, &#39;prototype&#39;);</span><br><span class="line">&#x2F;&#x2F; &#123;value: &#123;…&#125;, writable: true, enumerable: false, configurable: false&#125;</span><br></pre></td></tr></table></figure>

<p>Object.getOwnPropertyDescriptor 메소드가 반환한 프로퍼티 어트리뷰트를 객체로 표현한 프로퍼티 디스크립터 객체를 유심히 살펴보자. 접근자 프로퍼티와 데이터 프로퍼티의 프로퍼티 디스크립터 객체의 프로퍼티가 다른 것을 알 수 있다.<br><br></p>
<h1 id="4-프로퍼티-정의"><a href="#4-프로퍼티-정의" class="headerlink" title="4. 프로퍼티 정의"></a>4. 프로퍼티 정의</h1><p>프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다. .예를 들어 프로퍼티 값을 갱신 가능하도록 할 것인지, 프로퍼티를 열거 가능하도록 할 것인지, 프로퍼티를 재정의 가능하도록 할 것인지 정의할 수 있다. 이를 통해 객체의 프로퍼티가 어떻게 동작해야 하는지를 명확히 정의할 수 있다.</p>
<p>Object.defineProperty 메소드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. 인수는 객체의 참조와 데이터 프로퍼티의 키인 문자열 그리고 프로퍼티 디스크립터 객체를 전달한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 데이터 프로퍼티 정의</span><br><span class="line">Object.defineProperty(person, &#39;firstName&#39;, &#123;</span><br><span class="line">  value: &#39;Ungmo&#39;,</span><br><span class="line">  writable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Object.defineProperty(person, &#39;lastName&#39;, &#123;</span><br><span class="line">  value: &#39;Lee&#39;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">let descriptor &#x3D; Object.getOwnPropertyDescriptor(person, &#39;firstName&#39;);</span><br><span class="line">console.log(&#39;firstName&#39;, descriptor);</span><br><span class="line">&#x2F;&#x2F; firstName &#123;value: &quot;Ungmo&quot;, writable: true, enumerable: true, configurable: true&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값이다.</span><br><span class="line">descriptor &#x3D; Object.getOwnPropertyDescriptor(person, &#39;lastName&#39;);</span><br><span class="line">console.log(&#39;lastName&#39;, descriptor);</span><br><span class="line">&#x2F;&#x2F; lastName &#123;value: &quot;Lee&quot;, writable: false, enumerable: false, configurable: false&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [[Enumerable]]의 값이 false인 경우,</span><br><span class="line">&#x2F;&#x2F; 해당 프로퍼티는 for…in 문이나 Object.keys 등으로 열거할 수 없다.</span><br><span class="line">&#x2F;&#x2F; lastName 프로퍼티는 [[Enumerable]]의 값이 false이므로 열거되지 않는다.</span><br><span class="line">console.log(Object.keys(person)); &#x2F;&#x2F; [&quot;firstName&quot;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다.</span><br><span class="line">&#x2F;&#x2F; lastName 프로퍼티는 [[Writable]]의 값이 false이므로 값을 변경할 수 없다.</span><br><span class="line">&#x2F;&#x2F; 이때 값을 변경하면 에러는 발생하지 않고 무시된다.</span><br><span class="line">person.lastName &#x3D; &#39;Kim&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 삭제할 수 없다.</span><br><span class="line">&#x2F;&#x2F; lastName 프로퍼티는 [[Configurable]]의 값이 false이므로 삭제할 수 없다.</span><br><span class="line">&#x2F;&#x2F; 이때 프로퍼티를 삭제하면 에러는 발생하지 않고 무시된다.</span><br><span class="line">delete person.lastName;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 재정의할 수 없다.</span><br><span class="line">&#x2F;&#x2F; Object.defineProperty(person, &#39;lastName&#39;, &#123; enumerable: true &#125;);</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: Cannot redefine property: lastName</span><br><span class="line"></span><br><span class="line">descriptor &#x3D; Object.getOwnPropertyDescriptor(person, &#39;lastName&#39;);</span><br><span class="line">console.log(&#39;lastName&#39;, descriptor);</span><br><span class="line">&#x2F;&#x2F; lastName &#123;value: &quot;Lee&quot;, writable: false, enumerable: false, configurable: false&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 접근자 프로퍼티 정의</span><br><span class="line">Object.defineProperty(person, &#39;fullName&#39;, &#123;</span><br><span class="line">  &#x2F;&#x2F; getter 함수</span><br><span class="line">  get() &#123;</span><br><span class="line">    return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; setter 함수</span><br><span class="line">  set(name) &#123;</span><br><span class="line">    [this.firstName, this.lastName] &#x3D; name.split(&#39; &#39;);</span><br><span class="line">  &#125;,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  configurable: true</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">descriptor &#x3D; Object.getOwnPropertyDescriptor(person, &#39;fullName&#39;);</span><br><span class="line">console.log(&#39;fullName&#39;, descriptor);</span><br><span class="line">&#x2F;&#x2F; fullName &#123;get: ƒ, set: ƒ, enumerable: true, configurable: true&#125;</span><br><span class="line"></span><br><span class="line">person.fullName &#x3D; &#39;Heegun Lee&#39;;</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;firstName: &quot;Heegun&quot;, lastName: &quot;Lee&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>Object.defineProperty 메소드로 프로퍼티 정의할 때 프로퍼티 디스크립터 객체의 프로퍼티를 일부 생략할 수 있다. 프로퍼티 디스크립터 객체에서 생략된 어트리뷰트는 아래와 같이 기본값이 적용된다.</p>
<table>
<thead>
<tr>
<th>프로퍼티 디스크립터 객체의 프로퍼티</th>
<th>대응하는 프로퍼티 어트리뷰트</th>
<th>디스크립터 객체의 프로퍼트 누락 시의 기본값</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>[[value]]</td>
<td>undefined</td>
</tr>
<tr>
<td>get</td>
<td>[[Get]]</td>
<td>undefined</td>
</tr>
<tr>
<td>set</td>
<td>[[Set]]</td>
<td>undefined</td>
</tr>
<tr>
<td>writable</td>
<td>[[Writable]]</td>
<td>false</td>
</tr>
<tr>
<td>ennumerable</td>
<td>[[ennumerable]]</td>
<td>false</td>
</tr>
<tr>
<td>configuration</td>
<td>[[Configuration]]</td>
<td>false</td>
</tr>
</tbody></table>
<p>Object.defineProperty 메소드는 한번에 하나의 프로퍼티만 정의할 수 있다. Object.defineProperties 메소드를 사용하면 여러 개의 프로퍼티를 한번에 정의할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.defineProperties(person, &#123;</span><br><span class="line">  &#x2F;&#x2F; 데이터 프로퍼티 정의</span><br><span class="line">  firstName: &#123;</span><br><span class="line">    value: &#39;Ungmo&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  lastName: &#123;</span><br><span class="line">    value: &#39;Lee&#39;,</span><br><span class="line">    writable: true,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;&#x2F; 접근자 프로퍼티 정의</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    &#x2F;&#x2F; getter 함수</span><br><span class="line">    get() &#123;</span><br><span class="line">      return &#96;$&#123;this.firstName&#125; $&#123;this.lastName&#125;&#96;;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#x2F;&#x2F; setter 함수</span><br><span class="line">    set(name) &#123;</span><br><span class="line">      [this.firstName, this.lastName] &#x3D; name.split(&#39; &#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">person.fullName &#x3D; &#39;Heegun Lee&#39;;</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;firstName: &quot;Heegun&quot;, lastName: &quot;Lee&quot;&#125;</span><br></pre></td></tr></table></figure>
<br>

<h1 id="5-객체-변경-방지"><a href="#5-객체-변경-방지" class="headerlink" title="5. 객체 변경 방지"></a>5. 객체 변경 방지</h1><p>객체는 변경 가능한 값이므로 재할당없이 직접 변경이 가능하다. 즉, 프로퍼티를 추가하거나 삭제할 수 있고, 프로퍼티의 값을 갱신할 수 있으며 Object.defineProperty 또는 Object.defineProperties 메소드를 사용하여 프로퍼티 어트리뷰트를 재정의할 수도 있다.</p>
<p>자바스크립트는 객체의 변경을 방지할 수 있는 다양한 메소드를 제공한다. 객체 변경 방지 메소드 들은 객체의 변경을 금지하는 강도가 다르다.<br><br></p>
<h2 id="5-1-객체-확장-금지"><a href="#5-1-객체-확장-금지" class="headerlink" title="5.1. 객체 확장 금지"></a>5.1. 객체 확장 금지</h2><p>Object.preventExtensions 메소드는 객체의 확장을 금지한다. 객체 확장 금지란 프로퍼티 추가 금지를 의미한다. 즉, 확장이 금지된 객체는 프로퍼티 추가가 금지된다. 프로퍼티는 프로퍼티 동적 추가와 Object.defineProperty 메소드로 추가할 수 있다. 이 두가지 추가 방법이 모두 금지된다.</p>
<p>확장이 금지된 객체인지 여부는 Object.isExtensible 메소드로 확인 할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123; name: &#39;Lee&#39; &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체는 확장이 금지된 객체가 아니다.</span><br><span class="line">console.log(Object.isExtensible(person)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체의 확장을 금지하여 프로퍼티 추가를 금지한다.</span><br><span class="line">Object.preventExtensions(person);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체는 확장이 금지된 객체다.</span><br><span class="line">console.log(Object.isExtensible(person)); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 추가가 금지된다.</span><br><span class="line">person.age &#x3D; 20; &#x2F;&#x2F; 무시. strict mode에서는 에러</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 추가는 금지되지만 삭제는 가능하다.</span><br><span class="line">delete person.name;</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 정의에 의한 프로퍼티 추가도 금지된다.</span><br><span class="line">Object.defineProperty(person, &#39;age&#39;, &#123; value: 20 &#125;);</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot define property age, object is not extensible</span><br></pre></td></tr></table></figure>
<br>

<h2 id="5-2-객체-밀봉"><a href="#5-2-객체-밀봉" class="headerlink" title="5.2. 객체 밀봉"></a>5.2. 객체 밀봉</h2><p>Object.seal 메소드는 객체를 밀봉한다. 객체 밀봉(seal)이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지를 의미한다. 즉, 밀봉된 객체는 읽기와 쓰기만 가능하게 된다.</p>
<p>밀봉된 객체인지 여부는 Object.isSealed 메소드로 확인 할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123; name: &#39;Lee&#39; &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체는 밀봉(seal)된 객체가 아니다.</span><br><span class="line">console.log(Object.isSealed(person)); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체를 밀봉(seal)하여 프로퍼티 추가, 삭제, 재정의를 금지한다.</span><br><span class="line">Object.seal(person);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체는 밀봉(seal)된 객체다.</span><br><span class="line">console.log(Object.isSealed(person)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 밀봉(seal)된 객체는 configurable가 false이다.</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(person));</span><br><span class="line">&#x2F;*</span><br><span class="line">&#123;</span><br><span class="line">  name: &#123;value: &quot;Lee&quot;, writable: true, enumerable: true, configurable: false&#125;,</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 추가가 금지된다.</span><br><span class="line">person.age &#x3D; 20; &#x2F;&#x2F; 무시. strict mode에서는 에러</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 삭제가 금지된다.</span><br><span class="line">delete person.name; &#x2F;&#x2F; 무시. strict mode에서는 에러</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 값 갱신은 가능하다.</span><br><span class="line">Object.defineProperty(person, &#39;name&#39;, &#123; value: &#39;Kim&#39; &#125;);</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Kim&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 어트리뷰트 재정의가 금지된다.</span><br><span class="line">Object.defineProperty(person, &#39;name&#39;, &#123; configurable: true &#125;);</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot redefine property: name</span><br></pre></td></tr></table></figure>
<br>

<h2 id="5-3-객체-동결"><a href="#5-3-객체-동결" class="headerlink" title="5.3. 객체 동결"></a>5.3. 객체 동결</h2><p>Object.freeze 메소드는 객체를 동결한다. 객체 동결(freeze)이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다. 즉, <strong>동결된 객체는 읽기만 가능하게 된다.</strong></p>
<p>밀봉된 객체인지 여부는 Object.isFrozen 메소드로 확인 할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123; name: &#39;Lee&#39; &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체는 동결(freeze)된 객체가 아니다.</span><br><span class="line">console.log(Object.isFrozen(person)); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체를 동결(freeze)하여 프로퍼티 추가, 삭제, 재정의, 쓰기를 금지한다.</span><br><span class="line">Object.freeze(person);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; person 객체는 동결(freeze)된 객체다.</span><br><span class="line">console.log(Object.isFrozen(person)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 동결(freeze)된 객체는 writable과 configurable가 false이다.</span><br><span class="line">console.log(Object.getOwnPropertyDescriptors(person));</span><br><span class="line">&#x2F;*</span><br><span class="line">&#123;</span><br><span class="line">  name: &#123;value: &quot;Lee&quot;, writable: false, enumerable: true, configurable: false&#125;,</span><br><span class="line">&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 추가가 금지된다.</span><br><span class="line">person.age &#x3D; 20; &#x2F;&#x2F; 무시. strict mode에서는 에러</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 삭제가 금지된다.</span><br><span class="line">delete person.name; &#x2F;&#x2F; 무시. strict mode에서는 에러</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 값 갱신이 금지된다.</span><br><span class="line">person.name &#x3D; &#39;Kim&#39;; &#x2F;&#x2F; 무시. strict mode에서는 에러</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 프로퍼티 어트리뷰트 재정의가 금지된다.</span><br><span class="line">Object.defineProperty(person, &#39;name&#39;, &#123; value: &#39;Kim&#39; &#125;);</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot redefine property: name</span><br></pre></td></tr></table></figure>

<br>

<h2 id="5-4-불변객체"><a href="#5-4-불변객체" class="headerlink" title="5.4. 불변객체"></a>5.4. 불변객체</h2><p>지금까지 살펴본 변경 방지 메소드들은 얕은 변경 방지(Shallow only)로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 못하다. 따라서 Object.freeze 메소드로 객체를 동결하여도 중첩 객체까지 동결할 수 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#123; city: &#39;Seoul&#39; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 얕은 객체 동결</span><br><span class="line">Object.freeze(person);</span><br><span class="line"></span><br><span class="line">console.log(Object.isFrozen(person)); &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 중첩 객체까지 동결하지 못한다.</span><br><span class="line">console.log(Object.isFrozen(person.address)); &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">person.address.city &#x3D; &#39;Busan&#39;;</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;, address: &#123;city: &quot;Busan&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변 객체(immutable object, “12.6. 참조에 의한 전달과 외부 상태의 변경” 참고)를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메소드를 호출해야 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(target) &#123;</span><br><span class="line">  &#x2F;&#x2F; 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않은 객체만 동결한다.</span><br><span class="line">  if (target &amp;&amp; typeof target &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; !Object.isFrozen(target)) &#123;</span><br><span class="line">    Object.freeze(target);</span><br><span class="line">    &#x2F;*</span><br><span class="line">      모든 프로퍼티를 순회하며 재귀적으로 동결한다.</span><br><span class="line">      Object.keys 메소드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다.</span><br><span class="line">      (&quot;19.15.2. Object.keys&#x2F;values&#x2F;entries 메소드&quot; 참고)</span><br><span class="line">      forEach 메소드는 배열을 순회하며 배열의 각 요소에 대하여 콜백 함수를 실행한다.</span><br><span class="line">      (&quot;27.9.2. Array.prototype.forEach&quot; 참고)</span><br><span class="line">    *&#x2F;</span><br><span class="line">    Object.keys(target).forEach(key &#x3D;&gt; deepFreeze(target[key]));</span><br><span class="line">  &#125;</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;,</span><br><span class="line">  address: &#123; city: &#39;Seoul&#39; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 깊은 객체 동결</span><br><span class="line">deepFreeze(person);</span><br><span class="line"></span><br><span class="line">console.log(Object.isFrozen(person)); &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 중첩 객체까지 동결한다.</span><br><span class="line">console.log(Object.isFrozen(person.address)); &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">person.address.city &#x3D; &#39;Busan&#39;;</span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Lee&quot;, address: &#123;city: &quot;Seoul&quot;&#125;&#125;</span><br></pre></td></tr></table></figure>
        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-03-03T11:02:03.000Z">2020-03-03</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/JavaScript/">JavaScript</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/JavaScript/vue-js/">vue.js</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    11 minutes read (About 1635 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/03/%EC%83%9D%EC%84%B1%EC%9E%90%ED%95%A8%EC%88%98/">생성자 함수에 의한 객체 생성 | javaScript</a>
            
        </h1>
        <div class="content">
            <h1 id="1-Object-생성자-함수"><a href="#1-Object-생성자-함수" class="headerlink" title="1. Object 생성자 함수"></a>1. Object 생성자 함수</h1><p>new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후에는 프로퍼티나 메소드 추가 가능</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 프로퍼티, 메서드 동적 추가</span></span><br><span class="line">person.name = <span class="string">'이남권'</span>;</span><br><span class="line">person.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Hi My name is'</span> + <span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person) <span class="comment">// &#123;name: "Lee", sayHello: f&#125;</span></span><br><span class="line">person.sayHello(); <span class="comment">// Hi My name is 이남권</span></span><br></pre></td></tr></table></figure>

<p>생성자(constructor)함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// String 생성자 함수에 의한 String 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> strObj = <span class="keyword">new</span> string(<span class="string">'이남권'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> strObj); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(strObj); <span class="comment">// 이남권</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Number 생성자 함수에 의한 Number 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> numObj = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> numObj); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(numObj); <span class="comment">// Number &#123;123&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Boolean 생성자 함수에 의한 Boolean 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> boolObj= <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> boolObj); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(boolObj);        <span class="comment">// Boolean &#123;true&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function 생성자 함수에 의한 Function 객체(함수) 생성</span></span><br><span class="line"><span class="keyword">const</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>, <span class="string">'return x * x'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> func); <span class="comment">// function</span></span><br><span class="line"><span class="built_in">console</span>.dir(func);        <span class="comment">// ƒ anonymous(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Array 생성자 함수에 의한 Array 객체(배열) 생성</span></span><br><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> arr); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(arr);        <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성</span></span><br><span class="line"><span class="keyword">const</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/ab+c/i</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> regExp); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(regExp);        <span class="comment">// /ab+c/i</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Date 생성자 함수에 의한 Date 객체 생성</span></span><br><span class="line"><span class="keyword">const</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> date); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(date);        <span class="comment">// Fri Feb 14 2020 17:17:59 GMT+0900 (대한민국 표준시)</span></span><br></pre></td></tr></table></figure>
<p><br><br></p>
<h1 id="2-생성자-함수"><a href="#2-생성자-함수" class="headerlink" title="2.생성자 함수"></a>2.생성자 함수</h1><br>

<h2 id="2-1-객체-리터럴에-의한-객체-생성-방식의-문제점"><a href="#2-1-객체-리터럴에-의한-객체-생성-방식의-문제점" class="headerlink" title="2.1. 객체 리터럴에 의한 객체 생성 방식의 문제점"></a>2.1. 객체 리터럴에 의한 객체 생성 방식의 문제점</h2><p>객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만을 생성한다. 따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우, 매번 같은 프로퍼티를 기술해야 하기 떄문에 비효율적이다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> circle1 = &#123;</span><br><span class="line">  radius: <span class="number">5</span>,</span><br><span class="line">  getDiameter() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> circle2 = &#123;</span><br><span class="line">  radius: <span class="number">10</span>,</span><br><span class="line">  getDiameter() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>

<p>위 예제처럼 객체가 한두개라면 넘어갈 수도 있겠지만 만약 수십개의 객체를 생성해야 한다면 문제가 크다.<br><br></p>
<h2 id="2-2-생성자-함수에-의한-객체-생성-방식의-장점"><a href="#2-2-생성자-함수에-의한-객체-생성-방식의-장점" class="headerlink" title="2.2. 생성자 함수에 의한 객체 생성 방식의 장점"></a>2.2. 생성자 함수에 의한 객체 생성 방식의 장점</h2><p>생성자 함수에 의한 객체 생성 방식은 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 생성자 함수</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Circle</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다.</span></span><br><span class="line">  <span class="keyword">this</span>.radius = radius;</span><br><span class="line">  <span class="keyword">this</span>.getDiameter = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * <span class="keyword">this</span>.radius;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 인스턴스의 생성</span></span><br><span class="line"><span class="keyword">const</span> circle1 = <span class="keyword">new</span> Circle(<span class="number">5</span>);  <span class="comment">// 반지름이 5인 Circle 객체를 생성</span></span><br><span class="line"><span class="keyword">const</span> circle2 = <span class="keyword">new</span> Circle(<span class="number">10</span>); <span class="comment">// 반지름이 10인 Circle 객체를 생성</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(circle1.getDiameter()); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(circle2.getDiameter()); <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<br>

<pre><code>this
this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수이다.this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다.</code></pre><br>

<table>
<thead>
<tr>
<th>함수 호출 방식</th>
<th>this가 가리키는 값</th>
</tr>
</thead>
<tbody><tr>
<td>일반 함수로서 호출</td>
<td>전역 객체</td>
</tr>
<tr>
<td>메소드로서 호출</td>
<td>메소드를 호출한 객체</td>
</tr>
<tr>
<td>생성자 함수로서 호출</td>
<td>생성자 함수가 (미래에) 생성할 인스턴스</td>
</tr>
</tbody></table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수는 다양한 방식으로 호출될 수 있다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반적인 함수로서 호출</span></span><br><span class="line"><span class="comment">// 전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global을 가리킨다.</span></span><br><span class="line">foo(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 메소드로서 호출</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; foo &#125;; <span class="comment">// ES6 프로퍼티 축약 표현</span></span><br><span class="line">obj.foo(); <span class="comment">// obj</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수로서 호출</span></span><br><span class="line"><span class="keyword">const</span> inst = <span class="keyword">new</span> foo(); <span class="comment">// inst</span></span><br></pre></td></tr></table></figure>

<p>this에 대해서는 나중에 자세히 살펴보자.</p>
<p>생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수이다.<br>만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다.</span></span><br><span class="line"><span class="comment">// 즉, 일반적인 함수의 호출이다.</span></span><br><span class="line"><span class="keyword">const</span> circle3 = Circle(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 함수 Circle은 반환문이 없으므로 암묵적으로 undefined를 반환한다.</span></span><br><span class="line"><span class="built_in">console</span>.log(circle3); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반 함수 Circle내의 this는 전역 객체를 가리킨다.</span></span><br><span class="line"><span class="built_in">console</span>.log(radius); <span class="comment">// 15</span></span><br></pre></td></tr></table></figure>

<h2 id="2-3-내부-메소드-Call-과-Construct"><a href="#2-3-내부-메소드-Call-과-Construct" class="headerlink" title="2.3. 내부 메소드 [[Call]]과 [[Construct]]"></a>2.3. 내부 메소드 [[Call]]과 [[Construct]]</h2><p>함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. 생성자 함수로서 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성하는 것을 의미한다.</p>
<p>함수는 객체이므로 일반 객체(Ordinary object)와 동일하게 동작할 수 있다. 즉, 함수 객체는 일반 객체의 내부 슬롯과 내부 메소드(“15.2 내부 슬롯/메소드” 참고)를 모두 가지고 있다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 함수는 객체이다.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 프로퍼티를 소유할 수 있다.</span></span><br><span class="line">foo.prop = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 함수는 객체이므로 메소드를 소유할 수 있다.</span></span><br><span class="line">foo.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.prop);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.method(); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>함수 객체는 함수로서 동작하기 위해 일반 객체의 내부 슬롯과 내부 메소드 이외에 아래와 같은 내부 슬롯과 내부 메소드를 추가적으로 가지고 있다.<br>내부 메소드[[Call]]을 갖는 함수 객체를 Callable이라 하며, 내부 메소드인[[Construct]]를 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않는 함수 객체를 non-constructor라고 부른다.</p>
<p>callable은 호출할 수 있는 객체, 즉 함수를 말하며, constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다. 생성자 함수로서 호출할 수 있다는 것은 new 연산자(또는 super 연산자)와 함께 호출하는 것을 의미한다.</p>
<p>함수가 일반적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 호출되고 new 연산자(또는 super 연산자)와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 일반적인 함수로서 호출: [[Call]]이 호출된다.</span></span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 생성자 함수로서 호출: [[Construct]]가 호출된다.</span></span><br><span class="line"><span class="keyword">new</span> foo();</span><br></pre></td></tr></table></figure>


        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-03-02T04:53:10.000Z">2020-03-02</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    32 minutes read (About 4842 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/03/let_const/">let과 const | javaScript</a>
            
        </h1>
        <div class="content">
            <ol>
<li>var 키워드로 선언한 변수의 문제점<br>ES5까지 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었다. var 키워드로 선언된 변수는 아래와 같은 특징이 있다. 이는 다른 언어와는 구별되는 독특한 특징으로 주의를 기울이지 않으면 심각한 문제를 발생시킬 수 있다..<br>

</li>
</ol>
<h1 id="1-1-변수-중복-선언-허용"><a href="#1-1-변수-중복-선언-허용" class="headerlink" title="1.1. 변수 중복 선언 허용"></a>1.1. 변수 중복 선언 허용</h1><p>var 키워드로 선언한 변수는 중복 선언이 가능하다. 아래 예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.</span><br><span class="line">&#x2F;&#x2F; 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.</span><br><span class="line">var x &#x3D; 100;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 100</span><br></pre></td></tr></table></figure>
<p>위 예제의 변수 x는 중복 선언되었다. 이처럼 같은 스코프 내에서 변수를 중복 선언하면 나중에 작성된 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다. 이때 에러는 발생하지 않는다.</p>
<p>위 예제와 같이 만약 동일한 변수 이름이 이미 선언되어 있는 것을 모르고 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수값이 변경되는 부작용이 발생한다. 따라서 변수의 중복 선언은 문법적으로 허용되지만 사용하지 않는 것이 좋다.<br><br></p>
<h1 id="1-2-함수-레벨-스코프"><a href="#1-2-함수-레벨-스코프" class="headerlink" title="1.2. 함수 레벨 스코프"></a>1.2. 함수 레벨 스코프</h1><p>var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언하여도 모두 전역 변수가 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">if (true) &#123;</span><br><span class="line">  &#x2F;&#x2F; x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 변수 x는 중복 선언된다.</span><br><span class="line">  &#x2F;&#x2F; 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다.</span><br><span class="line">  var x &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(x); &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure>
<p>for 문의 변수 선언문에서 var 키워드로 선언한 변수도 전역 변수가 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var i &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; for문에서 선언한 i는 전역 변수이다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.</span><br><span class="line">for (var i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">  console.log(i); &#x2F;&#x2F; 0 1 2 3 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 의도치 않게 변수의 값이 변경되었다.</span><br><span class="line">console.log(i); &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>

<p>함수 레벨 스코프는 전역 변수를 남발할 가능성을 높인다. 이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생한다.<br><br></p>
<h1 id="1-3-변수-호이스팅"><a href="#1-3-변수-호이스팅" class="headerlink" title="1.3. 변수 호이스팅"></a>1.3. 변수 호이스팅</h1><p>var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 이 시점에는 변수 호이스팅에 의해 이미 변수 foo가 선언되었다. (1. 선언 단계)</span><br><span class="line">&#x2F;&#x2F; 변수 foo는 undefined로 초기화된다. (2. 초기화 단계)</span><br><span class="line">console.log(foo); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 변수에 값을 할당 (3. 할당 단계)</span><br><span class="line">foo &#x3D; 123;</span><br><span class="line"></span><br><span class="line">console.log(foo); &#x2F;&#x2F; 123</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행된다.</span><br><span class="line">var foo;</span><br></pre></td></tr></table></figure>

<p>변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다.<br><br></p>
<h1 id="2-let-키워드"><a href="#2-let-키워드" class="headerlink" title="2. let 키워드"></a>2. let 키워드</h1><p>앞에서 살펴본 var 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 선언 키워드 let과 const를 도입하였다. var 키워드와의 차이점을 중심으로 let 키워드에 대해 살펴보자.<br><br></p>
<h1 id="2-1-변수-중복-선언-금지"><a href="#2-1-변수-중복-선언-금지" class="headerlink" title="2.1. 변수 중복 선언 금지"></a>2.1. 변수 중복 선언 금지</h1><p>var 키워드로 동일한 이름을 갖는 변수를 중복 선언하면 아무런 에러가 발생하지 않는다. 이때 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수값이 재할당되어 변경되는 부작용이 발생한다.</p>
<p>하지만 let 키워드로 동일한 이름을 갖는 변수를 중복 선언하면 문법 에러(SyntaxError)가 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; 123;</span><br><span class="line">&#x2F;&#x2F; var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.</span><br><span class="line">&#x2F;&#x2F; 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.</span><br><span class="line">var foo &#x3D; 456;</span><br><span class="line"></span><br><span class="line">let bar &#x3D; 123;</span><br><span class="line">&#x2F;&#x2F; let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.</span><br><span class="line">let bar &#x3D; 456; &#x2F;&#x2F; SyntaxError: Identifier &#39;bar&#39; has already been declared</span><br></pre></td></tr></table></figure>
<br>

<h1 id="2-2-블록-레벨-스코프"><a href="#2-2-블록-레벨-스코프" class="headerlink" title="2.2. 블록 레벨 스코프"></a>2.2. 블록 레벨 스코프</h1><p>var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정하는 함수 레벨 스코프를 따른다. 하지만 let 키워드로 선언한 변수는 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 을 지역 스코프로 인정하는 블록 레벨 스코프(Block-level scope)를 따른다. 아래 예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let foo &#x3D; 123; &#x2F;&#x2F; 전역 변수</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  let foo &#x3D; 456; &#x2F;&#x2F; 지역 변수</span><br><span class="line">  let bar &#x3D; 456; &#x2F;&#x2F; 지역 변수</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foo); &#x2F;&#x2F; 123</span><br><span class="line">console.log(bar); &#x2F;&#x2F; ReferenceError: bar is not defined</span><br></pre></td></tr></table></figure>

<p>let 키워드로 선언된 변수는 블록 레벨 스코프를 따른다. 따라서 위 예제에서 코드 블록 내에 선언된 변수 foo와 지역 변수이다. 전역에서 선언된 변수 foo와는 다른 별개의 변수이다. 또한 변수 bar도 블록 레벨 스코프를 갖는 지역 변수이다. 따라서 전역에서는 변수 bar를 참조할 수 없다.</p>
<p>함수도 코드 블록이므로 스코프를 만든다. 이때 함수 내의 코드 블록은 함수 레벨 스코프에 중첩된다.<br><img src="https://poiemaweb.com/assets/fs-images/15-1.png" alt=""></p>
<p>블록 레벨 스코프의 중첩</p>
<h1 id="2-3-변수-호이스팅"><a href="#2-3-변수-호이스팅" class="headerlink" title="2.3. 변수 호이스팅"></a>2.3. 변수 호이스팅</h1><p>var 키워드로 선언한 변수와는 달리 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다. 아래 예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(foo); &#x2F;&#x2F; ReferenceError: foo is not defined</span><br><span class="line">let foo;</span><br><span class="line">이처럼 let 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다.</span><br></pre></td></tr></table></figure>

<p>“4.3. 변수 선언”에서 살펴본 바와 같이 var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 “선언 단계”와 “초기화 단계”가 한번에 진행된다. 즉, 선언 단계에서 스코프(실행 컨텍스트의 렉시컬 환경(Lexical Environment))에 변수 식별자를 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 그리고 즉시 초기화 단계에서 undefined로 변수를 초기화한다. 따라서 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이후 변수 할당문에 도달하면 비로소 값이 할당된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; var 키워드로 선언한 변수는 런타임 이전에 선언 단계와 초기화 단계가 실행된다.</span><br><span class="line">&#x2F;&#x2F; 따라서 변수 선언문 이전에 변수를 참조할 수 있다.</span><br><span class="line">console.log(foo); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">var foo;</span><br><span class="line">console.log(foo); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">foo &#x3D; 1; &#x2F;&#x2F; 할당문에서 할당 단계가 실행된다.</span><br><span class="line">console.log(foo); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<p><img src="https://poiemaweb.com/assets/fs-images/15-2.png" alt=""></p>
<p>var 키워드로 선언한 변수의 생명 주기</p>
<p>let 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행된다. 즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다.</p>
<p>만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다. 따라서 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지는 변수를 참조할 수 없다. 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 일시적 사각지대(Temporal Dead Zone; TDZ)라고 부른다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 런타임 이전에 선언 단계가 실행된다.</span><br><span class="line">&#x2F;&#x2F; 아직 변수가 초기화되지 않았다. 따라서 변수 선언문 이전에 변수를 참조할 수 없다.</span><br><span class="line">console.log(foo); &#x2F;&#x2F; ReferenceError: foo is not defined</span><br><span class="line"></span><br><span class="line">let foo; &#x2F;&#x2F; 변수 선언문에서 초기화 단계가 실행된다.</span><br><span class="line">console.log(foo); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">foo &#x3D; 1; &#x2F;&#x2F; 할당문에서 할당 단계가 실행된다.</span><br><span class="line">console.log(foo); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<p><img src="https://poiemaweb.com/assets/fs-images/15-3.png" alt=""></p>
<p>let 키워드로 선언한 변수의 생명 주기</p>
<p>결국 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 보인다. 하지만 그렇지 않다. 아래 예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let foo &#x3D; 1; &#x2F;&#x2F; 전역 변수</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  console.log(foo); &#x2F;&#x2F; ReferenceError: foo is not defined</span><br><span class="line">  let foo &#x3D; 2; &#x2F;&#x2F; 지역 변수</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>let 키워드로 선언한 변수의 경우, 변수 호이스팅 발생하지 않는다면 위 예제는 전역 변수 foo의 값을 출력해야 한다. 하지만 let 키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조 에러(ReferenceError)가 발생한다.</p>
<p>자바스크립트는 ES6에서 도입된 let, const를 포함하여 모든 선언(var, let, const, function, function*, class 등)을 호이스팅한다. 단, ES6에서 도입된 let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.<br><br></p>
<h1 id="2-4-전역-객체와-let"><a href="#2-4-전역-객체와-let" class="headerlink" title="2.4. 전역 객체와 let"></a>2.4. 전역 객체와 let</h1><p>전역 객체(Global Object, “21.4. 전역 객체” 참고)는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다. 전역 객체는 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 가리킨다.</p>
<p>var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역(“21.4.3. 암묵적 전역” 참고) 그리고 전역 함수는 전역 객체의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 이 예제는 브라우저 환경에서 실행시켜야 한다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 전역 변수</span><br><span class="line">var x &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; 암묵적 전역</span><br><span class="line">y &#x3D; 2;</span><br><span class="line">function foo() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티이다.</span><br><span class="line">console.log(window.x); &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span><br><span class="line">console.log(x); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 암묵적 전역은 전역 객체의 프로퍼티이다.</span><br><span class="line">console.log(window.y); &#x2F;&#x2F; 2</span><br><span class="line">console.log(y); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이다.</span><br><span class="line">console.log(window.foo); &#x2F;&#x2F; ƒ foo() &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.</span><br><span class="line">console.log(foo); &#x2F;&#x2F; ƒ foo() &#123;&#125;</span><br><span class="line">let 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다. 즉, window.foo와 같이 접근할 수 없다. let 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드. 이에 대해서는 “23. 실행 컨텍스트”에서 자세히 살펴볼 것이다.) 내에 존재하게 된다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 이 예제는 브라우저 환경에서 실행시켜야 한다.</span><br><span class="line">let x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.</span><br><span class="line">console.log(window.x); &#x2F;&#x2F; undefined</span><br><span class="line">console.log(x); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<br>

<h1 id="3-const-키워드"><a href="#3-const-키워드" class="headerlink" title="3. const 키워드"></a>3. const 키워드</h1><p>const 키워드는 상수(constant)를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다. 이에 대해서는 후반부에 설명한다. const의 특징은 let과 대부분 동일하므로 let과 다른 점을 중심으로 살펴보도록 하자.<br><br></p>
<h1 id="3-1-선언과-초기화"><a href="#3-1-선언과-초기화" class="headerlink" title="3.1. 선언과 초기화"></a>3.1. 선언과 초기화</h1><p>const 키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; 1;</span><br><span class="line">그렇지 않으면 아래와 같이 문법 에러(SyntaxError)가 발생한다.</span><br><span class="line"></span><br><span class="line">const foo; &#x2F;&#x2F; SyntaxError: Missing initializer in const declaration</span><br><span class="line">const 키워드로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로 블록 레벨 스코프를 가지며 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &#x2F;&#x2F; 변수 호이스팅이 발생하지 않는 것처럼 동작한다</span><br><span class="line">  console.log(foo); &#x2F;&#x2F; ReferenceError: Cannot access &#39;foo&#39; before initialization</span><br><span class="line">  const foo &#x3D; 1;</span><br><span class="line">  console.log(foo); &#x2F;&#x2F; 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 블록 레벨 스코프를 갖는다.</span><br><span class="line">console.log(foo); &#x2F;&#x2F; ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure>
<br>

<h1 id="3-2-재할당-금지"><a href="#3-2-재할당-금지" class="headerlink" title="3.2. 재할당 금지"></a>3.2. 재할당 금지</h1><p>var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const foo &#x3D; 1;</span><br><span class="line">foo &#x3D; 2; &#x2F;&#x2F; TypeError: Assignment to constant variable.</span><br></pre></td></tr></table></figure>
<br>

<h1 id="3-3-상수"><a href="#3-3-상수" class="headerlink" title="3.3. 상수"></a>3.3. 상수</h1><p>const 키워드로 선언한 변수에 원시값을 할당한 경우, 변수값을 변경할 수 없다. 원시값은 변경 불가능한 값(immutable value)이므로 재할당없이 값을 변경할 수 있는 방법이 없기 때문이다. 이러한 특징을 이용해 const 키워드를 상수를 표현하는 데 사용하기도 한다.</p>
<p>변수의 상대 개념인 상수는 재할당이 금지된 변수를 말한다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다. 단, 변수는 언제든지 재할당을 통해 변수값을 변경할 수 있지만 상수는 재할당이 금지된다.</p>
<p>상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 한다. 아래 예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 세전 가격</span><br><span class="line">let preTaxPrice &#x3D; 100;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 세후 가격</span><br><span class="line">&#x2F;&#x2F; 0.1의 의미를 명확히 알기 어렵기 때문에 가독성이 좋지 않다.</span><br><span class="line">let afterTaxPrice &#x3D; preTaxPrice + (preTaxPrice * 0.1);</span><br><span class="line"></span><br><span class="line">console.log(afterTaxPrice); &#x2F;&#x2F; 110</span><br></pre></td></tr></table></figure>

<p>코드 내에서 사용한 0.1은 어떤 의미로 사용하였는지 명확히 알기 어렵기 때문에 가독성이 좋지 않다. 또한 세율을 의미하는 0.1은 쉽게 바뀌지 않는 값이며 프로그램 전체에서 고정된 값을 사용해야 한다. 이때 세율을 상수로 정의하면 값의 의미를 쉽게 파악할 수 있고 변경될 수 없는 고정값으로 사용할 수 있다.</p>
<p>일반적으로 상수의 이름은 대문자로 선언하여 상수임을 명확히 나타낸다. 여러 단어로 이루어진 경우에는 언더스코어(_)로 구분하여 스네이크 케이스로 표현하는 것이 일반적이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 세율을 의미하는 0.1은 변경할 수 없는 상수로서 사용될 값이다.</span><br><span class="line">&#x2F;&#x2F; 변수 이름을 대문자로 선언하여 상수임을 명확히 나타낸다.</span><br><span class="line">const TAX_RATE &#x3D; 0.1;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 세전 가격</span><br><span class="line">let preTaxPrice &#x3D; 100;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 세후 가격</span><br><span class="line">let afterTaxPrice &#x3D; preTaxPrice + (preTaxPrice * TAX_RATE);</span><br><span class="line"></span><br><span class="line">console.log(afterTaxPrice); &#x2F;&#x2F; 110</span><br></pre></td></tr></table></figure>
<p>const 키워드로 선언된 변수는 재할당이 금지된다. const 키워드로 선언된 변수에 원시 값을 할당한 경우, 원시 값은 변경할 수 없는 값(immutable value)이고 const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다. 또한 상수는 프로그램 전체에서 공통 사용하므로 나중에 세율이 변경되면 상수만을 변경하면 되기 때문에 유지보수성이 대폭 향상된다.<br><br></p>
<h1 id="3-3-const-키워드와-객체"><a href="#3-3-const-키워드와-객체" class="headerlink" title="3.3. const 키워드와 객체"></a>3.3. const 키워드와 객체</h1><p>const 키워드로 선언된 변수에 원시값을 할당한 경우, 값을 변경할 수 없다. 하지만 const 키워드로 선언된 변수에 객체를 할당한 경우, 값을 변경할 수 있다. 변경 불가능한 값인 원시값은 재할당없이 변경(교체)할 수 있는 방법이 없지만 변경 가능한 값인 객체는 재할당없이도 직접 변경이 가능하기 때문이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;</span><br><span class="line">  name: &#39;Lee&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 객체는 변경 가능한 값이다. 따라서 재할당없이 변경이 가능하다.</span><br><span class="line">person.name &#x3D; &#39;Kim&#39;;</span><br><span class="line"></span><br><span class="line">console.log(person); &#x2F;&#x2F; &#123;name: &quot;Kim&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>“11.1.1. 변경 불가능한 값”에서 살펴본 바와 같이, const 키워드는 재할당을 금지할 뿐 “불변(immutable)”을 의미하지는 않는다. 다시 말해, 새로운 값을 재할당하는 것은 불가능하지만 객체의 내용(프로퍼티의 추가, 삭제, 프로퍼티 값의 변경)을 변경하는 것은 가능하다. 객체의 내용이 변경되더라도 변수에 할당된 참조값은 변경되지 않는다.<br><br></p>
<h1 id="4-var-vs-let-vs-const"><a href="#4-var-vs-let-vs-const" class="headerlink" title="4. var vs. let vs. const"></a>4. var vs. let vs. const</h1><p>변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다. 원시 값의 경우, 가급적 상수를 사용하는 편이 좋다. 그리고 객체를 재할당하는 경우는 생각보다 흔하지 않다. const 키워드를 사용하면 의도치 않은 재할당을 방지해 주기 때문에 보다 안전하다.<br>var와 let, 그리고 const 키워드는 다음처럼 사용하는 것을 추천한다.</p>
<p>ES6를 사용한다면 var 키워드는 사용하지 않는다.<br>재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.<br>변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다.<br>변수를 선언하는 시점에는 재할당이 필요할지 잘 모르는 경우가 많다. 그리고 객체는 의외로 재할당을 하는 경우가 드물다.(Angular, React, Vue.js와 같은 SPA 프레임워크의 경우, 상태가 변경되었음을 알리기 위해 객체를 재할당하는 경우도 있다.) 따라서 변수를 선언할 때에는 일단 const 키워드를 사용하도록 하자. 반드시 재할당이 필요하다면(반드시 재할당이 필요한지 한번 생각해 볼 일이다.) 그때 const 키워드를 let 키워드로 변경해도 결코 늦지 않는다.</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-26T04:53:10.000Z">2020-02-26</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    an hour read (About 10857 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/02/function/">함수 | javaScript</a>
            
        </h1>
        <div class="content">
            <h1 id="1-함수란"><a href="#1-함수란" class="headerlink" title="1. 함수란?"></a>1. 함수란?</h1><p>함수는 자바스크립트에서 가장 중요한 핵심 개념입니다. 다른 자바스크립트의 핵심 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메소드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있습니다. 따라서 함수는 자바스크립트를 정확히 이해하고 넘어 가야하는 핵심 중의 핵심이라고 할 수 있습니다.</p>
<p>프로그래밍 언어의 함수도 수학의 함수와 같은 개념입니다. 함수 f(x,y) = x + y를 자바스크립트의 함수로 표현해 봅시다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5) &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>

<p>프로그래밍 언어의 <strong>함수는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것입니다.</strong></p>
<p>함수 내부로 입력을 전달받는 변수를 <strong>매개변수(parameter)</strong>, 입력을 <strong>(argument)</strong>, 출력을 <strong>반환값(return value)</strong>이라 한다. 또한 함수는 값이며 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다.</p>
<p>함수는 <strong>함수 정의</strong>를 통해 생성한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>함수 정의만으로 함수가 실행되지 않는다. 인수를 매개변수를 통해 함수에 전달해야하다. 이를 <strong>함수 호출</strong>이라 한다. 함수를 호출하면 코드 블록에 담긴 무늘이 일괄적으로 실행되고 실행 결과, 반환값을 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 호출</span><br><span class="line">var result &#x3D; add(2, 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 add에 인수 2, 5를 전달하면서 호출하면 반환값 7을 반환한다.</span><br><span class="line">console.log(result); &#x2F;&#x2F;7</span><br></pre></td></tr></table></figure>

<h1 id="2-함수의-사용-이유"><a href="#2-함수의-사용-이유" class="headerlink" title="2. 함수의 사용 이유"></a>2. 함수의 사용 이유</h1><p>함수는 필요할 떄 여러 번 호출할 수 있다. 함수는 몇 번이든 호출할 수 있으므로 <strong>코드의 재사용</strong>이라는 측면에서 매우 유용하다.</p>
<p>함수를 사용하지 않고 같은 코드를 중복해서 여러 번 작성하면 그 코드를 수정해야 할 떄 중복된 횟수만큼 코드를 수정해야 한다. 코드의 중복을 억제하고 재사용성을 높이는 <strong>함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다.</strong></p>
<p><strong>함수는 객체 타입의 값이다.</strong> 따라서 이름(식별자)을 붙일 수 있다.함수 이름은 변수 이름과 마찬가지로 함수 자신의 역할을 잘 설명해야 한다.</p>
<h1 id="3-함수-리터럴"><a href="#3-함수-리터럴" class="headerlink" title="3. 함수 리터럴"></a>3. 함수 리터럴</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 변수에 함수 리터럴을 할당</span><br><span class="line">var add &#x3D; function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>함수 리터럴의 구성 요소에 대한 설명은 아래와 같다.</p>
<ul>
<li><p>함수 이름</p>
<ul>
<li>함수 이름은 식별자이다. 따라서 식별자 네이밍 규칙을 준수해야 한다.</li>
<li>함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이다.</li>
<li>함수 이름은 생략할 수 있다. 함수 이름이 있는 함수를 기명함수, 이름이 없는 함수를 익명함수라 한다.</li>
</ul>
</li>
<li><p>매개변수 목록</p>
<ul>
<li>0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다.</li>
<li>매개변수에는 함수호출문의 인수가 순서대로 할당된다.</li>
<li>매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다.</li>
</ul>
</li>
<li><p>함수 몸체</p>
<ul>
<li>함수가 호출되었을 떄 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다.</li>
<li>함수 몸체는 함수 호출에 의해 실행된다.</li>
</ul>
</li>
</ul>
<p>리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식을 말한다. 따라서 함수 리터럴도 평가되어 값을 생성하며 이 값은 객체다. 즉, <strong>함수는 객체다.</strong></p>
<p>함수는 객체이지만 일반 객체와는 다르다. <strong>일반 객체는 호출할 수 없지만 함수는 호출할 수 있다.</strong> 그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다.</p>
<h1 id="4-함수-정의"><a href="#4-함수-정의" class="headerlink" title="4. 함수 정의"></a>4. 함수 정의</h1><p>함수를 정의 하는 방법은 4가지가 있다.</p>
<ul>
<li><p>함수 선언문</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>함수 표현식</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; function(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Function 생성자 함수</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x + y&#39;);</span><br></pre></td></tr></table></figure>
</li>
<li><p>화살표 함수:ES6</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; (x, y) &#x3D;&gt; x + y;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>각각의 함수 정의 방식은 함수를 정의한다는 면에서는 동일하다. 단 미묘하지만 중요한 차이가 있다.</p>
<pre><code>변수 선언과 함수 정의
함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. 따라서 ECMAScript 사양에서도 변수는 선언, 함수는 정의라고 표현하고 있다.</code></pre><h2 id="4-1-함수-선언문"><a href="#4-1-함수-선언문" class="headerlink" title="4.1. 함수 선언문"></a>4.1. 함수 선언문</h2><p>함수 선언문을 사용하여 함수를 정의하는 방식은 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 참조</span><br><span class="line">console.dir(add); &#x2F;&#x2F; f add(x, y)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;함수 호출</span><br><span class="line">consle.log(add(2, 5)); &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>

<p>함수 선언문은 함수 리터럴과 형태가 동일하다. <strong>함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문은 함수 이름을 생략할 수 없다.</span><br><span class="line">function (x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; syntaxError: Function statements require a function name;</span><br></pre></td></tr></table></figure>

<p><strong>함수 선언문은 표현식이 아닌 문이다.</strong> 즉 함수 선언문을 실행하면 완료값 undefined를 출력한다.<br>함수 선언문이 만약 표현식인 문이라면 완료 값 undefined 대신 표현식이 평가되어 생성된 함수가 출력되어야 한다.</p>
<p><strong>표현식인 문과 표현식이 아닌 문</strong>에서 살펴보았듯이 <strong>표현식이 아닌 문은 변수에 할당할 수 없다.</strong> 함수 선언문도 표현식이 아닌 문이므로 변수에 할당할 수 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.</span><br><span class="line">&#x2F;&#x2F; 하지만 함수 선언문이 변수에 할당되는 것 처럼 보인다.</span><br><span class="line">var add &#x3D; function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 호출</span><br><span class="line">console.log(add(2, 5)); &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>
<p>함수 리터럴을 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석한다.</span><br><span class="line">&#x2F;&#x2F; 함수 선언문은 함수 이름을 생략할 수 없다.</span><br><span class="line">function foo() &#123; console.log(&#39;foo&#39;); &#125;</span><br><span class="line">foo(); &#x2F;&#x2F; foo</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식로 해석한다.</span><br><span class="line">&#x2F;&#x2F; 함수 리터럴은 함수 이름을 생략할 수 있다.</span><br><span class="line">(function bar() &#123; console.log(&#39;bar&#39;); &#125;);</span><br><span class="line">bar(); &#x2F;&#x2F; ReferenceError: bar is not defined</span><br></pre></td></tr></table></figure>

<p>함수 리터럴”에서 “함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다”라고 했다. 이는 함수 몸체 외부에서는 함수 이름으로 함수를 참조할 수 없으므로 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다는 의미이다. 즉, 함수를 가리키는 식별자가 없다는 것과 마찬가지다. 따라서 위 예제의 bar 함수는 호출할 수 없다.</p>
<p>하지만 위 예제에서 함수 선언문으로 정의된 함수는 foo라는 이름으로 호출할 수 있었다. foo는 함수 몸체 내부에서만 유효한 식별자인 함수 이름이므로 foo로 함수를 호출할 수 없어야 한다. foo라는 이름으로 함수를 호출하려면 foo는 함수 이름이 아니라 함수 객체를 할당한 식별자이어야 한다. 그런데 위 예제에는 식별자 foo를 선언한 적도 없고 할당한 적도 없다. foo는 도대체 무엇인가? 결론부터 말하자면 foo는 생성된 함수 객체를 할당하고 있는 자바스크립트 엔진이 암묵적으로 생성한 식별자이다.</p>
<p><strong>함수 선언문은 실행되어 함수 객체를 생성한다. 이떄 함수 이름은 함수 몸체 내부에서만 유효한 식별자 이므로 생성된 함수 객체를 가리키는 식별자가 필요하다.</strong> 함수 객체를 가리키는 식별자가 없으면 생성된 함수 객체를 호출할 수 없고 아무도 참조하고 있지 않는 함수 객체는 가비지 컬렉터에 의해 메모리에서 해제된다. 이를 위해 <strong>자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(add(2, 5)); &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>
<p><strong>함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.</strong><br>즉, 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수 이름 add이 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 add인 것이다.<br><strong>함수의 이름을 그대로 똑같이 식별자에 복사를 하는 것이다.</strong></p>
<p><strong>함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.</strong> 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수 이름 add이 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 add인 것이다. 함수 이름과 변수 이름이 일치하므로 함수 이름으로 호출되는 듯 보이지만 사실은 식별자로 호출된 것이다.</p>
<h2 id="4-2-함수-표현식"><a href="#4-2-함수-표현식" class="headerlink" title="4.2. 함수 표현식"></a>4.2. 함수 표현식</h2><p> 자바스크립트의 함수는 일급 객체이다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다. <strong>함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식(Function expression)이라 한다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 표현식</span><br><span class="line">var add &#x3D; function(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">console.log(add(2, 5)); &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>

<p>함수 리터럴의 함수 이름은 생략할 수 있다. 이러한 함수를 익명 함수(anonymous function)이라 한다. 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다.</p>
<p>함수 선언문에서 살펴본 바와 같이, <strong>함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용하여야 한다. 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름으로 함수를 호출할 수 없다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 기명 함수 표현식</span><br><span class="line">var add &#x3D; function foo (x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 객체를 가리키는 식별자로 호출</span><br><span class="line">console.log(add(2, 5)); &#x2F;&#x2F; 7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 이름으로 호출하면 ReferenceError가 발생한다.</span><br><span class="line">&#x2F;&#x2F; 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.</span><br><span class="line">console.log(foo(2, 5)); &#x2F;&#x2F; ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure>
<p><strong>자바스크립트 엔진은 함수 선언문의 함수 이름으로 식별자를 암묵적 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보인다.</strong></p>
<p>**함수 선언문은 “표현식이 아닌 문”이고 함수 표현식은 “표현식인 문”이다.</p>
<h2 id="4-3-함수-생성-시점과-함수-호이스팅"><a href="#4-3-함수-생성-시점과-함수-호이스팅" class="headerlink" title="4.3 함수 생성 시점과 함수 호이스팅"></a>4.3 함수 생성 시점과 함수 호이스팅</h2><p>아래 예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 참조</span><br><span class="line">console.dir(add); &#x2F;&#x2F; ƒ add(x, y)</span><br><span class="line">console.dir(sub); &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 호출</span><br><span class="line">console.log(add(2, 5)); &#x2F;&#x2F; 7</span><br><span class="line">console.log(sub(2, 5)); &#x2F;&#x2F; TypeError: sub is not a function</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 표현식</span><br><span class="line">var sub &#x3D; function (x, y) &#123;</span><br><span class="line">  return x - y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다. 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다.</strong></p>
<p>모든 선언문이 그러하듯 함수 선언문도 다른 코드가 한줄씩 순차적으로 실행되는 시점, 즉 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 다시 말해, <strong>함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다.</strong> 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다. </p>
<p>즉, 코드가 한줄씩 순차적으로 실행되기 시자하는 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태다.따라서 함수 선어문 이전에 함수를 참조할 수 있으며 호출할 수도 있다. 이런 자바스크립트 고유의 특징을 <strong>함수 호이스팅</strong>이라 한다.</p>
<p>함수 호이스팅과 변수 호이스팅은 미묘한 차이가 있으므로 주의하기 바란다. var 키워드로 사용한 변수 선언문과 함수 선언문은 모두 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일하다. 하지만 var 키워드로 선언된 변수는 undefined로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다. 따라서 var 키워드로 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가되지만 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.</p>
<p>변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만, 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.</p>
<p>따라서 <strong>함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.</strong><br>함수 표현식 이전에 함수를 참조하면 undefined으로 평가된다. 따라서 이때 함수를 호출하면 undefined를 호출하는 것과 마찬가지이므로 타입 에러(TypeError)가 발생한다. <strong>따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출하여야 한다.</strong></p>
<h2 id="4-4-Function-생성자-함수"><a href="#4-4-Function-생성자-함수" class="headerlink" title="4.4 Function 생성자 함수"></a>4.4 Function 생성자 함수</h2><p>자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성하여 반환한다. (사실 new 연산자 없이 호출하여도 결과는 동일하다.)</p>
<p>Function 생성자 함수로 지금까지 살펴본 add 함수를 생성해 봅시다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x + y&#39;);</span><br><span class="line"></span><br><span class="line">console.log(add(2, 5)); &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>

<p>Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; new Function(&#39;x&#39;, &#39;y&#39;, &#39;return x + y&#39;);</span><br><span class="line"></span><br><span class="line">console.log(add(2, 5)); &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>

<h2 id="4-5-화살표-함수"><a href="#4-5-화살표-함수" class="headerlink" title="4.5. 화살표 함수"></a>4.5. 화살표 함수</h2><p>ES6에서 새롭게 도입된 화살표 함수(Arrow function)는 function 키워드 대신 화살표(=&gt;, Fat arrow)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. <strong>화살표 함수는 항상 익명 함수로 정의한다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 화살표 함수</span><br><span class="line">const add &#x3D; (x, y) &#x3D;&gt; x + y;</span><br><span class="line"></span><br><span class="line">console.log(add(2, 5)); &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>
<p>화살표 함수는 생성자 함수로 사용할 수 없으며 기존의 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다.<br><br></p>
<h1 id="5-함수-호출"><a href="#5-함수-호출" class="headerlink" title="5. 함수 호출"></a>5. 함수 호출</h1><p>함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.<br>함수 호출 연산자 내에는 0개 이상의 인수(argument)를 쉼표로 구분하여 나열한다. 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 컨트롤을 넘긴다.</p>
<h2 id="5-1-매개변수와-인수"><a href="#5-1-매개변수와-인수" class="headerlink" title="5.1. 매개변수와 인수"></a>5.1. 매개변수와 인수</h2><p>함수의 실행을 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다. 인수는 값으로 평가될 수 있는 표현식이어야 하며 인수는 함수를 호출할 때 지정하며 개수와 타입에 제한이 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 호출</span><br><span class="line">&#x2F;&#x2F; 인수 1과 2는 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.</span><br><span class="line">var result &#x3D; add(1, 2);</span><br></pre></td></tr></table></figure>

<p>매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당된다. 함수가 호출될 때마다 매개변수는 이와 같은 단계를 거친다.</p>
<p><strong>매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다.</strong><br>즉, 매개변수의 스코프(유효 범위)는 함수 내부이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  console.log(x, y); &#x2F;&#x2F; 2 5</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 add의 매개변수 x, y는 함수 몸체 내부에서만 참조할 수 있다.</span><br><span class="line">console.log(x, y); &#x2F;&#x2F; ReferenceError: x is not defined;</span><br></pre></td></tr></table></figure>

<p>함수는 매개변수의 개수와 인수의 개수를 체크하지 않는다. 즉, 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 에러가 발생하지는 않는다. 인수가 부족하여 인수가 할당되지 않은 매개변수의 값은 undefined이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(2)); &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>
<p>위 예제의 매개변수 x에는 인수 2가 전달되지만, 매개변수 y에는 전달할 인수가 없다. 따라서 매개변수 y는 undefined가 초기화된 상태 그대로이다. 따라서 함수 몸체의 문 x + y는 2 + undefined와 같으므로 NaN이 반환된다.</p>
<p>인수가 매개변수보다 더 많은 경우, 초과되는 인수는 무시된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(2, 5, 10)); &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>

<p><strong>사실 초과된 인수가 그냥 버려지는 것은 아니다. 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  console.log(arguments);</span><br><span class="line">  &#x2F;&#x2F; Arguments(3) [2, 5, 10, callee: ƒ, Symbol(Symbol.iterator): ƒ]</span><br><span class="line"></span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(2, 5, 10);</span><br></pre></td></tr></table></figure>
<p>arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다.</p>
<h2 id="5-2-인수-확인"><a href="#5-2-인수-확인" class="headerlink" title="5.2. 인수 확인"></a>5.2. 인수 확인</h2><p>아래 예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 함수를 정의한 개발자의 의도는 아마도 2개의 숫자 타입 인수를 전달받아 그 합계를 반환하려는 것으로 추측된다. 하지만 코드상으로는 어떤 타입의 인수를 전달하여야 하는지, 어떤 타입의 값을 반환해야 하는지 명확하지 않다. 따라서 위 함수는 아래와 같이 호출될 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(2));        &#x2F;&#x2F; NaN</span><br><span class="line">console.log(add(&#39;a&#39;, &#39;b&#39;)); &#x2F;&#x2F; &#39;ab&#39;</span><br></pre></td></tr></table></figure>
<p>위 코드는 자바스크립트 문법상 어떠한 문제도 없으므로 자바스크립트 엔진은 아무런 이의 제기없이 위 코드를 실행할 것이다. 이러한 상황이 발생한 이유는 아래와 같다.</p>
<ol>
<li>자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.</li>
<li>자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.</li>
</ol>
<p>따라서 자바스크립트의 경우, 함수를 정의할 때 적절한 인수가 전달되었는지 확인이 필요하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  if (typeof x !&#x3D;&#x3D; &#39;number&#39; || typeof y !&#x3D;&#x3D; &#39;number&#39;) &#123;</span><br><span class="line">    throw new TypeError(&#39;매개변수에 숫자 타입이 아닌 값이 할당되었습니다.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(add(2));        &#x2F;&#x2F; TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.</span><br><span class="line">console.log(add(&#39;a&#39;, &#39;b&#39;)); &#x2F;&#x2F; TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.</span><br></pre></td></tr></table></figure>

<h2 id="5-3-매개변수의-최대-개수"><a href="#5-3-매개변수의-최대-개수" class="headerlink" title="5.3. 매개변수의 최대 개수"></a>5.3. 매개변수의 최대 개수</h2><p>ECMAScript 사양에서는 매개변수의 최대 개수에 명시적으로 제한하고 있지 않다.<br>매개변수는 순서에 의미가 있다. 따라서 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 한다. 이는 함수의 사용 방법을 어렵게 만들고 실수를 발생시킬 가능성을 높인다.<br>따라서 <strong>매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다.</strong></p>
<p>객체를 인수로 사용하는 경우, 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경쓰지 않아도 된다. 또한 명시적으로 값의 의미를 설명하는 프로퍼티 키를 사용하게 되므로 코드의 가독성도 좋아지고 실수도 줄어드는 효과가 있다.<br>하지만 <strong>주의할 것은 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수 효과(side-effect)</strong>가 발생한다는 것이다.</p>
<h2 id="5-4-반환문"><a href="#5-4-반환문" class="headerlink" title="5.4. 반환문"></a>5.4. 반환문</h2><p>함수는 return 키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 함수 외부로 반환(return)할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function multiply(x, y) &#123;</span><br><span class="line">  return x * y; &#x2F;&#x2F; 값의 반환</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수는 반환값으로 평가된다.</span><br><span class="line">var result &#x3D; multiply(3, 5);</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>

<p>multiply 함수는 두개의 인수를 전달받아서 곱한 결과값을 반환한다. 반환값은 return 키워드를 사용해 반환한다. 함수는 return 키워드를 사용해 자바스크립트에서 사용 가능한 모든 값을 반환할 수 있다. “5.3. 표현식”에서 살펴보았듯이 함수 호출은 표현식이다. 이때 함수 호출 표현식은 return 키워드가 반환한 값, 즉 반환값으로 평가된다.</p>
<p>반환문은 두가지 역할을 한다. 첫번째, 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function multiply(x, y) &#123;</span><br><span class="line">  return x * y; &#x2F;&#x2F; 반환문</span><br><span class="line">  &#x2F;&#x2F; 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다.</span><br><span class="line">  console.log(&#39;실행되지 않는다.&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(multiply(3, 5)); &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>

<p>두번째, 반환문은 return 키워드 뒤에 지정한 값을 반환한다. <strong>return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function foo () &#123;</span><br><span class="line">  &#x2F;&#x2F; return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다.</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foo()); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>함수는 반환문을 생략할 수 있다. 이때 함수는 <strong>함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function foo () &#123;</span><br><span class="line">  &#x2F;&#x2F; 반환문을 생략하면 암묵적으로 undefined가 반환된다.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(foo()); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>return 키워드와 반환값 사이에 줄바꿈이 있으면 의도치 않은 결과가 발생할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function multiply(x, y) &#123;</span><br><span class="line">  &#x2F;&#x2F; return 키워드와 반환값 사이에 줄바꿈이 있으면</span><br><span class="line">  return &#x2F;&#x2F; 세미콜론 자동 삽입 기능(ASI)에 의해 세미콜론이 추가된다.</span><br><span class="line">  x * y; &#x2F;&#x2F; 무시된다.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(multiply(3, 5)); &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>
<br>

<h1 id="6-참조에-의한-전달과-외부-상태의-변경"><a href="#6-참조에-의한-전달과-외부-상태의-변경" class="headerlink" title="6. 참조에 의한 전달과 외부 상태의 변경"></a>6. 참조에 의한 전달과 외부 상태의 변경</h1><p>원시 값은 값에 의한 전달(Pass by value), 객체는 참조에 의한 전달(Pass by reference) 방식으로 동작한다. <strong>매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따른다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 매개변수 primitive는 원시값을 전달받고, 매개변수 obj는 객체를 전달받는다.</span><br><span class="line">function changeVal(primitive, obj) &#123;</span><br><span class="line">  primitive +&#x3D; 100;</span><br><span class="line">  obj.name &#x3D; &#39;Kim&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 외부 상태</span><br><span class="line">  var num &#x3D; 100;</span><br><span class="line">  var person &#x3D; &#123; name: &#39;Lee&#39; &#125;;</span><br><span class="line"></span><br><span class="line">  console.log(num); &#x2F;&#x2F; 100</span><br><span class="line">  console.log(person); &#x2F;&#x2F; &#123;name: &#39;Lee&#39;&#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다.</span><br><span class="line">  changeVal(num, person);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 원시 값은 원본이 훼손되지 않는다.</span><br><span class="line">  console.log(num); &#x2F;&#x2F; 100</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 객체는 원본이 훼손된다.</span><br><span class="line">  console.log(person); &#x2F;&#x2F; &#123;name: &#39;Kim&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경(재할당을 통한 교체)하여도 원본은 훼손되지 않는다. 다시 말해 외부 상태, 즉 함수 외부에서 함수 몸체 내부로 전달한 원시값의 원본을 변경하는 어떠한 부수 효과(side-effect)도 발생하지 않는다.</p>
<p>객체 타입 인수는 참조값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조값을 통해 참조한 객체를 변경할 경우 원본이 훼손된다. 다시 말해 외부 상태, 즉 함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 원본 객체가 변경되는 부수 효과가 발생한다.</p>
<p>객체의 변경을 추적하려면 <mark>Observer 패턴</mark>등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요하다.</p>
<p>이러한 문제의 해결 방법 중 하나는 객체를 불변 객체로 만들어 사용하는 것이다.객체의 복사본을 새롭게 생성하는 비용은 들지만 객체를 마치 원시 값처럼 변경 불가능한 값으로 동작하게 만드는 것이다. 이를 통해 객체의 상태 변경을 원천봉쇄하고 객체의 상태 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 원본 객체를 완전히 복제, 즉 깊은 복사(Deep copy)(깊은 복사에 대해서는 Deep copying in JavaScript를 참고합시다.)를 통해 새로운 객체를 생성하여 재할당을 통해 교체한다. 이를 통해 외부 상태가 변경되는 부수 효과를 없앨 수 있다.</p>
<p>외부 상태를 변경하지 않고 의존하지도 않는 함수를 순수 함수라 한다. 순수 함수를 통해 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 한다.<br><br></p>
<h1 id="7-다양한-함수의-형태"><a href="#7-다양한-함수의-형태" class="headerlink" title="7. 다양한 함수의 형태"></a>7. 다양한 함수의 형태</h1><br>

<h2 id="7-1-즉시실행함수"><a href="#7-1-즉시실행함수" class="headerlink" title="7.1. 즉시실행함수"></a>7.1. 즉시실행함수</h2><p>함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)라고 한다. 즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수는 없다. 따라서 즉시 실행 함수는 함수 이름이 없는 익명 함수를 사용하는 것이 일반적이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 익명 즉시 실행 함수</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">  var a &#x3D; 3;</span><br><span class="line">  var b &#x3D; 5;</span><br><span class="line">  return a * b;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>함수 이름이 있는 기명 즉시 실행 함수도 사용할 수 있다. 하지만 <strong>그룹 연산자(…) 내의 기명 함수는 함수 선언문이 아니라 함수 리터럴로 평가되며 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자이므로 즉시 실행 함수를 다시 호출할 수는 없다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 기명 즉시 실행 함수</span><br><span class="line"></span><br><span class="line">(function foo() &#123;</span><br><span class="line">  var a &#x3D; 3;</span><br><span class="line">  var b &#x3D; 5;</span><br><span class="line">  return a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">foo(); &#x2F;&#x2F; ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure>

<p>즉시 실행 함수는 반드시 그룹 연산자 (…)로 감싸 주어야 한다. 그렇지 않으면 아래와 같이 에러가 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function () &#123; &#x2F;&#x2F; SyntaxError: Function statements require a function name</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p>위 예제에서 에러가 발생하는 이유는 함수 정의가 함수 선언문의 형식에 맞지 않기 때문이다. 함수 선언문은 함수 이름을 생략할 수 없다. 그렇다면 기명 함수를 정의하여 그룹 연산자 없이 즉시 호출해보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;(); &#x2F;&#x2F; SyntaxError: Unexpected token &#39;)&#39;</span><br></pre></td></tr></table></figure>

<p>위 예제에서도 에러가 발생한다. 그 이유는 자바스크립트 엔진이 암묵적으로 수행하는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)에 의해 함수 선언문이 끝나는 위치, 즉 함수 코드 블록의 닫는 중괄호 뒤에 “;”이 암묵적으로 추가되기 때문이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;&#125;(); &#x2F;&#x2F; &#x3D;&gt; function foo() &#123;&#125;;();</span><br></pre></td></tr></table></figure>

<p>따라서 함수 선언문 뒤의 그룹 연산자에 피연산자가 없기 때문에 에러가 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(); &#x2F;&#x2F; SyntaxError: Unexpected token )</span><br></pre></td></tr></table></figure>

<p>그룹 연산자의 피연산자는 값으로 평가되므로 기명 또는 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(typeof (function f()&#123;&#125;)); &#x2F;&#x2F; function</span><br><span class="line">console.log(typeof (function ()&#123;&#125;));  &#x2F;&#x2F; function</span><br></pre></td></tr></table></figure>
<br>
즉, 그룹 연산자로 함수를 묶은 이유는 먼저 함수를 평가하여 함수 객체를 생성하기 위함이다. 따라서 먼저 함수를 평가하여 함수 객체를 생성할 수 있다면 아래와 같이 그룹 연산자 이외의 연산자를 사용할 수도 있다. 가장 일반적인 방법은 첫번째 방식이다. 이 책에서는 첫번째 방식을 사용하도록 하겠다.

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">(function () &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line">!function () &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">+function () &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>

<p><strong>즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.</span><br><span class="line">var res &#x3D; (function () &#123;</span><br><span class="line">  var a &#x3D; 3;</span><br><span class="line">  var b &#x3D; 5;</span><br><span class="line">  return a * b;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line">console.log(res); &#x2F;&#x2F; 15</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.</span><br><span class="line">res &#x3D; (function (a, b) &#123;</span><br><span class="line">  return a * b;</span><br><span class="line">&#125;(3, 5));</span><br><span class="line"></span><br><span class="line">console.log(res); &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>

<h2 id="7-2-재귀-함수"><a href="#7-2-재귀-함수" class="headerlink" title="7.2. 재귀 함수"></a>7.2. 재귀 함수</h2><p><strong>함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다.</strong> 재귀 함수는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다.</p>
<p>재귀 호출을 통해 반복 연산을 간단하게 구현할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.</span><br><span class="line">&#x2F;&#x2F; n! &#x3D; 1 * 2 * ... * (n-1) * n</span><br><span class="line">function factorial(n) &#123;</span><br><span class="line">  &#x2F;&#x2F; 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다.</span><br><span class="line">  if (n &lt;&#x3D; 1) return 1;</span><br><span class="line">  &#x2F;&#x2F; 재귀 호출</span><br><span class="line">  return n * factorial(n - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(factorial(0)); &#x2F;&#x2F; 0! &#x3D; 1</span><br><span class="line">console.log(factorial(1)); &#x2F;&#x2F; 1! &#x3D; 1</span><br><span class="line">console.log(factorial(2)); &#x2F;&#x2F; 2! &#x3D; 2 * 1 &#x3D; 2</span><br><span class="line">console.log(factorial(3)); &#x2F;&#x2F; 3! &#x3D; 3 * 2 * 1 &#x3D; 6</span><br><span class="line">console.log(factorial(4)); &#x2F;&#x2F; 4! &#x3D; 4 * 3 * 1 * 1 &#x3D; 24</span><br><span class="line">console.log(factorial(5)); &#x2F;&#x2F; 5! &#x3D; 5 * 4 * 3 * 2 * 1 &#x3D; 120</span><br></pre></td></tr></table></figure>

<p>재귀 함수는 자신을 무한 재귀 호출한다. 따라서 <strong>재귀 함수 내에는 재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다.</strong> 위 예제의 경우 인수가 1 이하일 때 재귀 호출을 멈춘다. 탈출 조건이 없는 경우, 함수가 무한 호출되어 stack overflow 에러가 발생한다.</p>
<p>factorial 함수 내부에서 자기 자신을 호출할 때 사용한 식별자 factorial은 함수 이름이다. 함수 이름은 함수 몸체 내부에서만 유효하다. 따라서 함수 내부에서는 함수 이름을 사용하여 자기 자신을 호출할 수 있다. 함수 표현식으로 정의한 함수 내부에서는 함수 이름은 물론 함수를 가리키는 식별자로도 자기 자신을 재귀 호출할 수 있다. 단, 함수 호출은 반드시 함수를 가리키는 식별자로 해야 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 함수 표현식</span><br><span class="line">var factorial &#x3D; function foo(n) &#123;</span><br><span class="line">  &#x2F;&#x2F; 탈출 조건: n이 1 이하일 떄 재귀 호출을 멈춘다.</span><br><span class="line">  if (n &lt; 1) return 1;</span><br><span class="line">  &#x2F;&#x2F; 함수를 가리키는 식별자로 자기 자신을 재귀 호출</span><br><span class="line">  return n * factorial( n - 1 );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 함수 이름으로 자기 자신을 재귀 호출할 수도 있다.</span><br><span class="line">  &#x2F;&#x2F; console.log(factorial &#x3D;&#x3D;&#x3D; foo); &#x2F;&#x2F; true</span><br><span class="line">  &#x2F;&#x2F; return n * foo( n - 1 );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(factorial(5)); &#x2F;&#x2F; 5! &#x3D; 5 * 4 * 3 * 2 * 1 &#x3D; 120</span><br></pre></td></tr></table></figure>

<p>대부분의 재귀함수는 for나 while문으로 구현할 수 있다.<br>재귀 함수는 반복 연산을 간단히 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 수 있고, 이로 인해 stack overflow 에러를 발생시킬 수 있으므로 주의해서 사용해야 한다. 따라서 재귀 함수는 반복문을 사용하는 것 보다 재귀 함수를 사용하는 것이 보다 직관적으로 이해하기 쉬울 때에만 한정적으로 사용하는 것이 바람직하다.</p>
<h2 id="7-3-중첩-함수"><a href="#7-3-중첩-함수" class="headerlink" title="7.3. 중첩 함수"></a>7.3. 중첩 함수</h2><p>함수 내부에 정의된 함수를 중첩 함수(nested function) 또는 내부 함수(inner function)라 한다. 그리고 중첩 함수를 포함하는 함수는 외부 함수(outer function)라 부른다. 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 <strong>헬퍼 함수(helper function)</strong>의 역할을 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function outer() &#123;</span><br><span class="line">  var x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 중첩 함수</span><br><span class="line">  function inner() &#123;</span><br><span class="line">    var y &#x3D; 2;</span><br><span class="line">    &#x2F;&#x2F; 외부 함수의 변수를 참조할 수 있다.</span><br><span class="line">    console.log(x + y); &#x2F;&#x2F; 3</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  inner();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">outer();</span><br></pre></td></tr></table></figure>

<p>ES6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다. 함수 선언문의 경우, ES6 이전에는 코드의 최상위 또는 다른 함수 내부에서만 정의할 수 있었으나 ES6부터는 if 문이나 for 문 등의 코드 블록 내에서도 정의할 수 있다. <strong>단, 호이스팅으로 인해 혼란이 발생할 수 있으므로 if 문이나 for 문 등의 코드 블록에서 함수 선언문을 통해 함수를 정의하는 것은 바람직하지 않다.</strong></p>
<p>중첩 함수는 스코프와 클로저에 깊은 관련이 있다. 이에 대해서는 나중에 자세히 살펴보도록 하자.</p>
<h2 id="7-4-콜백-함수"><a href="#7-4-콜백-함수" class="headerlink" title="7.4. 콜백 함수"></a>7.4. 콜백 함수</h2><p>어떤 일을 반복 수행하는 repeat 함수를 정의해 보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; n만큼 어떤 일을 반복한다</span><br><span class="line">function repeat(n) &#123;</span><br><span class="line">  &#x2F;&#x2F; i를 출력한다.</span><br><span class="line">  for (var i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">  repeat(5); &#x2F;&#x2F; 0 1 2 3 4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; n만큼 어떤 일을 반복한다</span><br><span class="line">function repeat2(n) &#123;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; n; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; i가 홀수일 때만 출력한다.</span><br><span class="line">    if (i % 2) console.log(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">repeat2(5); &#x2F;&#x2F; 1 3</span><br></pre></td></tr></table></figure>

<p>위 repeat 함수는 경우에 따라 변경되는 일을 함수 f로 추상화하였고 이를 외부에서 전달받는다. 자바스크립트의 함수는 일급 객체이므로 함수의 매개변수를 통해 함수를 전달할 수 있다. repeat 함수는 더 이상 내부 로직에 강력히 의존하지 않고 외부에서 로직의 일부분을 함수로 전달받아 수행하므로 보다 유연한 구조를 갖게 되었다.</p>
<p>이처럼 <strong>함수의 매개변수를 통해 전달되는 함수를 콜백 함수(Callback function)라고 하며, 콜백 함수를 매개변수를 통해 전달받은 함수를 고차 함수(Higher-Order Function, HOF)라고 한다.</strong></p>
<p>중첩 함수가 외부 함수를 돕는 헬퍼 함수의 역할을 하는 것처럼 콜백 함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한다. 단, 중첩 함수는 고정되어 있어서 교체하기 곤란하지만 콜백 함수는 함수 외부에서 고차 함수 내부로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다. 즉, <strong>고차 함수는 콜백 함수를 자신의 일부분으로 합성한다.</strong></p>
<p>고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정하여 호출한다. 다시 말해, 콜백 함수는 고차 함수에 의해 호출되며 이때 필요에 따라 인수도 전달될 수 있다. 따라서 고차 함수에 콜백 함수를 전달할 때, 콜백 함수를 호출하지 않고 함수 자체를 전달해야 한다.</p>
<p>콜백 함수가 고차 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 익명 함수 리터럴을 콜백 함수로 매개변수에 전달한다.</span><br><span class="line">&#x2F;&#x2F; 익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다.</span><br><span class="line">repeat(5, function (i) &#123;</span><br><span class="line">  if (i % 2) console.log(i);</span><br><span class="line">&#125;); &#x2F;&#x2F; 1 3</span><br></pre></td></tr></table></figure>

<p>이때 콜백 함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성한다. 따라서 콜백 함수를 다른 곳에서도 호출할 필요가 있거나, 콜백 함수를 전달받는 함수가 자주 호출된다면 함수 외부에서 콜백 함수를 정의한 후 함수 참조를 고차 함수에 전달하는 편이 효율적이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; logOdds 함수는 단 한번만 생성된다.</span><br><span class="line">var logOdds &#x3D; function (i) &#123;</span><br><span class="line">  if (i % 2) console.log(i);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 고차 함수에 함수 참조를 전달한다.</span><br><span class="line">repeat(5, logOdds); &#x2F;&#x2F; 1 3</span><br></pre></td></tr></table></figure>

<p>위 예제의 logOdds 함수는 단 한번만 생성된다. 하지만 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하면 고차 함수가 호출될 때마다 콜백 함수가 생성된다.</p>
<p>콜백 함수는 일반적으로 비동기 처리(이벤트 처리, Ajax 통신, Timer 함수 등)을 위해 사용하는 중요한 패턴이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 콜백 함수를 사용한 이벤트 처리</span><br><span class="line">&#x2F;&#x2F; myButton 버튼을 클릭하면 콜백 함수를 실행한다.</span><br><span class="line">document.getElementById(&#39;myButton&#39;).addEventListener(&#39;click&#39;, function () &#123;</span><br><span class="line">  console.log(&#39;button clicked!&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 콜백 함수를 사용한 비동기 처리</span><br><span class="line">&#x2F;&#x2F; 1초 후에 메시지를 출력한다.</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(&#39;1초 경과&#39;);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<p>콜백 함수는 비동기 처리 뿐 만 아니라 배열 고차 함수에서도 사용된다. 자바스크립트에서 배열은 사용 빈도가 매우 높은 자료 구조이고 배열을 다룰 때 배열 고차 함수는 매우 중요하다. 이에 대해서는 “27.9. 배열 고차 함수”에서 자세히 살펴볼 것이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 콜백 함수를 사용하는 고차 함수 map</span><br><span class="line">var res &#x3D; [1, 2, 3].map(function (item) &#123;</span><br><span class="line">  return item * 2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(res); &#x2F;&#x2F; [2, 4, 6]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 콜백 함수를 사용하는 고차 함수 filter</span><br><span class="line">res &#x3D; [1, 2, 3].filter(function (item) &#123;</span><br><span class="line">  return item % 2;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(res); &#x2F;&#x2F; [1, 3]</span><br></pre></td></tr></table></figure>
<br>

<h2 id="7-5-순수-함수와-비순수-함수"><a href="#7-5-순수-함수와-비순수-함수" class="headerlink" title="7.5. 순수 함수와 비순수 함수"></a>7.5. 순수 함수와 비순수 함수</h2><p>순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수를 말한다. 즉, <strong>순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존하여 반환값을 만든다.</strong><br><strong>순수 함수의 또 하나의 특징은 함수의 외부 상태를 변경하지 않는다는 것이다.</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var conut &#x3D; 0; &#x2F;&#x2F; 현재 카운트를 나타내는 상태</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 외부 상태에 의존하지 않으며 변경하지도 않는 순수 함수</span><br><span class="line">&#x2F;&#x2F; 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.</span><br><span class="line">function increase(n) &#123;</span><br><span class="line">  return ++n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 순수 함수가 반환한 결과값을 변수에 재할당하여 상태를 변경</span><br><span class="line">conut &#x3D; increase(conut);</span><br><span class="line">console.log(conut); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">conut &#x3D; increase(conut);</span><br><span class="line">console.log(conut); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>반대로 <strong>함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 함수를 비순수 함수라고 한다.</strong> 비순수 함수의 또 하나의 특징은 순수 함수와는 달리 함수의 외부 상태를 변경하는 <strong>부수 효과(side effect)</strong>가 있다는 것이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 0; &#x2F;&#x2F; 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 비순수 함수</span><br><span class="line">&#x2F;&#x2F; 비순수 함수는 외부 상태를 변경하는 부수 효과(side effect)가 있다.</span><br><span class="line">function increase() &#123;</span><br><span class="line">  return ++count; &#x2F;&#x2F; 외부 상태를 변경한다.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.</span><br><span class="line">increase();</span><br><span class="line">console.log(count); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">increase();</span><br><span class="line">console.log(count); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 따라서 함수 외부 상태의 변경을 지양하는 순수 함수를 사용하는 것이 좋다. 위 예제의 increase 함수와 같은 비순수 함수는 코드의 복잡성을 증가시킨다. 비순수 함수를 최대한 줄이는 것은 부수 효과를 최대한 억제하는 것과 같다.</p>
<p>함수형 프로그래밍은 변수의 사용을 억제하여 상태 변경을 최대한 억제하고 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하려는 프로그래밍 패러다임이다. 변수 값은 누군가에 의해 언제든지 변경될 수 있고, 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 만들어 가독성을 해치고 오류 발생의 근본적 원인이 될 수 있기 때문이다.</p>
<p>함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법이라고 할 수 있다. 이 책에서는 함수형 프로그래밍을 다루지는 않는다. 하지만 자바스크립트는 멀티 패러다임 언어이며 객체지향 프로그래밍 뿐만 아니라 부분적으로 함수형 프로그래밍을 적극적으로 활용하고 있다. 먼저 자바스크립트의 기본 개념과 동작 원리를 이해하고 함수형 프로그래밍에 대해 추가적인 학습을 권장한다.</p>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-25T11:06:09.000Z">2020-02-25</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    3 minutes read (About 451 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/02/object/">객체 리터럴 | javaScript</a>
            
        </h1>
        <div class="content">
            <h1 id="1-객체란"><a href="#1-객체란" class="headerlink" title="1. 객체란?"></a>1. 객체란?</h1><p>자바스크립트는 객체(object) 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다.</p>
<p>원시 타입은 단 하나의 값만을 나타내지만 객체 타입(object / reference type)은 다양한 타입의 값(원시 값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료 구조(Data structure)이다. 또한 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다.</p>
<p>자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드(Method)라 부른다.</p>
<p>이처럼 객체는 프로퍼티와 메소드로 구성된 집합체이다. 프로퍼티와 메소드의 역할은 아래와 같다.</p>
<ul>
<li>프로퍼티: 객체의 상태를 나타내는 값(data)</li>
<li>메소드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)<br>이와 같이 객체는 객체의 상태를 나타내는 값(프로퍼티)과 프로퍼티를 참조하고 조작할 수 있는 동작(메소드)를 모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.</li>
</ul>

        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-24T06:34:10.000Z">2020-02-24</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    25 minutes read (About 3710 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/02/control-flow-statement/">제어문 | javaScript</a>
            
        </h1>
        <div class="content">
            <p>제어문(Control flow statement)은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다.</p>
<p>하지만 코드의 실행 순서가 변경된다는 것은 단순하게 위에서 아래로 순차적으로 진행하는 직관적인 코드의 흐름을 혼란스럽게 만든다. 따라서 제어문은 코드의 흐름을 이해하기 어렵게 만들어 가독성을 해치는 단점이 있다. 가독성이 좋지 않은 코드는 오류를 발생시키는 원인이 된다. 나중에 살펴볼 forEach, map, filter, reduce와 같은 고차 함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다.</p>
<p>2보 전진을 위해서는 먼저 첫발을 내디뎌야 한다. 제어문을 바르게 이해하는 것은 코딩 스킬에 많은 영향을 준다. 특히 for 문은 매우 중요하므로 확실히 이해하도록 하자.</p>
<h1 id="1-블록문"><a href="#1-블록문" class="headerlink" title="1.블록문"></a>1.블록문</h1><p>블록문(Block statement/Compound statement)는 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다. 블록문은 단독으로 사용할 수도 있으나 일반적으로 제어문이나 함수를 정의할 때 사용하는 것이 일반적이다.</p>
<p>아래는 블록문이 사용되는 다양한 예제이다. 문의 끝에는 세미 콜론(;)을 붙이는 것이 일반적이지만 블록문의 끝에는 세미콜론을 붙이지 않는다는 것에 주의하기 바란다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 블록문</span><br><span class="line">&#123;</span><br><span class="line">  var foo &#x3D; 10;</span><br><span class="line">  console.log(foo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 제어문</span><br><span class="line">var x &#x3D; 0;</span><br><span class="line">while (x &lt; 10) &#123;</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 함수 선언문</span><br><span class="line">function sum(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">console.log(sum(1, 2)); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<br>

<h1 id="2-조건문"><a href="#2-조건문" class="headerlink" title="2.조건문"></a>2.조건문</h1><p>조건문(conditional statement)은 주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블럭(블록문)의 실행을 결정한다. 조건식은 불리언 값으로 평가될 수 있는 표현식이다.</p>
<p>자바스크립트는 2가지의 조건문 if…else 문과 switch 문을 제공한다.</p>
<h2 id="2-1-if…else-문"><a href="#2-1-if…else-문" class="headerlink" title="2.1. if…else 문"></a>2.1. if…else 문</h2><p>if…else 문은 주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다. 조건식의 평가 결과가 참(true)일 경우, if 문 다음의 코드 블록이 실행되고 거짓(false)일 경우, else 문 다음의 코드 블록이 실행된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (조건식) &#123;</span><br><span class="line">  &#x2F;&#x2F; 조건식이 참이면 이 코드 블록이 실행된다.</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 조건식이 거짓이면 이 코드 블록이 실행된다.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if 문의 조건식은 불리언 값으로 평가되어야 한다. 만약 if 문의 조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 데이터 타입이 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다. 이에 대해서는 “8.2. 암묵적 타입 변환”에서 살펴볼 것이다.</p>
<p>조건식을 추가하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면 else if 문을 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (조건식1) &#123;</span><br><span class="line">  &#x2F;&#x2F; 조건식1이 참이면 이 코드 블록이 실행된다.</span><br><span class="line">&#125; else if (조건식2) &#123;</span><br><span class="line">  &#x2F;&#x2F; 조건식2이 참이면 이 코드 블록이 실행된다.</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행된다.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>else if 문과 else 문은 옵션이다. 즉, 사용할 수도 있고 사용하지 않을 수도 있다. if 문과 else 문은 2번 이상 사용할 수 없지만 else if 문은 여러 번 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 2;</span><br><span class="line">var kind;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if 문</span><br><span class="line">if (num &gt; 0) &#123;</span><br><span class="line">  kind &#x3D; &#39;양수&#39;; &#x2F;&#x2F; 음수를 구별할 수 없다</span><br><span class="line">&#125;</span><br><span class="line">console.log(kind); &#x2F;&#x2F; 양수</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if…else 문</span><br><span class="line">if (num &gt; 0) &#123;</span><br><span class="line">  kind &#x3D; &#39;양수&#39;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  kind &#x3D; &#39;음수&#39;; &#x2F;&#x2F; 0은 음수가 아니다.</span><br><span class="line">&#125;</span><br><span class="line">console.log(kind); &#x2F;&#x2F; 양수</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if…else if 문</span><br><span class="line">if (num &gt; 0) &#123;</span><br><span class="line">  kind &#x3D; &#39;양수&#39;;</span><br><span class="line">&#125; else if (num &lt; 0) &#123;</span><br><span class="line">  kind &#x3D; &#39;음수&#39;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  kind &#x3D; &#39;영&#39;;</span><br><span class="line">&#125;</span><br><span class="line">console.log(kind); &#x2F;&#x2F; 양수</span><br></pre></td></tr></table></figure>

<p>만약 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 2;</span><br><span class="line">var kind;</span><br><span class="line"></span><br><span class="line">if (num &gt; 0)      kind &#x3D; &#39;양수&#39;;</span><br><span class="line">else if (num &lt; 0) kind &#x3D; &#39;음수&#39;;</span><br><span class="line">else              kind &#x3D; &#39;영&#39;;</span><br><span class="line"></span><br><span class="line">console.log(kind); &#x2F;&#x2F; 양수</span><br></pre></td></tr></table></figure>

<p>대부분의 if…else 문은 삼항 조건 연산자(“7.4. 삼항 조건 연산자” 참고)로 바꿔 쓸 수 있다. 아래 예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; x가 짝수이면 문자열 &#39;짝수&#39;를 반환하고 홀수이면 문자열 &#39;홀수&#39;를 반환한다.</span><br><span class="line">var x &#x3D; 2;</span><br><span class="line">var result;</span><br><span class="line"></span><br><span class="line">if (x % 2) &#123; &#x2F;&#x2F; 2 % 2는 0이다. 이때 0은 false로 암묵적 강제 변환된다.</span><br><span class="line">  result &#x3D; &#39;홀수&#39;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  result &#x3D; &#39;짝수&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F; 짝수</span><br></pre></td></tr></table></figure>

<p>위 예제는 아래와 같이 삼항 조건 연산자로 바꿔 쓸 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; x가 짝수이면 문자열 &#39;짝수&#39;를 반환하고 홀수이면 문자열 &#39;홀수&#39;를 반환한다.</span><br><span class="line">var x &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 0은 false로 취급된다.</span><br><span class="line">var result &#x3D; x % 2 ? &#39;홀수&#39; : &#39;짝수&#39;;</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F; 짝수</span><br></pre></td></tr></table></figure>

<p>위 예제는 두가지 경우의 수(‘홀수’ 또는 ‘짝수’)를 갖는 경우이다. 만약 세가지 경우의 수(양수, 음수, 영)를 갖는 경우는 아래와 같이 바꿔 쓸 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 0은 false로 취급된다.</span><br><span class="line">var kind &#x3D; num ? (num &gt; 0 ? &#39;양수&#39; : &#39;음수&#39;) : &#39;영&#39;;</span><br><span class="line"></span><br><span class="line">console.log(kind); &#x2F;&#x2F; 양수</span><br></pre></td></tr></table></figure>

<p>num &gt; 0 ? ‘양수’ : ‘음수’는 표현식이다. 즉, 삼항 연산자는 값으로 평가되는 표현식을 만든다. 하지만 if…else 문은 표현식이 아닌 문이다. 따라서 삼항 조건 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다. 하지만 if…else 문은 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다는 차이가 있다.</p>
<h2 id="2-2-switch-문"><a href="#2-2-switch-문" class="headerlink" title="2.2. switch 문"></a>2.2. switch 문</h2><p>switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 순서를 이동시킨다. case 문은 상황(case)을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다.</p>
<p>switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없다면 실행 순서는 default 문으로 이동한다. default 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (표현식) &#123;</span><br><span class="line">  case 표현식1:</span><br><span class="line">    switch 문의 표현식과 표현식1이 일치하면 실행될 문;</span><br><span class="line">    break;</span><br><span class="line">  case 표현식2:</span><br><span class="line">    switch 문의 표현식과 표현식2가 일치하면 실행될 문;</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>if…else 문의 조건식은 반드시 불리언 값으로 평가되지만 switch 문의 표현식은 불리언 값보다는 문자열, 숫자 값인 경우가 많다. if…else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정한다. switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다.</p>
<p>아래 예제를 살펴보자. switch 문의 표현식, 즉 변수 month의 평가 결과인 숫자 값 11과 일치하는 case 문으로 실행 순서가 이동한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 월을 영어로 변환한다. (11 → &#39;November&#39;)</span><br><span class="line">var month &#x3D; 11;</span><br><span class="line">var monthName;</span><br><span class="line"></span><br><span class="line">switch (month) &#123;</span><br><span class="line">  case 1:</span><br><span class="line">    monthName &#x3D; &#39;January&#39;;</span><br><span class="line">  case 2:</span><br><span class="line">    monthName &#x3D; &#39;February&#39;;</span><br><span class="line">  case 3:</span><br><span class="line">    monthName &#x3D; &#39;March&#39;;</span><br><span class="line">  case 4:</span><br><span class="line">    monthName &#x3D; &#39;April&#39;;</span><br><span class="line">  case 5:</span><br><span class="line">    monthName &#x3D; &#39;May&#39;;</span><br><span class="line">  case 6:</span><br><span class="line">    monthName &#x3D; &#39;June&#39;;</span><br><span class="line">  case 7:</span><br><span class="line">    monthName &#x3D; &#39;July&#39;;</span><br><span class="line">  case 8:</span><br><span class="line">    monthName &#x3D; &#39;August&#39;;</span><br><span class="line">  case 9:</span><br><span class="line">    monthName &#x3D; &#39;September&#39;;</span><br><span class="line">  case 10:</span><br><span class="line">    monthName &#x3D; &#39;October&#39;;</span><br><span class="line">  case 11:</span><br><span class="line">    monthName &#x3D; &#39;November&#39;;</span><br><span class="line">  case 12:</span><br><span class="line">    monthName &#x3D; &#39;December&#39;;</span><br><span class="line">  default:</span><br><span class="line">    monthName &#x3D; &#39;Invalid month&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(monthName); &#x2F;&#x2F; Invalid month</span><br></pre></td></tr></table></figure>
<br>

<h1 id="3-반목문"><a href="#3-반목문" class="headerlink" title="3. 반목문"></a>3. 반목문</h1><p>반복문(Loop statement)은 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다.</p>
<p>자바스크립트는 3가지의 반복문 for 문, while 문, do…while 문을 제공한다. 그 외에도 for..in 문, ES6에서 새롭게 도입된 for…of 문이 있다. for..in 문과 for…of 문에 대해서는 나중에 살펴보기로 하자.</p>
<h2 id="3-1-for-문"><a href="#3-1-for-문" class="headerlink" title="3.1 for 문"></a>3.1 for 문</h2><p>for 문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 반복문의 형태는 아래와 같다. 변수 선언문의 변수 이름은 반복을 의미하는 iteration의 i를 사용하는 것이 일반적이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for (변수 선언문 또는 할당문; 조건식; 증감식) &#123;</span><br><span class="line">  조건식이 참인 경우 반복 실행될 문;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 2; i++) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위 예제의 for 문은 변수 i가 0으로 초기화된 상태에서 시작하여 i가 2보다 작을 때까지 코드 블록을 2번 반복 실행한다. for 문의 실행 순서를 따라가며 어떻게 동작하는지 살펴보자.</p>
<ol>
<li>for 문을 실행하면 가장 먼저 변수 선언문 var i = 0이 실행된다. 변수 선언문은 단 한번만 실행된다.</li>
<li>변수 선언문의 실행이 종료되면 조건식으로 실행 순서가 이동한다. 현재 변수 i는 0이므로 조건식의 평가 결과는 true다.</li>
<li>조건식의 평가 결과가 true이므로 실행 순서가 코드 블록으로 이동하여 실행된다. 증감문으로 실행 순서가 이동하는 것이 아니라 코드 블록으로 실행 순서가 이동하는 것에 주의하자.</li>
<li>코드 블록의 실행이 종료하면 증감식으로 실행 순서가 이동한다. 증감식 i++가 실행되어 i는 1이 된다.</li>
<li>증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다. 변수 선언문으로 실행 순서가 이동하는 것이 아니라 조건식으로 실행 순서가 이동하는 것에 주의하자. 변수 선언문은 단 한번만 실행된다. 현재 변수 i는 1이므로 조건식의 평가 결과는 true다.</li>
<li>조건식의 평가 결과가 true이므로 실행 순서가 코드 블록으로 이동하여 실행된다.</li>
<li>코드 블록의 실행이 종료하면 증감식으로 실행 순서가 이동한다. 증감식 i++가 실행되어 i는 2가 된다.</li>
<li>증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다. 현재 변수 i는 2이므로 조건식의 평가 결과는 false다. 조건식의 평가 결과가 false이므로 for 문의 실행이 종료된다.</li>
<li>아래 예제는 위 예제를 역으로 반복하는 for 문이다. 변수 i가 1으로 초기화된 상태에서 시작하여 i가 0보다 같거나 커질 때까지 코드 블록을 2번 반복 실행한다.</li>
</ol>
<p>for 문 내에 for 문을 중첩해 사용할 수 있다. 아래는 두 개의 주사위를 던졌을 때, 두 눈의 합이 6이 되는 모든 경우의 수를 출력하는 예제다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 1; i &lt;&#x3D; 6; i++) &#123;</span><br><span class="line">  for (var j &#x3D; 1; j &lt;&#x3D; 6; j++) &#123;</span><br><span class="line">    if (i + j &#x3D;&#x3D;&#x3D; 6) console.log(&#96;[$&#123;i&#125;, $&#123;j&#125;]&#96;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>출력 결과는 아래와 같다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1, 5]</span><br><span class="line">[2, 4]</span><br><span class="line">[3, 3]</span><br><span class="line">[4, 2]</span><br><span class="line">[5, 1]</span><br></pre></td></tr></table></figure>

<h2 id="3-2-while-문"><a href="#3-2-while-문" class="headerlink" title="3.2. while 문"></a>3.2. while 문</h2><p>while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.</span><br><span class="line">while (count &lt; 3) &#123;</span><br><span class="line">  console.log(count);</span><br><span class="line">  count++;</span><br><span class="line">&#125; &#x2F;&#x2F; 0 1 2</span><br></pre></td></tr></table></figure>

<p>조건식의 평가 결과가 언제나 참이면 무한루프가 된다. 무한루프를 탈출하기 위해서는 코드 블럭 내에 if문으로 탈출 조건을 만들고 break 문으로 코드 블럭을 탈출한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 무한루프</span><br><span class="line">while (true) &#123;</span><br><span class="line">  console.log(count);</span><br><span class="line">  count++;</span><br><span class="line">  &#x2F;&#x2F; count가 3이면 코드 블록을 탈출한다.</span><br><span class="line">  if (count &#x3D;&#x3D;&#x3D; 3) break;</span><br><span class="line">&#125; &#x2F;&#x2F; 0 1 2</span><br></pre></td></tr></table></figure>

<h1 id="4-break-문"><a href="#4-break-문" class="headerlink" title="4. break 문"></a>4. break 문</h1><p>switch 문과 while 문에서 살펴보았듯이 break 문은 코드 블록을 탈출한다. 좀 더 정확히 표현하자면 코드 블록을 탈출하는 것이 아니라 레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 이외에 break 문을 사용하면 SyntaxError(문법 에러)가 발생한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  break; &#x2F;&#x2F; Uncaught SyntaxError: Illegal break statement</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-continue-문"><a href="#5-continue-문" class="headerlink" title="5. continue 문"></a>5. continue 문</h1><p>continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. break 문처럼 반복문을 탈출하지는 않는다.<br>아래는 문자열에서 특정 문자의 개수를 카운트하는 예제이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var string &#x3D; &#39;Hello World.&#39;;</span><br><span class="line">var search &#x3D; &#39;l&#39;;</span><br><span class="line">var count &#x3D; 0;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 문자열은 유사배열이므로 for 문으로 순회할 수 있다.</span><br><span class="line">for (var i &#x3D; 0; i &lt; string.length; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; &#39;l&#39;이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다.</span><br><span class="line">  if (string[i] !&#x3D;&#x3D; search) continue;</span><br><span class="line">  count++; &#x2F;&#x2F; continue 문이 실행되면 이 문은 실행되지 않는다.</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(count); &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 참고로 String.prototype.match 메소드를 사용해도 같은 동작을 한다.</span><br><span class="line">const regexp &#x3D; new RegExp(search, &#39;g&#39;);</span><br><span class="line">console.log(string.match(regexp).length); &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>위 예제의 for 문은 아래와 동일하게 동작한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0; i &lt; string.length; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; &#39;l&#39;이면 카운트를 증가시킨다.</span><br><span class="line">  if (string[i] &#x3D;&#x3D;&#x3D; search) count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>위와 같이 if 문 내에서 실행해야 할 코드가 한 줄이라면 continue 문을 사용했을 때보다 간편하며 가독성도 좋다. 하지만 if 문 내에서 실행해야 할 코드가 길다면 들여쓰기가 한 단계 더 깊어지므로 continue 문을 사용하는 것이 가독성이 더 좋다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; continue 문을 사용하지 않으면 if 문 내에 코드를 작성해야 한다.</span><br><span class="line">for (var i &#x3D; 0; i &lt; string.length; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; &#39;l&#39;이면 카운트를 증가시킨다.</span><br><span class="line">  if (string[i] &#x3D;&#x3D;&#x3D; search) &#123;</span><br><span class="line">    count++;</span><br><span class="line">    &#x2F;&#x2F; code</span><br><span class="line">    &#x2F;&#x2F; code</span><br><span class="line">    &#x2F;&#x2F; code</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; continue 문을 사용면 if 문 밖에 코드를 작성할 수 있다.</span><br><span class="line">for (var i &#x3D; 0; i &lt; string.length; i++) &#123;</span><br><span class="line">  &#x2F;&#x2F; &#39;l&#39;이 아니면 카운트를 증가시키지 않는다.</span><br><span class="line">  if (string[i] !&#x3D;&#x3D; search) continue;</span><br><span class="line"></span><br><span class="line">  count++;</span><br><span class="line">  &#x2F;&#x2F; code</span><br><span class="line">  &#x2F;&#x2F; code</span><br><span class="line">  &#x2F;&#x2F; code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-24T05:07:23.000Z">2020-02-24</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/React/">React</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    a few seconds read (About 0 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/02/coercion/">타입 변환과 단축 평가 | javaScript</a>
            
        </h1>
        <div class="content">
            
        </div>
        
        
        
    </div>
</div>








    
<div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2020-02-22T17:13:10.000Z">2020-02-23</time>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    31 minutes read (About 4580 words)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2020/02/operator/">연산자 | javaScript</a>
            
        </h1>
        <div class="content">
            <p>연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자(Operand)라 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.그리고 피연산자와 연산자의 조합으로 이루어진 연산자 표현식도 값으로 평가될 수 있는 표현식이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 산술 연산자</span><br><span class="line">5 * 4 &#x2F;&#x2F; -&gt; 20</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 문자열 연결 연산자</span><br><span class="line">&#39;My name is &#39; + &#39;Lee&#39; &#x2F;&#x2F; -&gt; &#39;My name is Lee&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 할당 연산자</span><br><span class="line">color &#x3D; &#39;red&#39; &#x2F;&#x2F; -&gt; &#39;red&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 비교 연산자</span><br><span class="line">3 &gt; 5 &#x2F;&#x2F; -&gt; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 논리 연산자</span><br><span class="line">true &amp;&amp; false &#x2F;&#x2F; -&gt; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 타입 연산자</span><br><span class="line">typeof &#39;Hi&#39; &#x2F;&#x2F; -&gt; string</span><br></pre></td></tr></table></figure>

<p>피연산자가 “값”이라는 명사의 역할을 한다면 연산자는 “피연산자를 연산하여 새로운 값을 만든다”라는 동사의 역할을 한다고 볼 수 있다.다시 말해,피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다.연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다.</p>
<p>자바스크립트가 제공하는 다양한 연산자에 대해 살펴보도록 하자.</p>
<h1 id="1-산술-연산자"><a href="#1-산술-연산자" class="headerlink" title="1. 산술 연산자"></a>1. 산술 연산자</h1><p>산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환한다.</p>
<p>산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다.</p>
<h2 id="1-1-이항-산술-연산자"><a href="#1-1-이항-산술-연산자" class="headerlink" title="1.1 이항 산술 연산자"></a>1.1 이항 산술 연산자</h2><p>이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다.</p>
<p>모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과(Side effect)가 없다. 다시 말해 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없다. 언제나 새로운 값을 만들 뿐이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">5 + 2; &#x2F;&#x2F; -&gt; 7</span><br><span class="line">5 - 2; &#x2F;&#x2F; -&gt; 3</span><br><span class="line">5 * 2; &#x2F;&#x2F; -&gt; 10</span><br><span class="line">5 &#x2F; 2; &#x2F;&#x2F; -&gt; 2.5</span><br><span class="line">5 % 2; &#x2F;&#x2F; -&gt; 1</span><br></pre></td></tr></table></figure>

<h2 id="1-2-단항-산술-연산자"><a href="#1-2-단항-산술-연산자" class="headerlink" title="1.2. 단항 산술 연산자"></a>1.2. 단항 산술 연산자</h2><p>단항(Unary) 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 주의할 것은 이항 산술 연산자와는 달리 <strong>증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.</strong> 다시 말해 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이루어진다.</p>
<p>증가/감소(++/–) 연산자는 위치에 의미가 있다.</p>
<ul>
<li><p>피연산자 앞에 위치한 전위 증가/감소 연산자(Prefix increment/decrement operator)는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다.</p>
</li>
<li><p>피연산자 뒤에 위치한 후위 증가/감소 연산자(Postfix increment/decrement operator)는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 5, result;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 선할당 후증가 (Postfix increment operator)</span><br><span class="line">result &#x3D; x++;</span><br><span class="line">console.log(result, x); &#x2F;&#x2F; 5 6</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 선증가 후할당 (Prefix increment operator)</span><br><span class="line">result &#x3D; ++x;</span><br><span class="line">console.log(result, x); &#x2F;&#x2F; 7 7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 선할당 후감소 (Postfix decrement operator)</span><br><span class="line">result &#x3D; x--;</span><br><span class="line">console.log(result, x); &#x2F;&#x2F; 7 6</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 선감소 후할당 (Prefix decrement operator)</span><br><span class="line">result &#x3D; --x;</span><br><span class="line">console.log(result, x); &#x2F;&#x2F; 5 5</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>+단항 연산자는 피연산자에 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. 그런데 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 따라서 부수 효과는 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 아무런 효과가 없다.</span><br><span class="line">+10;    &#x2F;&#x2F; -&gt; 10</span><br><span class="line">+(-10); &#x2F;&#x2F; -&gt; -10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 문자열을 숫자로 타입 변환한다.</span><br><span class="line">+&#39;10&#39;; &#x2F;&#x2F; -&gt; 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 불리언 값을 숫자로 타입 변환한다.</span><br><span class="line">+true; &#x2F;&#x2F; -&gt; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 불리언 값을 숫자로 타입 변환한다.</span><br><span class="line">+false; &#x2F;&#x2F; -&gt; 0</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.</span><br><span class="line">+&#39;Hello&#39;; &#x2F;&#x2F; -&gt; NaN</span><br></pre></td></tr></table></figure>

<p>– 단항 연산자는 피연산자의 부호를 반전한 값을 반환한다. + 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 부호를 반전한 값을 생성해서 반환한다. 따라서 부수 효과는 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 부호를 반전한다.</span><br><span class="line">-(-10); &#x2F;&#x2F; -&gt; 10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 문자열을 숫자로 타입 변환한다.</span><br><span class="line">-&#39;10&#39;; &#x2F;&#x2F; -&gt; -10</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 불리언 값을 숫자로 타입 변환한다.</span><br><span class="line">-true; &#x2F;&#x2F; -&gt; -1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.</span><br><span class="line">-&#39;Hello&#39;; &#x2F;&#x2F; -&gt; NaN</span><br></pre></td></tr></table></figure>

<h2 id="1-3-문자열-연결-연산자"><a href="#1-3-문자열-연결-연산자" class="headerlink" title="1.3. 문자열 연결 연산자"></a>1.3. 문자열 연결 연산자</h2><p>+연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작한다. 아래 예제를 살펴보자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 문자열 연결 연산자</span><br><span class="line">&#39;1&#39; + 2; &#x2F;&#x2F; -&gt; &#39;12&#39;</span><br><span class="line">1 + &#39;2&#39;; &#x2F;&#x2F; -&gt; &#39;12&#39;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 산술 연산자</span><br><span class="line">1 + 2; &#x2F;&#x2F; -&gt; 3</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; true는 1로 타입 변환된다.</span><br><span class="line">1 + true; &#x2F;&#x2F; -&gt; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; false는 0으로 타입 변환된다.</span><br><span class="line">1 + false; &#x2F;&#x2F; -&gt; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; null는 0으로 타입 변환된다.</span><br><span class="line">1 + null; &#x2F;&#x2F; -&gt; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; undefined는 숫자로 타입 변환되지 않는다.</span><br><span class="line">+undefined;    &#x2F;&#x2F; -&gt; NaN</span><br><span class="line">1 + undefined; &#x2F;&#x2F; -&gt; NaN</span><br></pre></td></tr></table></figure>

<p>이 예제에서 주목할 것은 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다는 것이다. 위 예제에서 1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입을 강제 변환한 후 연산을 수행한다.</p>
<p>이를 <strong>암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)</strong>이라고 한다. 앞서 살펴본 +/- 단항 연산자도 암묵적 타입 변환이 발생한 것이다. 이에 대해서는 “9. 타입 변환과 단축 평가”에서 자세히 살펴볼 것이다.<br><br></p>
<h1 id="2-할당-연산자"><a href="#2-할당-연산자" class="headerlink" title="2. 할당 연산자"></a>2. 할당 연산자</h1><p>할당 연산자(Assignment Operator)는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line"></span><br><span class="line">x &#x3D; 10;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">x +&#x3D; 5; &#x2F;&#x2F; x &#x3D; x + 5;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 15</span><br><span class="line"></span><br><span class="line">x -&#x3D; 5; &#x2F;&#x2F; x &#x3D; x - 5;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">x *&#x3D; 5; &#x2F;&#x2F; x &#x3D; x * 5;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 50</span><br><span class="line"></span><br><span class="line">x &#x2F;&#x3D; 5; &#x2F;&#x2F; x &#x3D; x &#x2F; 5;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">x %&#x3D; 5; &#x2F;&#x2F; x &#x3D; x % 5;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">var str &#x3D; &#39;My name is &#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 문자열 연결 연산자</span><br><span class="line">str +&#x3D; &#39;Lee&#39;; &#x2F;&#x2F; str &#x3D; str + &#39;Lee&#39;;</span><br><span class="line"></span><br><span class="line">console.log(str); &#x2F;&#x2F; &#39;My name is Lee&#39;</span><br></pre></td></tr></table></figure>
<br>

<h1 id="3-비교-연산자"><a href="#3-비교-연산자" class="headerlink" title="3. 비교 연산자"></a>3. 비교 연산자</h1><p>비교 연산자(Comparison Operator)는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다.</p>
<h2 id="3-1-동등-일치-비교-연산자"><a href="#3-1-동등-일치-비교-연산자" class="headerlink" title="3.1 동등 / 일치 비교 연산자"></a>3.1 동등 / 일치 비교 연산자</h2><p>동등 비교(loose equality) 연산자와 일치 비교(strict equality) 연산자는 좌항과 우항의 피연산자가 같은 값을 갖는지 비교하여 불리언 값을 반환한다. 하지만 비교하는 엄격성의 정도가 다르다. 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 동등 비교</span><br><span class="line">5 &#x3D;&#x3D; 5; &#x2F;&#x2F; -&gt; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.</span><br><span class="line">5 &#x3D;&#x3D; &#39;5&#39;; &#x2F;&#x2F; -&gt; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 동등 비교. 결과를 예측하기 어렵다.</span><br><span class="line">&#39;0&#39; &#x3D;&#x3D; &#39;&#39;; &#x2F;&#x2F; -&gt; false</span><br><span class="line">0 &#x3D;&#x3D; &#39;&#39;;   &#x2F;&#x2F; -&gt; true</span><br><span class="line">0 &#x3D;&#x3D; &#39;0&#39;;  &#x2F;&#x2F; -&gt; true</span><br><span class="line">false &#x3D;&#x3D; &#39;false&#39;;   &#x2F;&#x2F; -&gt; false</span><br><span class="line">false &#x3D;&#x3D; &#39;0&#39;;       &#x2F;&#x2F; -&gt; true</span><br><span class="line">false &#x3D;&#x3D; null;      &#x2F;&#x2F; -&gt; false</span><br><span class="line">false &#x3D;&#x3D; undefined; &#x2F;&#x2F; -&gt; false</span><br></pre></td></tr></table></figure>
<p>위 예제와 같은 코드를 작성할 개발자는 드물겠지만 이처럼 동등 비교(==) 연산자는 예측하기 어려운 결과를 만들어낸다. 위 예제는 이해하려 하지 않아도 된다. 다만 동등 비교 연산자를 사용하지 말고 일치 비교 연산자를 사용하면 된다.</p>
<p>일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 다시 말해 암묵적 타입 변환을 하지 않고 값을 비교한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 일치 비교</span><br><span class="line">5 &#x3D;&#x3D;&#x3D; 5; &#x2F;&#x2F; -&gt; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 암묵적 타입 변환을 하지 않고 값을 비교한다.</span><br><span class="line">&#x2F;&#x2F; 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.</span><br><span class="line">5 &#x3D;&#x3D;&#x3D; &#39;5&#39;; &#x2F;&#x2F; -&gt; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; NaN은 자신과 일치하지 않는 유일한 값이다.</span><br><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN; &#x2F;&#x2F; -&gt; false</span><br></pre></td></tr></table></figure>

<p>NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 빌트인 함수 isNaN은 주어진 값이 NaN인지 체크하고 그 결과를 반환한다.</span><br><span class="line">isNaN(NaN); &#x2F;&#x2F; -&gt; true</span><br><span class="line">isNaN(10);  &#x2F;&#x2F; -&gt; false</span><br><span class="line">isNaN(1 + undefined); &#x2F;&#x2F; -&gt; true</span><br></pre></td></tr></table></figure>

<p>숫자 0도 주의하도록 하자. 자바스크립트에는 양의 0과 음의 0이 있는데 이들을 비교하면 true를 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 양의 0과 음의 0의 비교. 일치 비교&#x2F;동등 비교 모두 true이다.</span><br><span class="line">0 &#x3D;&#x3D;&#x3D; -0; &#x2F;&#x2F; -&gt; true</span><br><span class="line">0 &#x3D;&#x3D; -0;  &#x2F;&#x2F; -&gt; true</span><br></pre></td></tr></table></figure>

<pre><code>Object.is 메소드
위에서 살펴본 바와 같이 동등 비교 연산자(==)와 일치 비교 연산자(===)는 +0과 -0을 동일하다고 평가한다. 또한 동일한 값인 NaN과 NaN을 비교하면 다른 값이라고 평가한다.
ES6에서 새롭게 도입된 Object.is 메소드는 아래와 같이 예측 가능한 정확한 비교 결과를 반환한다. 그 외에는 일치 비교 연산자(===)와 동일하게 동작한다.</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-0 &#x3D;&#x3D;&#x3D; +0;         &#x2F;&#x2F; -&gt; true</span><br><span class="line">Object.is(-0, +0); &#x2F;&#x2F; -&gt; false</span><br><span class="line"></span><br><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN;         &#x2F;&#x2F; -&gt; false</span><br><span class="line">Object.is(NaN, NaN); &#x2F;&#x2F; -&gt; true</span><br></pre></td></tr></table></figure>

<p>부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대 개념이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 부동등 비교</span><br><span class="line">5 !&#x3D; 8;   &#x2F;&#x2F; -&gt; true</span><br><span class="line">5 !&#x3D; 5;   &#x2F;&#x2F; -&gt; false</span><br><span class="line">5 !&#x3D; &#39;5&#39;; &#x2F;&#x2F; -&gt; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 불일치 비교</span><br><span class="line">5 !&#x3D;&#x3D; 8;   &#x2F;&#x2F; -&gt; true</span><br><span class="line">5 !&#x3D;&#x3D; 5;   &#x2F;&#x2F; -&gt; false</span><br><span class="line">5 !&#x3D;&#x3D; &#39;5&#39;; &#x2F;&#x2F; -&gt; true</span><br></pre></td></tr></table></figure>

<h2 id="3-2-대소-관계-비교-연산자"><a href="#3-2-대소-관계-비교-연산자" class="headerlink" title="3.2. 대소 관계 비교 연산자"></a>3.2. 대소 관계 비교 연산자</h2><p>대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 대소 관계 비교</span><br><span class="line">5 &gt; 0;  &#x2F;&#x2F; -&gt; true</span><br><span class="line">5 &gt; 5;  &#x2F;&#x2F; -&gt; false</span><br><span class="line">5 &gt;&#x3D; 5; &#x2F;&#x2F; -&gt; true</span><br><span class="line">5 &lt;&#x3D; 5; &#x2F;&#x2F; -&gt; true</span><br></pre></td></tr></table></figure>
<br>

<h1 id="4-삼항-조건-연산자"><a href="#4-삼항-조건-연산자" class="headerlink" title="4. 삼항 조건 연산자"></a>4. 삼항 조건 연산자</h1><p>삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 자바스크립트의 유일한 삼항 연산자이며 부수 효과는 없다. 삼항 조건 연산자 표현식은 아래와 같이 사용한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값</span><br></pre></td></tr></table></figure>

<p>물음표(?) 앞의 첫번째 피연산자는 조건식, 즉 불리언 타입의 값으로 평가될 표현식이다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다. 이때 조건식이 참이면 콜론(:) 앞의 두번째 피연산자가 평가되어 반환되고, 거짓이면 콜론(:) 뒤의 세번째 피연산자가 평가되어 반환된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 2;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.</span><br><span class="line">var result &#x3D; x % 2 ? &#39;홀수&#39; : &#39;짝수&#39;;</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F; 짝수</span><br></pre></td></tr></table></figure>

<p>삼항 조건 연산자는 다음 장에서 살펴볼 if…else 문을 사용해도 동일한 처리를 할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 2, result;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.</span><br><span class="line">if (x % 2) result &#x3D; &#39;홀수&#39;;</span><br><span class="line">else       result &#x3D; &#39;짝수&#39;;</span><br><span class="line"></span><br><span class="line">console.log(result); &#x2F;&#x2F; 짝수</span><br></pre></td></tr></table></figure>

<p>하지만 if…else 문은 표현식이 아닌 문이다. 따라서 if…else 문은 값처럼 사용할 수 없다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; if...else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.</span><br><span class="line">var result &#x3D; if (x % 2) &#123; result &#x3D; &#39;홀수&#39;; &#125; else &#123; result &#x3D; &#39;짝수&#39;; &#125;;</span><br><span class="line">&#x2F;&#x2F; SyntaxError: Unexpected token if</span><br></pre></td></tr></table></figure>

<p><strong>삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다.</strong> 따라서 삼항 조건 연산자식은 값처럼 다른 표현식의 일부가 될 수 있어 매우 유용하다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 삼항 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.</span><br><span class="line">var result &#x3D; x % 2 ? &#39;홀수&#39; : &#39;짝수&#39;;</span><br><span class="line">console.log(result); &#x2F;&#x2F; 짝수</span><br></pre></td></tr></table></figure>

<p>조건에 따라 어떤 값을 결정해야 한다면 if…else 문보다 삼항 조건 연산자 표현식을 사용하는 것이 유리하다. 하지만 조건에 따라 수행해야 할 문이 하나가 아니라 여러 개라면 if…else 문이 보다 가독성이 좋다.<br><br></p>
<h1 id="5-논리-연산자"><a href="#5-논리-연산자" class="headerlink" title="5. 논리 연산자"></a>5. 논리 연산자</h1><p>논리 연산자(Logical Operator)는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 논리합(||) 연산자</span><br><span class="line">true || true;   &#x2F;&#x2F; -&gt; true</span><br><span class="line">true || false;  &#x2F;&#x2F; -&gt; true</span><br><span class="line">false || true;  &#x2F;&#x2F; -&gt; true</span><br><span class="line">false || false; &#x2F;&#x2F; -&gt; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 논리곱(&amp;&amp;) 연산자</span><br><span class="line">true &amp;&amp; true;   &#x2F;&#x2F; -&gt; true</span><br><span class="line">true &amp;&amp; false;  &#x2F;&#x2F; -&gt; false</span><br><span class="line">false &amp;&amp; true;  &#x2F;&#x2F; -&gt; false</span><br><span class="line">false &amp;&amp; false; &#x2F;&#x2F; -&gt; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 논리 부정(!) 연산자</span><br><span class="line">!true;  &#x2F;&#x2F; -&gt; false</span><br><span class="line">!false; &#x2F;&#x2F; -&gt; true</span><br></pre></td></tr></table></figure>

<p>논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단, 피연산자가 반드시 불리언 값일 필요는 없다. 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 암묵적 타입 변환</span><br><span class="line">!0;       &#x2F;&#x2F; -&gt; true</span><br><span class="line">!&#39;Hello&#39;; &#x2F;&#x2F; -&gt; false</span><br></pre></td></tr></table></figure>

<p>논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어는 한쪽으로 평가된다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 단축 평가</span><br><span class="line">&#39;Cat&#39; &amp;&amp; &#39;Dog&#39;; &#x2F;&#x2F; -&gt; &#39;Dog&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">!(x || y) &#x3D;&#x3D;&#x3D; (!x &amp;&amp; !y)</span><br><span class="line">!(x &amp;&amp; y) &#x3D;&#x3D;&#x3D; (!x || !y)</span><br></pre></td></tr></table></figure>
<br>

<h1 id="6-쉼표-연산자"><a href="#6-쉼표-연산자" class="headerlink" title="6. 쉼표 연산자"></a>6. 쉼표 연산자</h1><p>쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var x, y, z;</span><br><span class="line"></span><br><span class="line">x &#x3D; 1, y &#x3D; 2, z &#x3D; 3; &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<br>

<h1 id="7-그룹-연산자"><a href="#7-그룹-연산자" class="headerlink" title="7. 그룹 연산자"></a>7. 그룹 연산자</h1><p>그룹 연산자 (…)는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 따라서 그룹 연산자를 사용하면 연산자의 우선 순위를 조절할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 * 2 + 3; &#x2F;&#x2F; -&gt; 23</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 그룹 연산자를 사용하여 우선 순위 조절</span><br><span class="line">10 * (2 + 3); &#x2F;&#x2F; -&gt; 50</span><br></pre></td></tr></table></figure>
<p>위 예제의 첫번째 문은 10 * 2를 먼저 연산하고 그 다음 20 + 3을 연산한다. 수학에서와 마찬가지로 곱셈 연산자 *가 덧셈 연산자 +보다 우선 순위가 높기 때문이다.</p>
<p>두번째 문은 그룹 연산자로 감싼 표현식을 먼저 연산한다. 따라서 2 + 3을 먼저 연산하고 그 다음 10 * 5를 연산한다.<br><br></p>
<h1 id="8-typeof-연산자"><a href="#8-typeof-연산자" class="headerlink" title="8. typeof 연산자"></a>8. typeof 연산자</h1><p>typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자는 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다. “null”을 반환하는 경우는 없으며 함수의 경우 “function”을 반환한다. 이처럼 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않는다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">typeof &#39;&#39;              &#x2F;&#x2F; -&gt; &quot;string&quot;</span><br><span class="line">typeof 1               &#x2F;&#x2F; -&gt; &quot;number&quot;</span><br><span class="line">typeof NaN             &#x2F;&#x2F; -&gt; &quot;number&quot;</span><br><span class="line">typeof true            &#x2F;&#x2F; -&gt; &quot;boolean&quot;</span><br><span class="line">typeof undefined       &#x2F;&#x2F; -&gt; &quot;undefined&quot;</span><br><span class="line">typeof Symbol()        &#x2F;&#x2F; -&gt; &quot;symbol&quot;</span><br><span class="line">typeof null            &#x2F;&#x2F; -&gt; &quot;object&quot;</span><br><span class="line">typeof []              &#x2F;&#x2F; -&gt; &quot;object&quot;</span><br><span class="line">typeof &#123;&#125;              &#x2F;&#x2F; -&gt; &quot;object&quot;</span><br><span class="line">typeof new Date()      &#x2F;&#x2F; -&gt; &quot;object&quot;</span><br><span class="line">typeof &#x2F;test&#x2F;gi        &#x2F;&#x2F; -&gt; &quot;object&quot;</span><br><span class="line">typeof function () &#123;&#125;  &#x2F;&#x2F; -&gt; &quot;function&quot;</span><br></pre></td></tr></table></figure>

<p>typeof 연산자로 null 값을 연산해 보면 “null”이 아닌 “object”를 반환하는 것에 주의하자. 이것은 자바스크립트의 첫 번째 버전의 버그이다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다.</p>
<p>따라서 null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하도록 하자.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; null;</span><br><span class="line"></span><br><span class="line">typeof foo &#x3D;&#x3D;&#x3D; null; &#x2F;&#x2F; -&gt; false</span><br><span class="line">foo &#x3D;&#x3D;&#x3D; null;        &#x2F;&#x2F; -&gt; true</span><br></pre></td></tr></table></figure>

<p>또 하나 주의해야 할 것이 있다. 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 “undefined”를 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 식별자 undeclared는 선언한 적이 없다.</span><br><span class="line">typeof undeclared; &#x2F;&#x2F; -&gt; undefined</span><br></pre></td></tr></table></figure>

<p>typeof 연산자가 선언하지 않은 식별자를 연산했을 때 “undefined”를 반환하는 것을 카일 심슨의 “You don’t know JS”에서는 특별한 안전 가드(safety guard)로 설명한다. 하지만 모던 자바스크립트 개발에서는 대부분 모듈을 사용하고 전역 변수인 플래그를 사용하지 않으므로 의도적으로 사용할 필요는 없다.<br><br></p>
<h1 id="9-지수-연산자"><a href="#9-지수-연산자" class="headerlink" title="9. 지수 연산자"></a>9. 지수 연산자</h1><p>ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 ** 2;   &#x2F;&#x2F; -&gt; 4</span><br><span class="line">2 ** 2.5; &#x2F;&#x2F; -&gt; 5.65685424949238</span><br><span class="line">2 ** 0;   &#x2F;&#x2F; -&gt; 1</span><br><span class="line">2 ** -2;  &#x2F;&#x2F; -&gt; 0.25</span><br></pre></td></tr></table></figure>

<p>지수 연산자가 도입되기 이전에는 Math.pow 메소드를 사용하였다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(2, 2);   &#x2F;&#x2F; -&gt; 4</span><br><span class="line">Math.pow(2, 2.5); &#x2F;&#x2F; -&gt; 5.65685424949238</span><br><span class="line">Math.pow(2, 0);   &#x2F;&#x2F; -&gt; 1</span><br><span class="line">Math.pow(2, -2);  &#x2F;&#x2F; -&gt; 0.25</span><br></pre></td></tr></table></figure>

<p>지수 연산자는 여러 개의 피연산자를 사용할 경우, Math.pow 메소드보다 가독성이 좋다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 ** 2 ** 2; &#x2F;&#x2F; -&gt; 16</span><br><span class="line">Math.pow(Math.pow(2, 2), 2); &#x2F;&#x2F; -&gt; 16</span><br></pre></td></tr></table></figure>

<p>음수를 거듭제곱의 밑으로 계산하려면 아래와 같이 괄호로 묶어야 한다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-5 ** 2;</span><br><span class="line">&#x2F;&#x2F; -&gt; SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence</span><br><span class="line">(-5) ** 2; &#x2F;&#x2F; -&gt; 25</span><br></pre></td></tr></table></figure>

<p>지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var num &#x3D; 5;</span><br><span class="line">num **&#x3D; 2; &#x2F;&#x2F; -&gt; 25</span><br></pre></td></tr></table></figure>

<p>지수 연산자는 모든 이항 연산자보다 우선 순위가 높다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 * 5 ** 2; &#x2F;&#x2F; -&gt; 50</span><br></pre></td></tr></table></figure>
<br>

<h1 id="10-연산자의-부수-효과"><a href="#10-연산자의-부수-효과" class="headerlink" title="10. 연산자의 부수 효과"></a>10. 연산자의 부수 효과</h1><p>대부분의 연산자는 다른 코드에 영향을 주지 않는다. 예를 들어, 1 * 2는 다른 코드에 어떠한 영향도 주지 않는다. 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과(side effect)가 있다.</p>
<p>부수 효과가 있는 연산자는 할당(=) 연산자, 증가/감소(++/–) 연산자, delete 연산자이다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var x;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 할당 연산자는 변수 값이 변하는 부수 효과가 있다.</span><br><span class="line">&#x2F;&#x2F; 이는 변수 x를 사용하는 다른 코드에 영향을 준다.</span><br><span class="line">x &#x3D; 1;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 증가&#x2F;감소(++&#x2F;--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.</span><br><span class="line">&#x2F;&#x2F; 피연산자 x의 값이 변경된다. 이는 변수 x를 사용하는 다른 코드에 영향을 준다.</span><br><span class="line">x++;</span><br><span class="line">console.log(x); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">var o &#x3D; &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.</span><br><span class="line">&#x2F;&#x2F; 이는 객체 o를 사용하는 다른 코드에 영향을 준다.</span><br><span class="line">delete o.a;</span><br><span class="line">console.log(o); &#x2F;&#x2F; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>delete 연산자는 객체의 프로퍼티를 삭제한다. 이에 대해서는 객체에 대해 살펴본 다음 “프로퍼티 삭제”에서 알아보도록 하자.</p>

        </div>
        
        
        
    </div>
</div>









    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/tags/github/page/0/">Previous</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/tags/github/page/2/">Next</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/tags/github/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/tags/github/page/2/">2</a></li>
            
        </ul>
    </nav>
</div>
</div>
                




<div class="column is-4-tablet is-4-desktop is-4-widescreen  has-order-1 column-left is-sticky">
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered" style="flex-shrink: 1">
                <div>
                    
                    <figure class="image is-128x128 has-mb-6">
                        <img class="" src="/images/avatar.png" alt="namkwon">
                    </figure>
                    
                    <p class="is-size-4 is-block">
                        namkwon
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        welcome my gitBlog
                    </p>
                    
                    
                    <p class="is-size-6 is-flex is-flex-center has-text-grey">
                        <i class="fas fa-map-marker-alt has-mr-7"></i>
                        <span>korea/seoul</span>
                    </p>
                    
                </div>
            </div>
        </nav>
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Posts
                    </p>
                    <a href="/archives">
                        <p class="title has-text-weight-normal">
                            16
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Categories
                    </p>
                    <a href="/categories">
                        <p class="title has-text-weight-normal">
                            3
                        </p>
                    </a>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Tags
                    </p>
                    <a href="/tags">
                        <p class="title has-text-weight-normal">
                            12
                        </p>
                    </a>
                </div>
            </div>
        </nav>
        
        <div class="level">
            <a class="level-item button is-link is-rounded" href="https://github.com/Leenamkwon" target="_blank" rel="noopener">
                Follow</a>
        </div>
        
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Github" href="https://github.com/Leenamkwon">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Facebook" href="https://facebook.com">
                
                <i class="fab fa-facebook"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Twitter" href="https://twitter.com">
                
                <i class="fab fa-twitter"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="Dribbble" href="https://dribbble.com">
                
                <i class="fab fa-dribbble"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" rel="noopener"
                title="RSS" href="/">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
    </div>
</div>
    
        
    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categories
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/JavaScript/">
            <span class="level-start">
                <span class="level-item">JavaScript</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/JavaScript/vue-js/">
            <span class="level-start">
                <span class="level-item">vue.js</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/React/">
            <span class="level-start">
                <span class="level-item">React</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        <div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-08T06:02:03.000Z">2020-03-08</time></div>
                    <a href="/2020/03/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/" class="title has-link-black-ter is-size-6 has-text-weight-normal">프로토타입 | javaScript</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/JavaScript/">JavaScript</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-04T04:00:03.000Z">2020-03-04</time></div>
                    <a href="/2020/03/%ED%95%A8%EC%88%98%EC%99%80%20%EC%9D%BC%EA%B8%89%20%EA%B0%9D%EC%B2%B4/" class="title has-link-black-ter is-size-6 has-text-weight-normal">함수와 일급 객체 | javaScript</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/JavaScript/">JavaScript</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-03T11:02:03.000Z">2020-03-03</time></div>
                    <a href="/2020/03/property_attribute/" class="title has-link-black-ter is-size-6 has-text-weight-normal">프로퍼티 어트리뷰트 | javaScript</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-03T11:02:03.000Z">2020-03-03</time></div>
                    <a href="/2020/03/%EC%83%9D%EC%84%B1%EC%9E%90%ED%95%A8%EC%88%98/" class="title has-link-black-ter is-size-6 has-text-weight-normal">생성자 함수에 의한 객체 생성 | javaScript</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/JavaScript/">JavaScript</a> / <a class="has-link-grey -link" href="/categories/JavaScript/vue-js/">vue.js</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2020-03-02T04:53:10.000Z">2020-03-02</time></div>
                    <a href="/2020/03/let_const/" class="title has-link-black-ter is-size-6 has-text-weight-normal">let과 const | javaScript</a>
                    <p class="is-size-7 is-uppercase">
                        
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>
    
    
        <div class="column-right-shadow is-hidden-widescreen is-sticky">
        
        </div>
    
</div>

                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="namkwon&#39;s tech blog" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 Lee namkwon&nbsp;
                Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a
                        href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
                <div class="field has-addons is-flex-center-mobile has-mt-5-mobile is-flex-wrap is-flex-middle">
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/">
                        
                        <i class="fab fa-creative-commons"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/">
                        
                        <i class="fab fa-creative-commons-by"></i>
                        
                    </a>
                </p>
                
                <p class="control">
                    <a class="button is-white is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus">
                        
                        <i class="fab fa-github"></i>
                        
                    </a>
                </p>
                
                </div>
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


<script>
var IcarusThemeSettings = {
    site: {
        url: 'https://github.com/Leenamkwon/Leenamkwon.github.io',
        external_link: {"enable":true,"exclude":[]}
    },
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


<script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>





<script src="/js/animation.js"></script>



<script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
<script src="/js/gallery.js" defer></script>



<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>


<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>














<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>