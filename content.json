{"pages":[{"title":"categories","text":"","link":"/categories/index.html"}],"posts":[{"title":"날짜와 시간을 위한 Date 객체 | javaScript","text":"Date 객체는 날짜와 시간(년, 월, 일, 시, 분, 초, 밀리초(천분의 1초(millisecond, ms)))을 위한 메소드를 제공하는 빌트인 객체이면서 생성자 함수이다. Date 생성자 함수로 생성한 Date 객체는 내부적으로 숫자값을 갖는다. 이 값은 1970년 1월 1일 00:00(UTC)을 기점으로 현재 시간까지의 밀리초를 나타낸다. UTC(협정 세계시: Coordinated Universal Time)는 GMT(그리니치 평균시: Greenwich Mean Time)로 불리기도 하는데 UTC와 GMT는 초의 소숫점 단위에서만 차이가 나기 때문에 일상에서는 혼용되어 사용된다. 기술적인 표기에서는 UTC가 사용된다. KST(Korea Standard Time)는 UTC/GMT에 9시간을 더한 시간이다. 즉, KST는 UTC/GMT보다 9시간이 빠르다. 예를 들어, UTC 00:00 AM은 KST 09:00 AM이다. 현재의 날짜와 시간은 자바스크립트 코드가 동작한 시스템의 시계에 의해 결정된다. 시스템 시계의 설정(timezone, 시간)에 따라 서로 다른 값을 가질 수 있다. 1. Date Constructor Date 객체는 생성자 함수이다. Date 생성자 함수는 날짜와 시간을 가지는 인스턴스를 생성한다. 생성된 인스턴스는 기본적으로 현재 날짜와 시간을 나타내는 값을 가진다. Date 생성자 함수에 명시적으로 해당 날짜와 시간 정보를 인수로 지정한다. 1.1 new Date() 인수를 전달하지 않으면 현재 날짜와 시간을 가지는 인스턴스를 반환한다. 12const date = new Date();console.log(date); // Thu May 26 20200 17:16:13 GMT+0900 (한국 표준시) 1.2 new Date(milliseconds) 인수로 숫자 타입의 밀리초를 전달하면 1970년 1월 1일 00:00(UTC)을 기점으로 인수로 전달된 밀리초만큼 경과한 날짜와 시간을 가지는 인스턴스를 반환한다. 1234567891011// KST(Korea Standard Time)는 GMT(그리니치 평균시: Greenwich Mean Time)에 9시간을 더한 시간이다.let date = new Date(0);console.log(date); // Thu Jan 01 1970 09:00:00 GMT+0900 (한국 표준시)// 86400000ms는 1day를 의미한다.// 1s = 1,000ms// 1m = 60s * 1,000ms = 60,000ms// 1h = 60m * 60,000ms = 3,600,000ms// 1d = 24h * 3,600,000ms = 86,400,000msdate = new Date(86400000);console.log(date); // FFri Jan 02 1970 09:00:00 GMT+0900 (한국 표준시) 1.3 new Date(dateString) 인수로 날짜와 시간을 나타내는 문자열을 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다. 이때 인수로 전달한 문자열은 Date.parse 메소드에 의해 해석 가능한 형식이어야 한다. 1234let date = new Date('May 16, 2019 17:22:10');date = new Date('2019/05/16/17:22:10');console.log(date); // Thu May 16 2019 17:22:10 GMT+0900 (한국 표준시) 1.4 new Date(year, month[, day, hour, minute, second, millisecond])인수로 년, 월, 일, 시, 분, 초, 밀리초를 의미하는 숫자를 전달하면 지정된 날짜와 시간을 가지는 인스턴스를 반환한다. 이때 년, 월은 반드시 지정하여야 한다. 지정하지 않은 옵션 정보는 0 또는 1으로 초기화된다. 인수는 다음과 같다. 인수 내용 year 1900년 이후의 년 month 월을 나타내는 0 ~ 11까지의 정수(주의: 0부터 시작, 0 = 1월) day 일을 나타내는 1 ~ 31까지의 정수 hour 시를 나타내는 0 ~ 23까지의 정수 minute 분을 나타내는 0 ~ 59까지의 정수 second 초를 나타내는 0 ~ 59까지의 정수 millisecond 밀리초를 나타내는 0 ~ 999까지의 정수 년, 월을 지정하지 않은 경우 1970년 1월 1일 00:00(UTC)을 가지는 인스턴스를 반환한다. 12345678910111213// 월을 나타내는 4는 5월을 의미한다.// 2019/5/1/00:00:00:00let date = new Date(2019, 4);console.log(date); // Wed May 01 2019 00:00:00 GMT+0900 (한국 표준시)// 월을 나타내는 4는 5월을 의미한다.// 2019/5/16/17:24:30:00date = new Date(2019, 4, 16, 17, 24, 30, 0);console.log(date); // Thu May 16 2019 17:24:30 GMT+0900 (한국 표준시)// 가독성이 훨씬 좋다.date = new Date('2019/5/16/17:24:30:10');console.log(date); // Thu May 16 2019 17:24:30 GMT+0900 (한국 표준시) 1.5 Date 생성자 함수를 new 연산자없이 호출 Date 생성자 함수를 new 연산자없이 호출하면 인스턴스를 반환하지 않고 결과값을 문자열로 반환한다. 12let date = Date();console.log(typeof date, date); // string Thu May 16 2019 17:33:03 GMT+0900 (한국 표준시) 2. Date 메소드 2.1 Date.now 1970년 1월 1일 00:00:00(UTC)을 기점으로 현재 시간까지 경과한 밀리초를 숫자로 반환한다. 12const now = Date.now();console.log(now); 2.2 Date.Parse 1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간(new Date(dateString)의 인수와 동일한 형식)까지의 밀리초를 숫자로 반환한다. 12345678let d = Date.parse('Jan 2, 1970 00:00:00 UTC'); // UTCconsole.log(d); // 86400000d = Date.parse('Jan 2, 1970 09:00:00'); // KSTconsole.log(d); // 86400000d = Date.parse('1970/01/02/09:00:00'); // KSTconsole.log(d); // 86400000 2.3 Date.UTC 1970년 1월 1일 00:00:00(UTC)을 기점으로 인수로 전달된 지정 시간까지의 밀리초를 숫자로 반환한다. Date.UTC 메소드는 new Date(year, month[, day, hour, minute, second, millisecond]) 와 같은 형식의 인수를 사용해야 한다. Date.UTC 메소드의 인수는 local time(KST)가 아닌 UTC로 인식된다. 12345let d = Date.UTC(1970, 0, 2);console.log(d); // 86400000d = Date.UTC('1970/1/2');console.log(d); // NaN month는 월을 의미하는 0~11까지의 정수이다. 0부터 시작하므로 주의가 필요하다. 2.4 Date.prototype.getFullYear 년도를 나타내는 4자리 숫자를 반환한다. 12345const today = new Date();const year = today.getFullYear();console.log(today); // Thu May 16 2019 17:39:30 GMT+0900 (한국 표준시)console.log(year); // 2019 2.5 Date.prototype.setFullYear년도를 나타내는 4자리 숫자를 설정한다.년도 이외 월, 일도 설정할 수 있다. 1dateObj.setFullYear(year[, month[, day]]) 123456789101112131415const today = new Date();// 년도 지정today.setFullYear(2000);let year = today.getFullYear();console.log(today); // Tue May 16 2000 17:42:40 GMT+0900 (한국 표준시)console.log(year); // 2000// 년도 지정today.setFullYear(1900, 0, 1);year = today.getFullYear();console.log(today); // Mon Jan 01 1900 17:42:40 GMT+0827 (한국 표준시)console.log(year); // 1900 2.6 Date.prototype.getMonth 월을 나타내는 0 ~ 11의 정수를 반환한다. 1월은 0, 12월은 11이다. 12345const today = new Date();const month = today.getMonth();console.log(today); // Thu May 16 2019 17:44:03 GMT+0900 (한국 표준시)console.log(month); // 4 2.7 Date.prototype.setMonth 월을 나타내는 0 ~ 11의 정수를 설정한다. 1월은 0, 12월은 11이다.월 이외 일도 설정할 수 있다. 12345678910111213141516dateObj.setMonth(month[, day])const today = new Date();// 월을 지정today.setMonth(0); // 1월let month = today.getMonth();console.log(today); // Wed Jan 16 2019 17:45:20 GMT+0900 (한국 표준시)console.log(month); // 0// 월/일을 지정today.setMonth(11, 1); // 12월 1일month = today.getMonth();console.log(today); // Sun Dec 01 2019 17:45:20 GMT+0900 (한국 표준시)console.log(month); // 11 2.8 Date.prototype.getDate 날짜(1~31)를 나타내는 정수를 반환한다. 12345const today = new Date();const date = today.getDate();console.log(today); // Thu May 16 2019 17:46:42 GMT+0900 (한국 표준시)console.log(date); // 16 2.9 Date.prototype.getDate 날짜(1~31)를 나타내는 정수를 반환한다. 12345const today = new Date();const date = today.getDate();console.log(today); // Thu May 16 2019 17:46:42 GMT+0900 (한국 표준시)console.log(date); // 16 2.10 Date.prototype.getDay요일(0 ~ 6)를 나타내는 정수를 반환한다. 반환값은 아래와 같다. 요일 반환값 일요일 0 월요일 1 화요일 2 수요일 3 목요일 4 금요일 5 토요일 6 12345const today = new Date();const day = today.getDay();console.log(today); // Thu May 16 2019 17:47:31 GMT+0900 (한국 표준시)console.log(day); // 4 2.11 Date.prototype.getHours 시간(0 ~ 23)를 나타내는 정수를 반환한다. 12345const today = new Date();const hours = today.getHours();console.log(today); // Thu May 16 2019 17:48:03 GMT+0900 (한국 표준시)console.log(hours); // 17 2.12 Date.prototype.setHours 시간(0~23)를 나타내는 정수를 설정한다.시간 이외 분, 초, 밀리초도 설정할 수 있다. 1dateObj.setHours(hour[, minute[, second[, ms]]]) 12345678910111213// 시간 지정today.setHours(7);let hours = today.getHours();console.log(today); // Thu May 16 2019 07:49:06 GMT+0900 (한국 표준시)console.log(hours); // 7// 시간/분/초/밀리초 지정today.setHours(0, 0, 0, 0); // 00:00:00:00hours = today.getHours();console.log(today); // Thu May 16 2019 00:00:00 GMT+0900 (한국 표준시)console.log(hours); // 0 2.13 Date.prototype.getMinutes 분(0 ~ 59)를 나타내는 정수를 반환한다. 12345const today = new Date();const minutes = today.getMinutes();console.log(today); // Thu May 16 2019 17:50:29 GMT+0900 (한국 표준시)console.log(minutes); // 50 2.14 Date.prototype.setMinutes 분(0 ~ 59)를 나타내는 정수를 설정한다. 분 이외 초, 밀리초도 설정할 수 있다. 1dateObj.setMinutes(minute[, second[, ms]]) 123456789101112131415const today = new Date();// 분 지정today.setMinutes(50);let minutes = today.getMinutes();console.log(today); // Thu May 16 2019 17:50:30 GMT+0900 (한국 표준시)console.log(minutes); // 50// 분/초/밀리초 지정today.setMinutes(5, 10, 999); // HH:05:10:999minutes = today.getMinutes();console.log(today); // Thu May 16 2019 17:05:10 GMT+0900 (한국 표준시)console.log(minutes); // 5 2.15 Date.prototype.getSeconds 초(0 ~ 59)를 나타내는 정수를 반환한다. 12345const today = new Date();const seconds = today.getSeconds();console.log(today); // Thu May 16 2019 17:53:17 GMT+0900 (한국 표준시)console.log(seconds); // 17 2.16 Date.prototype.setSeconds 초(0 ~ 59)를 나타내는 정수를 설정한다. 초 이외 밀리초도 설정할 수 있다. 1dateObj.setSeconds(second[, ms]) 123456789101112131415const today = new Date();// 초 지정today.setSeconds(30);let seconds = today.getSeconds();console.log(today); // Thu May 16 2019 17:54:30 GMT+0900 (한국 표준시)console.log(seconds); // 30// 초/밀리초 지정today.setSeconds(10, 0); // HH:MM:10:000seconds = today.getSeconds();console.log(today); // Thu May 16 2019 17:54:10 GMT+0900 (한국 표준시)console.log(seconds); // 10 2.17 Date.prototype.getMilliseconds밀리초(0~999)를 나타내는 정수를 반환한다. 12345const today = new Date();const ms = today.getMilliseconds();console.log(today); // Thu May 16 2019 17:55:02 GMT+0900 (한국 표준시)console.log(ms); // 905 2.18 Date.prototype.setMilliseconds 12345678910밀리초(0 ~ 999)를 나타내는 정수를 설정한다.const today = new Date();// 밀리초 지정today.setMilliseconds(123);const ms = today.getMilliseconds();console.log(today); // Thu May 16 2019 17:55:45 GMT+0900 (한국 표준시)console.log(ms); // 123 2.19 Date.prototype.getTime 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초를 반환한다. 12345const today = new Date();const time = today.getTime();console.log(today); // Thu May 16 2019 17:56:08 GMT+0900 (한국 표준시)console.log(time); // 1557996968335 2.20 Date.prototype.setTime 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초를 설정한다. 1dateObj.setTime(time) 12345678const today = new Date();// 1970년 1월 1일 00:00:00(UTC)를 기점으로 현재 시간까지 경과된 밀리초 지정today.setTime(86400000); // 86400000 === 1dayconst time = today.getTime();console.log(today); // Fri Jan 02 1970 09:00:00 GMT+0900 (한국 표준시)console.log(time); // 86400000 2.21 Date.prototype.getTimezoneOffset UTC와 지정 로케일(Locale) 시간과의 차이를 분단위로 반환한다. 12345const today = new Date();const x = today.getTimezoneOffset() / 60; // -9console.log(today); // Thu May 16 2019 17:58:13 GMT+0900 (한국 표준시)console.log(x); // -9 KST(Korea Standard Time)는 UTC에 9시간을 더한 시간이다. 즉, UTC = KST - 9h이다. 2.22 Date.prototype.toDateString 사람이 읽을 수 있는 형식의 문자열로 날짜를 반환한다. 1234const d = new Date('2019/5/16/18:30');console.log(d.toString()); // Thu May 16 2019 18:30:00 GMT+0900 (한국 표준시)console.log(d.toDateString()); // Thu May 16 2019 2.23 Date.prototype.toTimeString 사람이 읽을 수 있는 형식의 문자열로 시간을 반환한다. 1234const d = new Date('2019/5/16/18:30');console.log(d.toString()); // Thu May 16 2019 18:30:00 GMT+0900 (한국 표준시)console.log(d.toTimeString()); // 18:30:00 GMT+0900 (한국 표준시) 3. Date Example 현재 날짜와 시간을 초단위로 반복 출력하는 예제이다. 1234567891011121314151617181920212223242526272829(function printNow() { const today = new Date(); const dayNames = ['(일요일)', '(월요일)', '(화요일)', '(수요일)', '(목요일)', '(금요일)', '(토요일)']; // getDay: 해당 요일(0 ~ 6)를 나타내는 정수를 반환한다. const day = dayNames[today.getDay()]; const year = today.getFullYear(); const month = today.getMonth() + 1; const date = today.getDate(); let hour = today.getHours(); let minute = today.getMinutes(); let second = today.getSeconds(); const ampm = hour &gt;= 12 ? 'PM' : 'AM'; // 12시간제로 변경 hour %= 12; hour = hour || 12; // 0 =&gt; 12 // 10미만인 분과 초를 2자리로 변경 minute = minute &lt; 10 ? '0' + minute : minute; second = second &lt; 10 ? '0' + second : second; const now = `${year}년 ${month}월 ${date}일 ${day} ${hour}:${minute}:${second} ${ampm}`; console.log(now); setTimeout(printNow, 1000);}());&lt;br&gt;","link":"/2020/03/Date/"},{"title":"수학 상수와 함수를 위한 Math 객체 | javaScript","text":"Math 객체는 수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 빌트인 객체이다. Math 객체는 생성자 함수가 아니다. 따라서 Math 객체는 정적(static) 프로퍼티와 메소드만을 제공한다. 사용 빈도가 높은 프로퍼티와 메소드만을 설명한다. 1. Math Property 1.1 Math.PIPI 값(π ≈ 3.141592653589793)을 반환한다. 2. Math Method 2.1 Math.abs(x: number):number 인수의 절댓값을 반환한다. 절댓값은 반드시 0 또는 양수이어야 한다. 123456789Math.abs(-1); // 1Math.abs('-1'); // 1Math.abs(''); // 0Math.abs([]); // 0Math.abs(null); // 0Math.abs(undefined);// NaNMath.abs({}); // NaNMath.abs('string'); // NaNMath.abs(); // NaN 2.2 Math.round(x: number):number 인수의 소수점 이하를 반올림한 정수를 반환한다. 123456Math.round(1.4); // 1Math.round(1.6); // 2Math.round(-1.4); // -1Math.round(-1.6); // -2Math.round(1); // 1Math.round(); // NaN 2.3 Math.ceil(x: number): number 인수의 소수점 이하를 올림한 정수를 반환한다. 123456Math.round(1.4); // 1Math.round(1.6); // 2Math.round(-1.4); // -1Math.round(-1.6); // -2Math.round(1); // 1Math.round(); // NaN 2.4 Math.floor(x: number): number 인수의 소수점 이하를 내림한 정수를 반환한다. Math.ceil의 반대 개념이다. 양수인 경우, 소수점 이하를 떼어 버린 다음 정수를 반환한다. 음수인 경우, 소수점 이하를 떼어 버린 다음 -1을 한 정수를 반환한다. 123456Math.floor(1.9); // 1Math.floor(9.1); // 9Math.floor(-1.9); // -2Math.floor(-9.1); // -10Math.floor(1); // 1Math.floor(); // NaN 2.5 Math.sqrt(x: number): number 인수의 제곱근을 반환한다. 123456Math.sqrt(9); // 3Math.sqrt(-9); // NaNMath.sqrt(2); // 1.414213562373095Math.sqrt(1); // 1Math.sqrt(0); // 0Math.sqrt(); // NaN 2.6 Math.random(): number 임의의 부동 소수점을 반환한다. 반환된 부동 소수점은 0부터 1 미만이다. 즉, 0은 포함되지만 1은 포함되지 않는다. 12345678Math.random(); // 0 ~ 1 미만의 부동 소수점 (0.8208720231391746)// 1 ~ 10의 랜덤 정수 취득// 1) Math.random로 0 ~ 1 미만의 부동 소수점을 구한 다음, 10을 곱해 0 ~ 10 미만의 부동 소수점을 구한다.// 2) 0 ~ 10 미만의 부동 소수점에 1을 더해 1 ~ 10까지의 부동 소수점을 구한다.// 3) Math.floor으로 1 ~ 10까지의 부동 소수점의 소수점 이하를 떼어 버린 다음 정수를 반환한다.const random = Math.floor((Math.random() * 10) + 1);console.log(random); // 1 ~ 10까지의 정수 2.7 Math.pow(x: number, y: number): number 첫번째 인수를 밑(base), 두번째 인수를 지수(exponent)로하여 거듭제곱을 반환한다. 123456Math.pow(2, 8); // 256Math.pow(2, -1); // 0.5Math.pow(2); // NaN// ES7(ECMAScript 2016) Exponentiation operator(거듭 제곱 연산자)2 ** 8; // 256 2.8 Math.max(…values: number[]): number 인수 중에서 가장 큰 수를 반환한다. 12345678Math.max(1, 2, 3); // 3// 배열 요소 중에서 최대값 취득const arr = [1, 2, 3];const max = Math.max.apply(null, arr); // 3// ES6 Spread operatorMath.max(...arr); // 3 2.9 Math.min(…values: number[]): number 인수 중에서 가장 큰 수를 반환한다. 12345678910111213Math.min(1, 2, 3); // 1// 배열 요소 중에서 최소값 취득const arr = [1, 2, 3];// 최소값 const min = Math.min.apply(null, arr); // 1// 최댓값const max = Math.max.apply(null, arr); // 3// ES6 Spread operatorMath.min(...arr); // 1","link":"/2020/03/Math/"},{"title":"정규표현식 | javaScript","text":"1. 정규표현식(Regular Expression) 정규표현식(Regular Expression)은 문자열에서 특정 내용을 찾거나 대체 또는 발췌하는데 사용한다. 예를 들어 회원가입 화면에서 사용자로 부터 입력 받는 전화번호가 유효한지 체크할 필요가 있다. 이때 정규표현식을 사용하면 간단히 처리할 수 있다. 123456const tel = '0101234567팔';// 정규 표현식 리터럴const myRegExp = /^[0-9]+$/;console.log(myRegExp.test(tel)); // false 반복문과 조건문을 사용한 복잡한 코드도 정규표현식을 이용하면 매우 간단하게 표현할 수 있다. 하지만 정규표현식은 주석이나 공백을 허용하지 않고 여러가지 기호를 혼합하여 사용하기 때문에 가독성이 좋지 않다는 문제가 있다. 정규표현식은 리터럴 표기법으로 생성할 수 있다. 정규 표현식 리터럴은 아래와 같이 표현한다. 정규표현식을 사용하는 자바스크립트 메소드는 RegExp.prototype.exec, RegExp.prototype.test, String.prototype.match, String.prototype.replace, String.prototype.search, String.prototype.split 등이 있다. 12345678910111213const targetStr = 'This is a pen.';const regexr = /is/ig;// RegExp 객체의 메소드console.log(regexr.exec(targetStr)); // [ 'is', index: 2, input: 'This is a pen.' ]console.log(regexr.test(targetStr)); // true// String 객체의 메소드console.log(targetStr.match(regexr)); // [ 'is', 'is' ]console.log(targetStr.replace(regexr, 'IS')); // ThIS IS a pen.// String.prototype.search는 검색된 문자열의 첫번째 인덱스를 반환한다.console.log(targetStr.search(regexr)); // 2 ← indexconsole.log(targetStr.split(regexr)); // [ 'Th', ' ', ' a pen.' ] 1.2 플래그 플래그는 아래와 같은 종류가 있다. Flag Meaning Description i Ignore Case 대소문자를 구별하지 않고 검색한다. g Global 문자열 내의 모든 패턴을 검색한다. m Multi Line 문자열의 행이 바뀌더라도 검색을 계속한다. 플래그는 옵션이므로 선택적으로 사용한다.플래그를 사용하지 않은 경우 문자열 내 검색 매칭 대상이 1개 이상이더라도 첫번째 매칭한 대상만을 검색하고 종료한다. 123456789101112const targetStr = 'Is this all there is?';// 문자열 is를 대소문자를 구별하여 한번만 검색한다.let regexr = /is/;console.log(targetStr.match(regexr)); // [ 'is', index: 5, input: 'Is this all there is?' ]// 문자열 is를 대소문자를 구별하지 않고 대상 문자열 끝까지 검색한다.regexr = /is/ig;console.log(targetStr.match(regexr)); // [ 'Is', 'is', 'is' ]console.log(targetStr.match(regexr).length); // 3 1.2 패턴 패턴에는 검색하고 싶은 문자열을 지정한다. 이때 문자열의 따옴표는 생략한다. 따옴표를 포함하면 따옴표까지도 검색한다. 또한 패턴은 특별한 의미를 가지는 메타문자(Metacharacter) 또는 기호로 표현할 수 있다. 몇가지 패턴 표현 방법을 소개한다. 1234const targetStr = 'AA BB Aa Bb';// 임의의 문자 3개const regexr = /.../; . 은 임의의 문자 한 개를 의미한다. 문자의 내용은 무엇이든지 상관없다. 위 예제의 경우 . 를 3개 연속하여 패턴을 생성하였으므로 3자리 문자를 추출한다. 1console.log(targetStr.match(regexr)); // [ 'AA ', index: 0, input: 'AA BB Aa Bb' ] 이떄 추출을 반복하지 않는다. 반복하기 위해서는 플래그 g 를 사용한다. 123456const targetStr = 'AA BB Aa Bb';// 임의의 문자 3개를 반복하여 검색const regexr = /.../g;console.log(targetStr.match(regexr)); // [ 'AA ', 'BB ', 'Aa ' ] 모든 문자를 선택하려면 . 와 g 를 동시에 지정한다. 1234567const targetStr = 'AA BB Aa Bb';// 임의의 한문자를 반복 검색const regexr = /./g;console.log(targetStr.match(regexr));// [ 'A', 'A', ' ', 'B', 'B', ' ', 'A', 'a', ' ', 'B', 'b' ] 패턴에 문자 또는 문자열을 지정하면 일치하는 문자 또는 문자열을 추출한다. 123456const targetStr = 'AA BB Aa Bb';// 'A'를 검색const regexr = /A/;console.log(targetStr.match(regexr)); // 'A' 이떄 대소문자를 구별하며 패턴과 일치한 첫번쨰 결과만 반환된다. 대소문자를 구별하지 않게 하려면 플래그 i 를 사용한다. 123456const targetStr = 'AA BB Aa Bb';// 'A'를 대소문자 구분없이 반복 검색const regexr = /A/ig;console.log(targetStr.match(regexr)); // [ 'A', 'A', 'A', 'a' ] 앞선 패턴을 최소 한번 반복하려면 앞선 패턴 뒤에 + 를 붙인다. 아래 예제의 경우, 앞선 패턴은 A이므로 A+는 A만으로 이루어진 문자열(‘A’, ‘AA’, ‘AAA’, …)를 의미한다. 123456const targetStr = 'AA AAA BB Aa Bb';// 'A'가 한번이상 반복되는 문자열('A', 'AA', 'AAA', ...)을 반복 검색const regexr = /A+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'AAA', 'A' ] | 를 사용하면 or의 의미를 가지게 된다. 123456const targetStr = 'AA BB Aa Bb';// 'A' 또는 'B'를 반복 검색const regexr = /A|B/g;console.log(targetStr.match(regexr)); // [ 'A', 'A', 'B', 'B', 'A', 'B' ] 분해되지 않은 단어 레벨로 추출하기 위해서는 + 를 같이 사용하면 된다. 1234567const targetStr = 'AA AAA BB Aa Bb';// 'A' 또는 'B'가 한번 이상 반복되는 문자열을 반복 검색// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ...const regexr = /A+|B+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'AAA', 'BB', 'A', 'B' ] 위 예제는 패턴을 or로 한번 이상 반복하는 것인데 간단히 표현하면 아래와 같다. [] 내의 문자는 or로 동작한다. 그 뒤에 +를 사용하여 앞선 패턴을 한번 이상 반복하게 한다. 1234567const targetStr = 'AA BB Aa Bb';// 'A' 또는 'B'가 한번 이상 반복되는 문자열을 반복 검색// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ...const regexr = /[AB]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'A', 'B' ] 범위를 지정하려면 [] 내에 - 를 사용한다. 아래의 경우 대문자 알파벳을 추출한다. 12345678const targetStr = 'AA BB ZZ Aa Bb';// 'A' ~ 'Z'가 한번 이상 반복되는 문자열을 반복 검색// 'A', 'AA', 'AAA', ... 또는 'B', 'BB', 'BBB', ... ~ 또는 'Z', 'ZZ', 'ZZZ', ...const regexr = /[A-Z]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'ZZ', 'A', 'B' ] 대소문자를 구별하지 않고 알파벳을 추출하려면 아래와 같이 한다. 12345678const targetStr = 'AA BB Aa Bb';// 'A' ~ 'Z' 또는 'a' ~ 'z'가 한번 이상 반복되는 문자열을 반복 검색const regexr = /[A-Za-z]+/g;// 아래와 동일하다.// const regexr = /[A-Z]+/gi;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'Aa', 'Bb' ] 숫자를 추출하는 방법이다. 123456const targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9'가 한번 이상 반복되는 문자열을 반복 검색const regexr = /[0-9]+/g;console.log(targetStr.match(regexr)); // [ '24', '000' ] 컴마 떄문에 결과가 분리되므로 패턴에 포함시킨다. 123456const targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9' 또는 ','가 한번 이상 반복되는 문자열을 반복 검색const regexr = /[0-9,]+/g;console.log(targetStr.match(regexr)); // [ '24,000' ] 이것을 간단히 표현하면 아래와 같다. \\d 는 숫자를 의미한다. \\D 는 \\d 와 반대로 동작한다. 1234567891011const targetStr = 'AA BB Aa Bb 24,000';// '0' ~ '9' 또는 ','가 한번 이상 반복되는 문자열을 반복 검색let regexr = /[\\d,]+/g;console.log(targetStr.match(regexr)); // [ '24,000' ]// '0' ~ '9'가 아닌 문자(숫자가 아닌 문자) 또는 ','가 한번 이상 반복되는 문자열을 반복 검색regexr = /[\\D,]+/g;console.log(targetStr.match(regexr)); // [ 'AA BB Aa Bb ', ',' ] \\w 는 알파벳과 숫자를 의미한다. \\W 는 \\w 와 반대로 동작한다. 1234567891011const targetStr = 'AA BB Aa Bb 24,000';// 알파벳과 숫자 또는 ','가 한번 이상 반복되는 문자열을 반복 검색let regexr = /[\\w,]+/g;console.log(targetStr.match(regexr)); // [ 'AA', 'BB', 'Aa', 'Bb', '24,000' ]// 알파벳과 숫자가 아닌 문자 또는 ','가 한번 이상 반복되는 문자열을 반복 검색regexr = /[\\W,]+/g;console.log(targetStr.match(regexr)); // [ ' ', ' ', ' ', ' ', ',' ] 1.3 자주 사용하는 정규표현식 특정 단어로 시작하는지 검사한다. 1234567const url = 'http://example.com';// 'http'로 시작하는지 검사// ^ : 문자열의 처음을 의미한다.const regexr = /^http/;console.log(regexr.test(url)); // true 특정 단어로 끝나는지 검사한다. 1234567const fileName = 'index.html';// 'html'로 끝나는지 검사// $ : 문자열의 끝을 의미한다.const regexr = /html$/;console.log(regexr.test(fileName)); // true 숫자인지 검사한다. 12345678const targetStr = '12345';// 모두 숫자인지 검사// [^]: 부정(not)을 의미한다. 얘를 들어 [^a-z]는 알파벳 소문자로 시작하지 않는 모든 문자를 의미한다.// [] 바깥의 ^는 문자열의 처음을 의미한다.const regexr = /^\\d+$/;console.log(regexr.test(targetStr)); // true 하나 이상의 공백으로 시작하는지 검사한다. 1234567const targetStr = ' Hi!';// 1개 이상의 공백으로 시작하는지 검사// \\s : 여러 가지 공백 문자 (스페이스, 탭 등) =&gt; [\\t\\r\\n\\v\\f]const regexr = /^[\\s]+/;console.log(regexr.test(targetStr)); // true 아이디로 사용 가능한지 검사한다. (영문자, 숫자만 허용, 4~10자리) 1234567const id = 'abc123';// 알파벳 대소문자 또는 숫자로 시작하고 끝나며 4 ~10자리인지 검사// {4,10}: 4 ~ 10자리const regexr = /^[A-Za-z0-9]{4,10}$/;console.log(regexr.test(id)); // true 메일 주소 형식에 맞는지 검사한다. 12345const email = 'ungmo2@gmail.com';const regexr = /^[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\\.]?[0-9a-zA-Z])*\\.[a-zA-Z]{2,3}$/;console.log(regexr.test(email)); // true 핸드폰 번호 형식에 맞는지 검사한다. 12345const cellphone = '010-1234-5678';const regexr = /^\\d{3}-\\d{3,4}-\\d{4}$/;console.log(regexr.test(cellphone)); // true 특수 문자 포함 여부를 검사한다. 1234567891011121314const targetStr = 'abc#123';// A-Za-z0-9 이외의 문자가 있는지 검사let regexr = /[^A-Za-z0-9]/gi;console.log(regexr.test(targetStr)); // true// 아래 방식도 동작한다. 이 방식의 장점은 특수 문자를 선택적으로 검사할 수 있다.regexr = /[\\{\\}\\[\\]\\/?.,;:|\\)*~`!^\\-_+&lt;&gt;@\\#$%&amp;\\\\\\=\\(\\'\\\"]/gi;console.log(regexr.test(targetStr)); // true// 특수 문자 제거console.log(targetStr.replace(regexr, '')); // abc123 2. Javascript Regular Expression 2.1 RegExp Constructor 자바스크립트은 정규표현식을 위해 RegExp 객체를 지원한다. RegExp 객체를 생성하기 위해서는 리터럴 방식과 RegExp 생성자 함수를 사용할 수 있다. 일반적인 방법은 리터럴 방식이다. 1new RegExp(pattern[, flags]) pattern 정규표현식의 텍스트 flags 정규표현식의 플래그 (g, i, m, u, y) 12345678// 정규식 리터럴/ab+c/i;new RegExp('ab+c', 'i');new RegExp(/ab+c/, 'i');new RegExp(/ab+c/i); // ES6 정규표현식을 사용하는 메소드는 RegExp.prototype.exec, RegExp.prototype.test, String.prototype.match, String.prototype.replace, String.prototype.search, String.prototype.split 등이 있다. 2.2 RegExp Method 2.2.1 RegExp.prototype.exec(target: string): RegExpExecArray | null 문자열을 검색하여 매칭 결과를 반환한다. 반환값은 배열 또는 null이다. 12345const target = 'Is this all there is?';const regExp = /is/;const res = regExp.exec(target);console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ] exec 메소드는 g플래그를 지정하여도 첫번째 매칭 결과만을 반환한다. 12345const target = 'Is this all there is?';const regExp = /is/g;const res = regExp.exec(target);console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ] 2.2.2 RegExp.prototype.test(target: string):boolean 12345const target = 'Is this all there is?';const regExp = /is/;const res = regExp.exec(target);console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ] exec 메소드는 g플래그를 지정하여도 첫번쨰 매칭 결과만을 반환한다. 12345const target = 'Is this all there is?';const regExp = /is/g;const res = regExp.exec(target);console.log(res); // [ 'is', index: 5, input: 'Is this all there is?' ] 2.2.2 RegExp.prototype.test(target: string): boolean ES3 문자열을 검색하여 매칭 결과를 반환한다. 반환값은 true 또는 false이다. 12345const target = 'Is this all there is?';const regExp = /is/;const res = regExp.test(target);console.log(res); // true","link":"/2020/03/RegExp/"},{"title":"Number 레퍼 객체 | javaScript","text":"Number 객체는 원시 타입 number를 다룰 때 유용한 프로퍼티와 메소드를 제공하는 레퍼(wrapper) 객체이다. 변수 또는 객체의 프로퍼티가 숫자를 값으로 가지고 있다면 Number 객체의 별도 생성없이 Number 객체의 프로퍼티와 메소드를 사용할 수 있다. 원시 타입이 wrapper 객체의 메소드를 사용할 수 있는 이유는 원시 타입으로 프로퍼티나 메소드를 호출할 때 원시 타입과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 되기 때문이다. 1. Number Constructor Number 객체는 Number() 생성자 함수를 통해 생성할 수 있다. 1new Number(value); 만일 인자가 숫자로 변환될 수 없다면 NaN을 반환한다. 1234567var x = new Number(123);var y = new Number('123');var z = new Number('str');console.log(x); // 123console.log(y); // 123console.log(z); // NaN Number() 생성자 함수를 new 연산자를 붙이지 않아 생성자로 사용하지 않으면 Number 객체를 반환하지 않고 원시 타입 숫자를 반환한다. 이때 형 변환이 발생할 수 있다. 123var x = Number('123');console.log(typeof x, x); // number 123 일반적으로 숫자를 사용할 때는 원시 타입 숫자를 사용한다. 12345678var x = 123;var y = new Number(123);console.log(x == y); // trueconsole.log(x === y); // falseconsole.log(typeof x); // numberconsole.log(typeof y); // object 2. Number Property 정적(static)프로퍼티로 Number 객체를 생성할 필요없이 ``Number.propertyName` 의 형태로 사용한다. 2.1 Number.EPSILON(ES6) Number.EPSILON은 JavaScript에서 표현할 수 있는 가장 작은 수이다. 12345678910console.log(0.1 + 0.2); // 0.30000000000000004console.log(0.1 + 0.2 == 0.3); // false!!!function isEqual(a, b){ // Math.abs는 절댓값을 반환한다. // 즉 a와 b의 차이가 JavaScript에서 표현할 수 있는 가장 작은 수인 Number.EPSILON보다 작으면 같은 수로 인정할 수 있다. return Math.abs(a - b) &lt; Number.EPSILON;}console.log(isEqual(0.1 + 0.2, 0.3)); 2.2 Number.MAX_VALUE(ES1) 자바스크립트에서 사용 가능한 가장 큰 숫자(1.7976931348623157e+308)를 반환한다. MAX_VALUE보다 큰 숫자는 Infinity 이다. 123456Number.MAX_VALUE; // 1.7976931348623157e+308var num = 10;num.MAX_VALUE; // undefinedconsole.log(Infinity &gt; Number.MAX_VALUE); // true 2.3 Number.MIN_VALUE(ES1) 자바스크립트에서 사용 가능한 가장 작은 숫자(5e-324)를 반환한다. MIN_VALUE는 0에 가장 가까운 양수 값이다. MIN_VALUE보다 작은 숫자는 0으로 변환된다. 123456Number.MIN_VALUE; // 5e-324var num = 10;num.MIN_VALUE; // undefinedconsole.log(Number.MIN_VALUE &gt; 0); // true 2.4 Number.POSITIVE_INFINITY 양의 무한대 Infinity 를 반환한다. 1234Number.POSITIVE_INFINITY // Infinityvar num = 10;num.POSITIVE_INFINITY; // undefined 2.5 Number.NEGATIVE_INFINITY 양의 무한대 -Infinity 를 반환한다. 1234Number.NEGATIVE_INFINITY // -Infinityvar num = 10;num.NEGATIVE_INFINITY; // undefined 2.6 Number.NaN ES1 숫자가 아님(Not-a-Number)을 나타내는 숫자값이다. Number.NaN 프로퍼티는 window.NaN 프로퍼티와 같다. 123console.log(Number('xyz')); // NaNconsole.log(1 * 'string'); // NaNconsole.log(typeof NaN); // number 3. Number Method 3.1 Number.isFinite(testValue: number):boolean 매개변수에 전달된 값이 정상적인 유한수인지를 검사하여 그 결과를 Boolean으로 반환한다. 숫자가 아닌 인수가 주어졌을 때 반환값은 언제나 false가 된다. 12345678Number.isFinite(Infinity) // falseNumber.isFinite(NaN) // falseNumber.isFinite('Hello') // falseNumber.isFinite('2005/12/12') // falseNumber.isFinite(0) // trueNumber.isFinite(2e64) // trueNumber.isFinite(null) // false. isFinite(null) =&gt; true 3.2 Number.isInteger(testValue: number): boolean ES6 매개변수에 전달된 값이 정수(Integer)인지 검사하여 그 결과를 Boolean으로 반환한다. 12345678910Number.isInteger(123) //trueNumber.isInteger(-123) //trueNumber.isInteger(5-2) //trueNumber.isInteger(0) //trueNumber.isInteger(0.5) //falseNumber.isInteger('123') //falseNumber.isInteger(false) //falseNumber.isInteger(Infinity) //falseNumber.isInteger(-Infinity) //falseNumber.isInteger(0 / 0) //false 3.3 Number.isNaN(testValue: number):boolean 매개변수에 전달된 값이 NaN인지를 검사하여 그 결과를 Boolean으로 반환한다. Number.isNaN()는 전역 함수 isNaN()와 차이가 있다. 전역 함수 isNaN()는 인수를 숫자로 변환하여 검사를 수행하지만 Number.isNaN()는 인수를 변환하지 않는다. 따라서 숫자가 아닌 인수가 주어졌을 때 반환값은 언제나 false가 된다. 1234567891011121314Number.isNaN(NaN) // trueNumber.isNaN(undefined) // false. undefined → NaN. isNaN(undefined) → true.Number.isNaN({}) // false. {} → NaN. isNaN({}) → true.Number.isNaN('blabla') // false. 'blabla' → NaN. isNaN('blabla') → true.Number.isNaN(true) // falseNumber.isNaN(null) // falseNumber.isNaN(37) // falseNumber.isNaN('37'); // falseNumber.isNaN('37.37'); // falseNumber.isNaN(''); // falseNumber.isNaN(' '); // falseNumber.isNaN(new Date()) // falseNumber.isNaN(new Date().toString()) // false. String → NaN. isNaN(String) → true. 3.4. Number.isSafeinteger(testValue: number): boolean 매개변수에 전달된 값이 안전한(safe) 정수값인지 검사하여 그 결과를 Boolean으로 반환한다. 123456789101112Number.isSafeInteger(123) //trueNumber.isSafeInteger(-123) //trueNumber.isSafeInteger(5-2) //trueNumber.isSafeInteger(0) //trueNumber.isSafeInteger(1000000000000000) // trueNumber.isSafeInteger(10000000000000001) // falseNumber.isSafeInteger(0.5) //falseNumber.isSafeInteger('123') //falseNumber.isSafeInteger(false) //falseNumber.isSafeInteger(Infinity) //falseNumber.isSafeInteger(-Infinity) //falseNumber.isSafeInteger(0 / 0) //false 3.5 Number.prototype.toExpoenetial(fractionDigits?: number): string 대상을 지수 표기법으로 변환하여 문자열로 반환한다. 지수 표기법이란 매우 큰 숫자를 표기할 때 주로 사용하며 e(Exponent) 앞에 있는 숫자에 10의 n승이 곱하는 형식으로 수를 나타내는 방식이다. 12345678var numObj = 77.1234;console.log(numObj.toExponential()); // logs 7.71234e+1console.log(numObj.toExponential(4)); // logs 7.7123e+1console.log(numObj.toExponential(2)); // logs 7.71e+1console.log(77.1234.toExponential()); // logs 7.71234e+1console.log(77.toExponential()); // SyntaxError: Invalid or unexpected tokenconsole.log(77 .toExponential()); // logs 7.7e+1 3.6 Number.prototype.toFixed(fractionDigits?: number): string 매개변수로 지정된 소숫점자리를 반올림하여 문자열로 반환한다. 123456789101112var numObj = 12345.6789;// 소숫점 이하 반올림console.log(numObj.toFixed()); // '12346'// 소숫점 이하 1자리수 유효, 나머지 반올림console.log(numObj.toFixed(1)); // '12345.7'// 소숫점 이하 2자리수 유효, 나머지 반올림console.log(numObj.toFixed(2)); // '12345.68'// 소숫점 이하 3자리수 유효, 나머지 반올림console.log(numObj.toFixed(3)); // '12345.679'// 소숫점 이하 6자리수 유효, 나머지 반올림console.log(numObj.toFixed(6)); // '12345.678900' 3.7 Number.prototype.toPrecision(precision?: number): string 매개변수로 지정된 전체 자릿수까지 유효하도록 나머지 자릿수를 반올림하여 문자열로 반환한다. 지정된 전체 자릿수로 표현할 수 없는 경우 지수 표기법으로 결과를 반환한다. 123456789101112var numObj = 15345.6789;// 전체자리수 유효console.log(numObj.toPrecision()); // '12345.6789'// 전체 1자리수 유효, 나머지 반올림console.log(numObj.toPrecision(1)); // '2e+4'// 전체 2자리수 유효, 나머지 반올림console.log(numObj.toPrecision(2)); // '1.5e+4'// 전체 3자리수 유효, 나머지 반올림console.log(numObj.toPrecision(3)); // '1.53e+4'// 전체 6자리수 유효, 나머지 반올림console.log(numObj.toPrecision(6)); // '12345.7' 3.8 Number.prototype.toString(radix?: number): string 숫자를 문자열로 변환하여 반환한다. 1234567891011121314var count = 10;console.log(count.toString()); // '10'console.log((17).toString()); // '17'console.log(17 .toString()); // '17'console.log((17.2).toString()); // '17.2'var x = 16;console.log(x.toString(2)); // '10000'console.log(x.toString(8)); // '20'console.log(x.toString(16)); // '10'console.log((254).toString(16)); // 'fe'console.log((-10).toString(2)); // '-1010'console.log((-0xff).toString(2)); // '-11111111' 3.9. Number.prototype.valueOf(): number Number 객체의 원시 타입 값(primitive value)을 반환한다. 123456var numObj = new Number(10);console.log(typeof numObj); // objectvar num = numObj.valueOf();console.log(num); // 10console.log(typeof num); // number","link":"/2020/03/Number/"},{"title":"Ajax | javaScript","text":"Ajax 웹브라우저는 대단히 정적인 시스템이었다. 내용이 바뀌면 페이지 새로고침을 해서 내용을 새롭게 변경해야 했다. 이것은 웹이 전자 문서를 염두에 두고 고안된 시스템이기 때문에 당연하게 생각 되었다. 그러다 Ajax 개념이 도입되면서 모든 것이 바뀌었다. Ajax는 웹브라우저와 웹서버가 내부적으로 데이터 통신을 하게 된다. 그리고 변경된 결과를 웹페이지에 프로그래밍적으로 반영함으로써 웹페이지의 로딩 없이 서비스를 사용할 수 있게 한다. Ajax는 Asynchronous JavaScript and XML의 약자다. 한국어로는 비동기적 자바스크립트와 XML 정도로 직역할 수 있는데 자바스크립트를 이용해서 비동기적으로 서버와 브라우저가 데이터를 주고 받는 방식을 의미한다. 이 때 사용하는 API가 XMLHttpRequest이다. 그렇다고 꼭 XML을 사용해서 통신해야 하는 것은 아니다. 사실 XML 보다는 JSON을 더 많이 사용한다. IE5,6 에서는 XMLHttpRequest 객체 대신 ActiveXObject(&quot;Msxml2.XMLHTTP.6.0&quot;)을 사용해야 한다. 여기서는 다루지 않는다. XMLHttpRequest이 떄 사용하는 API가 XMLHttpRequest이다. 다음 예제를 보자 본 예제를 실행하기 위해서는 서버 환경이 구축 되어 있어야 한다.현재 시간 코드를 출력한다. 12345&lt;?php$d1 = new DateTime;$d1-&gt;setTimezone(new DateTimezone(\"asia/seoul\"));echo $d1-&gt;format('H:i:s');?&gt; 아래 코드는 time.php에 접속해서 현재 시간을 페이지에 표시한다. 123456789101112131415161718192021&lt;p&gt;time : &lt;span id=\"time\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;input type=\"button\" id=\"execute\" value=\"execute\" /&gt;&lt;script&gt;document.querySelector('input').addEventListener('click', function(e) { // 객체 생성 var xhr = new XMLHttpRequset(); // OPEN 메소드 먼저 써야함. xhr.open('GET', './time.php'); // 데이터 준비가 다 되었다면 fn 함수 호출 xhr.onreadystatechange = function() { // 데이터가 정상적이라면 if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) { // 응답 데이터를 innerHTML로 넣기 document.querySelector('#time').innerHTML = xhr.responseText; } } // 데이터 전송 xhr.send();})&lt;/script&gt; 코드 분석 해보기 1var xhr = new XMLHttpRequest(); XMLHttpRequest 객체를 생성한다. 1xhr.open('GET', './time.php') 접속하려는 대상을 지정한다. 첫번째 인자는 form 태그의 method에 대응하는 것으로 GET/POST 방식을 주로 사용한다. 두번째 인자는 접속하고자 하는 서버쪽 리소스의 주소로 form 태그의 action에 해당한다. 12345xhr.onreadystatechange = function() { if(xhr.readyState === 4 &amp;&amp; xhr.status === 200) { document.querySelector('#time').innerHTML = xhr.responseText; }} onreadystatechange 이벤트는 서버와의 통신이 끝났을 떄 호출되는 이벤트이다. readyState는 통신의 현재 상태를 알려준다. 4는 통신이 완료되었음을 의미한다. status는 HTTP 통신의 결과를 의미하는데 200은 통신이 성공했음을 의미한다. reponseText 프로퍼티는 서버에서 전송한 데이터를 담고 있다. 이것을 id가 time 엘리먼트의 하위로 삽입한다. 이를 통해서 현재 서버에서 가져온 현재시간을 페이지 리로딩 없이 가져올 수 있다. POST 방식 아래 예제는 시간대와 시간의 출력 형식을 지정하는 예제다. 123456789101112131415161718192021222324&lt;p&gt;time : &lt;span id=\"time\"&gt;&lt;/span&gt;&lt;/p&gt;&lt;select id=\"timezone\"&gt; &lt;option value=\"Asia/Seoul\"&gt;asia/seoul&lt;/option&gt; &lt;option value=\"America/New_York\"&gt;America/New_York&lt;/option&gt;&lt;/select&gt;&lt;select id=\"format\"&gt; &lt;option value=\"Y-m-d H:i:s\"&gt;Y-m-d H:i:s&lt;/option&gt; &lt;option value=\"Y-m-d\"&gt;Y-m-d&lt;/option&gt;&lt;/select&gt;&lt;input type=\"button\" id=\"execute\" value=\"execute\" /&gt;&lt;script&gt;document.querySelector('input').addEventListener('click', function(event){ var xhr = new XMLHttpRequest(); xhr.open('POST', './time2.php'); xhr.onreadystatechange = function(){ document.querySelector('#time').innerHTML = xhr.responseText; } xhr.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\"); var data = ''; data += 'timezone='+document.getElementById('timezone').value; data += '&amp;format='+document.getElementById('format').value; xhr.send(data); });&lt;/script&gt; 데이터 전송방법을 GET에서 POST로 변경했다. 1xhr.open('POST', './time2.php'); 서버로 전송할 데이터 타입의 형식(MIME)을 지정한다. 1xhr.setRequestHeader(\"content-type\", \"application/x-www-form-urlencoded\"); 서버로 전송할 데이터를 형식에 맞게 만든다. 이름=값&amp;이름=값…의 형식을 지켜야 한다. 123var data = '';data += 'timezone=' + document.getElementById('timezone').value;date += '&amp;format=' + document.getElementById('format').value; send 메소드의 인자로 전송할 데이터를 전달한다. 1xhr.send(data); 아래는 Ajax를 이용해서 전송한 데이터를 받아서 현재 시간을 출력해주는 서버쪽 구현이다. 12345&lt;?php$d1 = new DateTime;$d1-&gt;setTimezone(new DateTimezone($_POST['timezone']));echo $d1-&gt;format($_POST['format']);?&gt;","link":"/2020/04/ajax/"},{"title":"Canvas를 활용한 컴퓨터 그래픽스 | javaScript","text":"Canvas란? Canvas는 웹 브라우저에서 그래픽을 처리하기 위해 추가된 HTML5의 구성요소이다. 애플(Apple)사가 MacOs와 사파리 웹 브라우저에서 사용자 인터페이스를 만들기 위해 위젯이나 이미지를 렌더링할 목적으로 개발한 것이다. Canvas는 주요 웹브라우저에서 사용할 수 있으며 IE9이상에서 지원이된다. Canvas로는 2차원 그래픽과 WebGL을 사용한 3차원 그래픽을 구현할 수 있다. Canvas의 특징 canvas는 즉시 실행형 저수준 API이다. Canvas의 기본적인 사용법 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Canvas의 기본&lt;/title&gt; &lt;script&gt; window.onload = function() { // canvas 요소 가져오기 var canvas = document.getElementById(\"mycanvas\"); // canvas 랜더링 컨텍스트 가져오기 var ctx = canvas.getContext(\"2d\"); // 좌표(10,10)에 가로 200, 높이 50인 사각형 테두리를 그린다 ctx.strokeRect(10,10,200,150); // 좌표(50,40)에 가로 120, 높이 90인 사각형을 채운다 ctx.fillRect(50,40,120,90); // 좌표(90,65)에 가로 40, 높이 40인 사각형 영역을 삭제한다 ctx.clearRect(90,65,40,40); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id=\"mycanvas\" width=\"640\" height=\"400\"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;/html&gt; 1 canvas 요소를 배치한다.body요소에서 canvas를 표시하고자 하는 위치에 canvas 요소를 배치한다. 1&lt;canvas id=\"mycanvas\" width=\"640\" height=\"400\"&gt;&lt;/canvas&gt; 입력 기본 단위는 px입니다. Canvas요소 객체의 가로 세로를 직접 입력할 수 있다. CSS로도 크기를 설정할 수 있지만 브라우저마다 왜곡/확대/축소될 수 있으므로 HTML 또는 DOM으로 설정하는 것이 나음. 2 canvas 요소의 객체 가져오기1var canvas = document.getElementById(\"mycanvas\"); 3 렌더링 컨텍스트 가져오기Canvas로 그림을 그리려면 canvas 요소객체에서 ‘렌더링 컨텍스트’라는 객체를 가져와야 함.렌더링 컨텍스트를 가져올 떄는 canvas 요소 객체의 getContext 메서드를 사용해야합니다. 1var ctx = canvas.getContext(\"2d\"); getContext의 메소드는 두 가지이다. 하나는 2차원 그래픽인 “2d” 하나는 WebGL을 사용한 3차원인 “webgl”을 사용한다. 4 그림 그리기렌더링 컨텍스트를 가져왔다면 렌더링 컨텍스트의 메서드를 사용해서 Canvas 위에 그림을 그린다. 1ctx.strokeRext(50, 60, 200, 100); Canvas 좌표계Canvas 좌표계는 기본적으로 왼쪽 윗부분이 원점인 (0, 0)이다. 캔버스 오른쪽이 x축의 정방향이며 캔버스 아래쪽이 y축 정방향이다.좌표축의 길이를 세는 단위는 기본적으로 PX이다. 기본 좌표계는 나중에 수정이 가능함. 사각형 그리기12345678// 사각형 테두리 그리기ctx.stokeRect(x, y, width, height);// 사각형 채우기ctx.fillRext(x, y, width, hegiht);// 사각형 영역을 지우고 투명하게 만들기ctx.clearRext(x, y, width, height); 패스로 그리기패스를 정의하면 곡선을 그릴 수도 있고 내부를 채울 수도 있습니다. 123456789101112ctx.beginPath();ctx.moveTo(60, 10);ctx.lineTo(110, 100);ctx.lineTo(10, 100);ctx.closePath();ctx.stroke();// 삼각형 채우기ctx.beginPath();ctx.moveTo(60, 120);ctx.lineTo(110, 210);ctx.lineTo(10, 210);ctx.fill(); 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Canvas의 기본&lt;/title&gt; &lt;script&gt; window.onload = function() { // canvas 요소 가져오기 var canvas = document.getElementById(\"mycanvas\"); // canvas 랜더링 컨텍스트 가져오기 var ctx = canvas.getContext(\"2d\"); // 그리기 ctx.beginPath(); ctx.moveTo(100,50); ctx.lineTo(100,150); ctx.moveTo(50,100); ctx.lineTo(150,100); ctx.stroke(); } &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;canvas id=\"mycanvas\" width=\"640\" height=\"400\"&gt;&lt;/canvas&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/04/canvas/"},{"title":"타입 변환과 단축 평가 | javaScript","text":"1. 타입 변환이란?자바스크립트의 모든 값은 타입이 있다. 값의 타입은 개발자의 의도에 의해 다른 타입으로 변환할 수 있다. 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(Explicit coercion) 또는 타입 캐스팅(Type casting)이라 한다. 123456789var x = 10;// 명시적 타입 변환// 숫자를 문자열로 타입 캐스팅한다.var str = x.toString();console.log(typeof str, str); // string 10// 변수 x의 값이 변경된 것은 아니다.console.log(typeof x, x); // number 10 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다. 123456789var x = 10;// 암묵적 타입 변환// 문자열 연결 연산자는 숫자 타입 x의 값을 바탕으로 새로운 문자열을 생성한다.var str = x + '';console.log(typeof str, str); // string 10// 변수 x의 값이 변경된 것은 아니다.console.log(typeof x, x); // number 10 명시적 타입 변환이나 암묵적 타입 변환이 기존 원시값(위 예제의 경우, 변수 x의 값)을 직접 변경하는 것은 아니다. 원시값은 변경 불가능한 값(imuutable value)이므로 변경할 수 없다. 타입 변환이란 기존 원시값을 사용해 다른 타입의 새로운 원시값을 생성하는 것이다. 123// 원시값 1이 '1'로 직접 변경되는 것이 아니다.// 1을 사용해 타입이 다른 '1'을 새롭게 생성하여 '1' + ''을 평가한다.1 + '' // '1' 암묵적 타입 변환은 변수의 값을 재할당해서 변경하는 것이 아니라 자바스크립트 엔진이 표현식을 에러없이 평가하기 위해 피연산자의 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다. 위 예제의 경우, 자바스크립트 엔진은 표현식 x + ‘’을 평가하기 위해 변수 x의 숫자 값을 바탕으로 새로운 문자열 값 ‘10’을 생성하고 이것으로 표현식 ‘10’ + ‘’를 평가한다. 이때 자동 생성된 문자열 ‘10’은 변수 x에 할당되는 것이 아니다. 따라서 자동 생성된 문자열 ‘10’은 표현식의 평가가 끝나면 아무도 참조하지 않으므로 가비지 컬렉터에 의해 메모리에서 해제된다. 명시적 타입 변환은 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 드러난다. 하지만 암묵적 타입 강제 변환은 자바스크립트 엔진에 의해 암묵적으로, 즉 드러나지 않게 타입이 자동 변환되기 때문에 타입을 변경하겠다는 개발자의 의지가 코드에 명백히 나타나지 않는다. 따라서 자신이 작성한 코드에서 암묵적 타입 변환이 발생하는지, 발생한다면 어떤 타입의 어떤 값으로 변환되는지, 그리고 타입 변환된 값으로 표현식은 어떻게 평가될 것인지 예측 가능해야 한다. 만약 타입 변환 결과를 예측하지 못하거나 예측이 결과와 일치하지 않는다면 오류를 생산할 가능성이 높아진다. 그렇다면 명시적 타입 변환 만을 사용하고 암묵적 타입 변환은 발생하지 않도록 코드를 작성하면 어떨까? 좋은 생각이긴 하지만 이러한 논리는 옳지 않다. 때로는 명시적 타입 변환보다 암묵적 타입 변환이 가독성 측면에서 더 좋을 수도 있다. 예를 들어 자바스크립트 문법을 잘 이해하고 있는 개발자에게는 (10).toString()보다 10 + ‘’이 더욱 간결하고 이해하기 쉽다. 중요한 것은 코드를 예측할 수 있어야 한다는 것이다. 동료가 작성한 코드를 정확히 이해할 수 있어야 하고 자신의 코드는 타인에 의해 쉽게 이해될 수 있어야 한다. 이를 위해 타입 변환이 어떻게 동작하는지 정확히 이해하고 사용하도록 하자. 2. 암묵적 타입 변환자바스크립트 엔진은 표현식을 평가할 때 개발자의 의도와는 상관없이 코드의 문맥을 고려하여 암묵적으로 데이터 타입을 강제 변환(암묵적 타입 변환)할 때가 있다. 아래 예제를 살펴보자. 123456789// 피연산자가 모두 문자열 타입이여야 하는 문맥'10' + 2 // '102'// 피연산자가 모두 숫자 타입이여야 하는 문맥5 * '10' // 50// 피연산자 또는 표현식이 불리언 타입이여야 하는 문맥!0 // trueif (1) { } 이처럼 표현식을 평가할 때 코드의 문맥에 부합하지 않는 다양한 상황이 발생할 수 있다. 이때 자바스크립트는 가급적 에러를 발생시키지 않도록 암묵적 타입 변환을 통해 표현식을 평가한다. 암묵적 타입 변환이 발생하면 문자열, 숫자, 불리언과 같은 원시 타입 중 하나로 타입을 자동 변환한다. 타입 별로 암묵적 타입 변환이 어떻게 발생하는지 살펴보자. 2.1. 문자열 타입으로 변환아래의 예제를 살펴보자. 11 + '2' // \"12\" 위 예제의 + 연산자는 피연산자 중 하나 이상이 문자열이므로 문자열 연결 연산자로 동작한다. 문자열 연결 연산자의 역할은 문자열 값을 만드는 것이다. 따라서 문자열 연결 연산자의 모든 피연산자는 코드의 문맥 상 모두 문자열 타입이여야 한다. 자바스크립트 엔진은 문자열 연결 연산자 표현식을 평가하기 위해 문자열 연결 연산자의 피연산자 중에서 문자열 타입이 아닌 피연산자를 문자열 타입으로 암묵적 타입 변환한다. 연산자 식의 피연산자(피연산자도 표현식이다) 만이 암묵적 타입 변환의 대상이 되는 것은 아니다. 앞서 언급했듯이 자바스크립트 엔진은 표현식을 평가할 때 코드 문맥에 부합하도록 암묵적 타입 변환을 실행한다. 예를 들어 ES6에서 도입된 템플릿 리터럴의 표현식 삽입(“6.3.2. 표현식 삽입” 참고)은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환한다. 1console.log(`1 + 1 = ${1 + 1}`); // \"1 + 1 = 2\" 자바스크립트 엔진은 문자열 타입 아닌 값을 문자열 타입으로 암묵적 타입 변환을 수행할 때 아래와 같이 동작한다. 1234567891011121314151617181920212223242526272829// 숫자 타입0 + '' // \"0\"-0 + '' // \"0\"1 + '' // \"1\"-1 + '' // \"-1\"NaN + '' // \"NaN\"Infinity + '' // \"Infinity\"-Infinity + '' // \"-Infinity\"// 불리언 타입true + '' // \"true\"false + '' // \"false\"// null 타입null + '' // \"null\"// undefined 타입undefined + '' // \"undefined\"// 심볼 타입(Symbol()) + '' // TypeError: Cannot convert a Symbol value to a string// 객체 타입({}) + '' // \"[object Object]\"Math + '' // \"[object Math]\"[] + '' // \"\"[10, 20] + '' // \"10,20\"(function(){}) + '' // \"function(){}\"Array + '' // \"function Array() { [native code] }\" 2.2. 숫자 타입으로 변환아래의 예제를 살펴보자. 1231 - '1' // 01 * '10' // 101 / 'one' // NaN 위 예제에서 사용한 연산자는 모두 산술 연산자이다. 산술 연산자의 역할은 숫자 값을 만드는 것이다. 따라서 산술 연산자의 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다. 자바스크립트 엔진은 산술 연산자 표현식을 평가하기 위해 산술 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다. 이때 피연산자를 숫자 타입으로 변환할 수 없는 경우는 산술 연산을 수행할 수 없으므로 표현식의 평가 결과는 NaN이 된다.피연산자를 숫자 타입으로 변환해야 할 문맥은 산술 연산자 뿐만이 아니다. 아래 예제를 살펴보자. 1'1' &gt; 0 // true 비교 연산자의 역할은 불리언 값을 만드는 것이다. &gt; 비교 연산자는 피연산자의 크기를 비교하므로 모든 피연산자는 코드의 문맥 상 모두 숫자 타입이여야 한다. 자바스크립트 엔진은 비교 연산자 표현식을 평가하기 위해 비교 연산자의 피연산자 중에서 숫자 타입이 아닌 피연산자를 숫자 타입으로 암묵적 타입 변환한다.자바스크립트 엔진은 숫자 타입 아닌 값을 숫자 타입으로 암묵적 타입 변환을 수행할 때 아래와 같이 동작한다. + 단항 연산자는 피연산자가 숫자 타입의 값이 아니면 숫자 타입의 값으로 암묵적 타입 변환을 수행한다. 12345678910111213141516171819202122232425// 문자열 타입+'' // 0+'0' // 0+'1' // 1+'string' // NaN// 불리언 타입+true // 1+false // 0// null 타입+null // 0// undefined 타입+undefined // NaN// 심볼 타입+Symbol() // TypeError: Cannot convert a Symbol value to a number// 객체 타입+{} // NaN+[] // 0+[10, 20] // NaN+(function(){}) // NaN빈 문자열(‘’), 빈 배열([]), null, false는 0으로, true는 1로 변환된다. 객체와 빈 배열이 아닌 배열, undefined는 변환되지 않아 NaN이 된다는 것에 주의하자. 2.3. 불리언 타입으로 변환아래의 예제를 살펴보자. 12345678910if ('') console.log(x);if 문이나 for 문과 같은 제어문 또는 삼항 조건 연산자의 조건식(conditional expression)은 불리언 값, 즉 논리적 참, 거짓을 반환해야 하는 표현식이다. 자바스크립트 엔진은 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환한다.if ('') console.log('1');if (true) console.log('2');if (0) console.log('3');if ('str') console.log('4');if (null) console.log('5');// 2 4 이때 자바스크립트 엔진은 불리언 타입이 아닌 값을 Truthy 값(참으로 평가되는 값) 또는 Falsy 값(거짓으로 평가되는 값)으로 구분한다. 즉, 제어문의 조건식과 같이 불리언 값으로 평가되어야 할 문맥에서 Truthy 값은 true로, Falsy 값은 false로 암묵적 타입 변환된다. 아래 값들은 false로 평가되는 Falsy 값이다. 12345678910111213falseundefinednull0, -0NaN’’ (빈문자열)// 아래의 조건문은 모두 코드 블록을 실행한다.if (!false) console.log(false + ' is falsy value');if (!undefined) console.log(undefined + ' is falsy value');if (!null) console.log(null + ' is falsy value');if (!0) console.log(0 + ' is falsy value');if (!NaN) console.log(NaN + ' is falsy value');if (!'') console.log('' + ' is falsy value'); Falsy 값 이외의 모든 값은 모두 true로 평가되는 Truthy 값이다. 아래 예제는 Truthy/Falsy 값을 판별하는 함수다. 함수함수란 어떤 작업을 수행하기 위해 필요한 문들의 집합을 정의한 코드 블록이다. 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문들을 일괄적으로 실행할 수 있다. 함수에 대해서는 나중에 자세히 살펴볼 것이다. 123456789101112131415161718192021222324// 주어진 인자가 Falsy 값이면 true, Truthy 값이면 false를 반환한다.function isFalsy(v) { return !v;}// 주어진 인자가 Truthy 값이면 true, Falsy 값이면 false를 반환한다.function isTruthy(v) { return !!v;}// 모두 true를 반환한다.console.log(isFalsy(false));console.log(isFalsy(undefined));console.log(isFalsy(null));console.log(isFalsy(0));console.log(isFalsy(NaN));console.log(isFalsy(''));// 모두 true를 반환한다.console.log(isTruthy(true));// 빈 문자열이 아닌 문자열은 Truthy 값이다.console.log(isTruthy('0'));console.log(isTruthy({}));console.log(isTruthy([])); 3. 명시적 타입 변환개발자의 의도에 의해 명시적으로 타입을 변경하는 방법은 다양하다. 표준 빌트인 생성자 함수(String, Number, Boolean)를 new 연산자 없이 호출하는 방법과 자바스크립트에서 제공하는 빌트인 메소드를 사용하는 방법, 그리고 앞에서 살펴본 암묵적 타입 변환을 이용하는 방법이 있다. 3.1. 문자열 타입으로 변환문자열 타입이 아닌 값을 문자열 타입으로 변환하는 방법은 아래와 같다. String 생성자 함수를 new 연산자 없이 호출하는 방법Object.prototype.toString 메소드를 사용하는 방법문자열 연결 연산자를 이용하는 방법 1234567891011121314151617181920212223242526// 1. String 생성자 함수를 new 연산자 없이 호출하는 방법// 숫자 타입 =&gt; 문자열 타입console.log(String(1)); // \"1\"console.log(String(NaN)); // \"NaN\"console.log(String(Infinity)); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log(String(true)); // \"true\"console.log(String(false)); // \"false\"// 2. Object.prototype.toString 메소드를 사용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log((1).toString()); // \"1\"console.log((NaN).toString()); // \"NaN\"console.log((Infinity).toString()); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log((true).toString()); // \"true\"console.log((false).toString()); // \"false\"// 3. 문자열 연결 연산자를 이용하는 방법// 숫자 타입 =&gt; 문자열 타입console.log(1 + ''); // \"1\"console.log(NaN + ''); // \"NaN\"console.log(Infinity + ''); // \"Infinity\"// 불리언 타입 =&gt; 문자열 타입console.log(true + ''); // \"true\"console.log(false + ''); // \"false\" 3.2. 숫자 타입으로 변환숫자 타입이 아닌 값을 숫자 타입으로 변환하는 방법은 아래와 같다. Number 생성자 함수를 new 연산자 없이 호출하는 방법parseInt, parseFloat 함수를 사용하는 방법(문자열만 숫자 타입으로 변환 가능) 단항 산술 연산자를 이용하는 방법 산술 연산자를 이용하는 방법1234567891011121314151617181920212223242526272829303132// 1. Number 생성자 함수를 new 연산자 없이 호출하는 방법// 문자열 타입 =&gt; 숫자 타입console.log(Number('0')); // 0console.log(Number('-1')); // -1console.log(Number('10.53')); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(Number(true)); // 1console.log(Number(false)); // 0// 2. parseInt, parseFloat 함수를 사용하는 방법(문자열만 변환 가능)// 문자열 타입 =&gt; 숫자 타입console.log(parseInt('0')); // 0console.log(parseInt('-1')); // -1console.log(parseFloat('10.53')); // 10.53// 3. + 단항 산술 연산자를 이용하는 방법// 문자열 타입 =&gt; 숫자 타입console.log(+'0'); // 0console.log(+'-1'); // -1console.log(+'10.53'); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(+true); // 1console.log(+false); // 0// 4. * 산술 연산자를 이용하는 방법// 문자열 타입 =&gt; 숫자 타입console.log('0' * 1); // 0console.log('-1' * 1); // -1console.log('10.53' * 1); // 10.53// 불리언 타입 =&gt; 숫자 타입console.log(true * 1); // 1console.log(false * 1); // 0 3.3. 불리언 타입으로 변환불리언 타입이 아닌 값을 불리언 타입으로 변환하는 방법은 아래와 같다. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법! 부정 논리 연산자를 두번 사용하는 방법 1234567891011121314151617181920212223242526272829303132333435// 1. Boolean 생성자 함수를 new 연산자 없이 호출하는 방법// 문자열 타입 =&gt; 불리언 타입console.log(Boolean('x')); // trueconsole.log(Boolean('')); // falseconsole.log(Boolean('false')); // true// 숫자 타입 =&gt; 불리언 타입console.log(Boolean(0)); // falseconsole.log(Boolean(1)); // trueconsole.log(Boolean(NaN)); // falseconsole.log(Boolean(Infinity)); // true// null 타입 =&gt; 불리언 타입console.log(Boolean(null)); // false// undefined 타입 =&gt; 불리언 타 입console.log(Boolean(undefined)); // false// 객체 타입 =&gt; 불리언 타입console.log(Boolean({})); // trueconsole.log(Boolean([])); // true// 2. ! 부정 논리 연산자를 두번 사용하는 방법// 문자열 타입 =&gt; 불리언 타입console.log(!!'x'); // trueconsole.log(!!''); // falseconsole.log(!!'false'); // true// 숫자 타입 =&gt; 불리언 타입console.log(!!0); // falseconsole.log(!!1); // trueconsole.log(!!NaN); // falseconsole.log(!!Infinity); // true// null 타입 =&gt; 불리언 타입console.log(!!null); // false// undefined 타입 =&gt; 불리언 타입console.log(!!undefined); // false// 객체 타입 =&gt; 불리언 타입console.log(!!{}); // trueconsole.log(!![]); // true 4. 단축 평가“7.5. 논리 연산자”에서 설명하지 않고 뒤로 나중으로 미룬 내용이 있다. 그것은 “논리합(||) 연산자와 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합(||), 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어느 한쪽으로 평가된다.”라는 것이다. 암묵적 타입 변환에 대해 살펴보았으므로 뒤로 미뤘던 위 내용을 이제 설명할 수 있다. 아래 예제를 살펴보자. 1'Cat' &amp;&amp; 'Dog' // 'Dog' 논리곱(&amp;&amp;) 연산자는 두개의 피연산자가 모두 true로 평가될 때 true를 반환한다. 대부분의 연산자가 그렇듯이 논리곱 연산자도 왼쪽에서 오른쪽으로 평가가 진행된다. 첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 하지만 이 시점까지는 위 표현식을 평가할 수 없다. 두번째 피연산자까지 평가해 보아야 위 표현식을 평가할 수 있다. 다시 말해 두번째 피연산자가 위 논리곱 연산자 표현식의 평가 결과를 결정한다. 이때 논리곱 연산자는 논리 연산의 결과를 결정한 두번째 피연산자 즉, 문자열 ‘Dog’를 그대로 반환한다. 논리합(||) 연산자도 논리곱(&amp;&amp;) 연산자와 동일하게 동작한다. 1'Cat' || 'Dog' // 'Cat' 논리합(||) 연산자는 두개의 피연산자 중 하나만 true로 평가되어도 true를 반환한다. 대부분의 연산자가 그렇듯이 논리합 연산자도 왼쪽에서 오른쪽으로 평가가 진행된다. 첫번째 피연산자 ‘Cat’은 Truthy 값이므로 true로 평가된다. 이 시점에 두번째 피연산자까지 평가해 보지 않아도 위 표현식을 평가할 수 있다. 이때 논리합 연산자는 논리 연산의 결과를 결정한 첫번째 피연산자 즉, 문자열 ‘Cat’를 그대로 반환한다. 논리곱(&amp;&amp;) 연산자와 논리합(||) 연산자는 이와 같이 논리 연산의 결과를 결정한 피연산자를 타입 변환하지 않고 그대로 반환한다. 이를 단축 평가(short-circuit evaluation)라 부른다. 단축 평가는 표현식을 평가하는 도중에 평가 결과가 확정된 경우, 나머지 평가 과정을 중단하는 것이다. 대부분의 프로그래밍 언어는 단축 평가를 통해 논리 연산을 수행한다. 단축 평가는 아래의 규칙을 따른다. 단축 평가 표현식 평가 결과 12345678910111213true || anything truefalse || anything anythingtrue &amp;&amp; anything anythingfalse &amp;&amp; anything false// 논리합(||) 연산자'Cat' || 'Dog' // 'Cat'false || 'Dog' // 'Dog''Cat' || false // 'Cat'// 논리곱(&amp;&amp;) 연산자'Cat' &amp;&amp; 'Dog' // Dogfalse &amp;&amp; 'Dog' // false'Cat' &amp;&amp; false // false 단축 평가를 사용하면 if문을 대체할 수 있다. 주어진 조건이 Truthy 값(참으로 평가되는 값)일 때 무언가를 해야 한다면 논리곱(&amp;&amp;) 연산자 표현식으로 if문을 대체할 수 있다. 123456789var done = true;var message = '';// 주어진 조건이 true일 때if (done) message = '완료';// if문은 단축 평가로 대체 가능하다.message = done &amp;&amp; '완료';console.log(message); // 완료 주어진 조건이 Falsy 값(거짓으로 평가되는 값)일 때 무언가를 해야 한다면 논리합(||) 연산자 표현식으로 if문을 대체할 수 있다. 123456789var done = false;var message = '';// 주어진 조건이 false일 때if (!done) message = '미완료';// if문은 단축 평가로 대체 가능하다.message = done || '미완료';console.log(message); // 미완료 참고로 삼항 조건 연산자는 if…else문을 대체할 수 있다. 1234567891011var done = true;var message = '';// if...else문if (done) message = '완료';else message = '미완료';console.log(message); // 완료// if..else문은 삼항 조건 연산자로 대체 가능하다.message = done ? '완료' : '미완료';console.log(message); // 완료 단축 평가는 아래와 같은 상황에서 유용하게 사용된다. 아직 살펴보지 않은 객체와 함수에 대한 내용이 나와서 혼란스러울 수 있겠다. 지금은 아래와 같은 단축 평가의 유용한 패턴이 있다는 정도로 이해하고 넘어가도 좋다. 객체와 함수에 대해서는 나중에 자세히 살펴볼 것이다. 객체를 가리키는 변수가 null(또는 undefined)인지 확인하고 프로퍼티를 참조할 때 12345var elem = null;var value = elem.value; // TypeError: Cannot read property 'value' of nullvar value = elem &amp;&amp; elem.value; // null객체는 키(key)과 값(value)으로 구성된 프로퍼티(Property)들의 집합이다. 만약 객체를 가리키는 변수가 null인 경우, 객체의 프로퍼티를 참조하면 타입 에러(TypeError)가 발생한다. 이때 단축 평가를 사용하면 에러를 발생시키지 않는다. ES11(ECMAScript2020)에 도입될 것으로 알려진 옵셔널 체이닝(optional chaining, 2020년 2월 현재, stage 4) 문법을 사용하면 논리곱(&amp;&amp;) 연산자 표현식을 대체할 수 있다. 123456const elem = null;// elem이 null 또는 undefined인 경우, 옵셔널 체이닝 문법은 undefined를 반환한다.const value = elem?.value; // undefined// 옵셔널 체이닝 문법은 아래와 같이 동작한다.// const value = (elem === null || elem === undefined) ? undefined : elem.value; 함수 매개변수에 기본값을 설정할 때 12345678910111213141516// 단축 평가를 사용한 매개변수의 기본값 설정function getStringLength(str) { str = str || ''; return str.length;}getStringLength(); // 0getStringLength('hi'); // 2// ES6의 매개변수의 기본값 설정function getStringLength(str = '') { return str.length;}getStringLength(); // 0getStringLength('hi'); // 2 함수를 호출할 때 인수를 전달하지 않으면 매개변수는 undefined를 갖는다. 이때 단축 평가를 사용하여 매개변수의 기본값을 설정하면 undefined로 인해 발생할 수 있는 에러를 방지할 수 있다.","link":"/2020/02/coercion/"},{"title":"제어문 | javaScript","text":"제어문(Control flow statement)은 주어진 조건에 따라 코드 블록을 실행(조건문)하거나 반복 실행(반복문)할 때 사용한다. 일반적으로 코드는 위에서 아래 방향으로 순차적으로 실행된다. 제어문을 사용하면 코드의 실행 흐름을 인위적으로 제어할 수 있다. 하지만 코드의 실행 순서가 변경된다는 것은 단순하게 위에서 아래로 순차적으로 진행하는 직관적인 코드의 흐름을 혼란스럽게 만든다. 따라서 제어문은 코드의 흐름을 이해하기 어렵게 만들어 가독성을 해치는 단점이 있다. 가독성이 좋지 않은 코드는 오류를 발생시키는 원인이 된다. 나중에 살펴볼 forEach, map, filter, reduce와 같은 고차 함수를 사용한 함수형 프로그래밍 기법에서는 제어문의 사용을 억제하여 복잡성을 해결하려고 노력한다. 2보 전진을 위해서는 먼저 첫발을 내디뎌야 한다. 제어문을 바르게 이해하는 것은 코딩 스킬에 많은 영향을 준다. 특히 for 문은 매우 중요하므로 확실히 이해하도록 하자. 1.블록문블록문(Block statement/Compound statement)는 0개 이상의 문을 중괄호로 묶은 것으로 코드 블록 또는 블록이라고 부르기도 한다. 자바스크립트는 블록문을 하나의 실행 단위로 취급한다. 블록문은 단독으로 사용할 수도 있으나 일반적으로 제어문이나 함수를 정의할 때 사용하는 것이 일반적이다. 아래는 블록문이 사용되는 다양한 예제이다. 문의 끝에는 세미 콜론(;)을 붙이는 것이 일반적이지만 블록문의 끝에는 세미콜론을 붙이지 않는다는 것에 주의하기 바란다. 123456789101112131415161718// 블록문{ var foo = 10; console.log(foo);}// 제어문var x = 0;while (x &lt; 10) { x++;}console.log(x); // 10// 함수 선언문function sum(a, b) { return a + b;}console.log(sum(1, 2)); // 3 2.조건문조건문(conditional statement)은 주어진 조건식(conditional expression)의 평가 결과에 따라 코드 블럭(블록문)의 실행을 결정한다. 조건식은 불리언 값으로 평가될 수 있는 표현식이다. 자바스크립트는 2가지의 조건문 if…else 문과 switch 문을 제공한다. 2.1. if…else 문if…else 문은 주어진 조건식(불리언 값으로 평가될 수 있는 표현식)의 평가 결과, 즉 논리적 참 또는 거짓에 따라 실행할 코드 블록을 결정한다. 조건식의 평가 결과가 참(true)일 경우, if 문 다음의 코드 블록이 실행되고 거짓(false)일 경우, else 문 다음의 코드 블록이 실행된다. 12345if (조건식) { // 조건식이 참이면 이 코드 블록이 실행된다.} else { // 조건식이 거짓이면 이 코드 블록이 실행된다.} if 문의 조건식은 불리언 값으로 평가되어야 한다. 만약 if 문의 조건식이 불리언 값이 아닌 값으로 평가되면 자바스크립트 엔진에 의해 암묵적으로 데이터 타입이 불리언 값으로 강제 변환되어 실행할 코드 블록을 결정한다. 이에 대해서는 “8.2. 암묵적 타입 변환”에서 살펴볼 것이다. 조건식을 추가하여 조건에 따라 실행될 코드 블록을 늘리고 싶으면 else if 문을 사용한다. 1234567if (조건식1) { // 조건식1이 참이면 이 코드 블록이 실행된다.} else if (조건식2) { // 조건식2이 참이면 이 코드 블록이 실행된다.} else { // 조건식1과 조건식2가 모두 거짓이면 이 코드 블록이 실행된다.} else if 문과 else 문은 옵션이다. 즉, 사용할 수도 있고 사용하지 않을 수도 있다. if 문과 else 문은 2번 이상 사용할 수 없지만 else if 문은 여러 번 사용할 수 있다. 1234567891011121314151617181920212223242526var num = 2;var kind;// if 문if (num &gt; 0) { kind = '양수'; // 음수를 구별할 수 없다}console.log(kind); // 양수// if…else 문if (num &gt; 0) { kind = '양수';} else { kind = '음수'; // 0은 음수가 아니다.}console.log(kind); // 양수// if…else if 문if (num &gt; 0) { kind = '양수';} else if (num &lt; 0) { kind = '음수';} else { kind = '영';}console.log(kind); // 양수 만약 코드 블록 내의 문이 하나뿐이라면 중괄호를 생략할 수 있다. 12345678var num = 2;var kind;if (num &gt; 0) kind = '양수';else if (num &lt; 0) kind = '음수';else kind = '영';console.log(kind); // 양수 대부분의 if…else 문은 삼항 조건 연산자(“7.4. 삼항 조건 연산자” 참고)로 바꿔 쓸 수 있다. 아래 예제를 살펴보자. 1234567891011// x가 짝수이면 문자열 '짝수'를 반환하고 홀수이면 문자열 '홀수'를 반환한다.var x = 2;var result;if (x % 2) { // 2 % 2는 0이다. 이때 0은 false로 암묵적 강제 변환된다. result = '홀수';} else { result = '짝수';}console.log(result); // 짝수 위 예제는 아래와 같이 삼항 조건 연산자로 바꿔 쓸 수 있다. 1234567// x가 짝수이면 문자열 '짝수'를 반환하고 홀수이면 문자열 '홀수'를 반환한다.var x = 2;// 0은 false로 취급된다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 위 예제는 두가지 경우의 수(‘홀수’ 또는 ‘짝수’)를 갖는 경우이다. 만약 세가지 경우의 수(양수, 음수, 영)를 갖는 경우는 아래와 같이 바꿔 쓸 수 있다. 123456var num = 2;// 0은 false로 취급된다.var kind = num ? (num &gt; 0 ? '양수' : '음수') : '영';console.log(kind); // 양수 num &gt; 0 ? ‘양수’ : ‘음수’는 표현식이다. 즉, 삼항 연산자는 값으로 평가되는 표현식을 만든다. 하지만 if…else 문은 표현식이 아닌 문이다. 따라서 삼항 조건 연산자 표현식은 값처럼 사용할 수 있기 때문에 변수에 할당할 수 있다. 하지만 if…else 문은 값처럼 사용할 수 없기 때문에 변수에 할당할 수 없다는 차이가 있다. 2.2. switch 문switch 문은 주어진 표현식을 평가하여 그 값과 일치하는 표현식을 갖는 case 문으로 실행 순서를 이동시킨다. case 문은 상황(case)을 의미하는 표현식을 지정하고 콜론으로 마친다. 그리고 그 뒤에 실행할 문들을 위치시킨다. switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없다면 실행 순서는 default 문으로 이동한다. default 옵션으로 사용할 수도 있고 사용하지 않을 수도 있다. 12345678910switch (표현식) { case 표현식1: switch 문의 표현식과 표현식1이 일치하면 실행될 문; break; case 표현식2: switch 문의 표현식과 표현식2가 일치하면 실행될 문; break; default: switch 문의 표현식과 일치하는 표현식을 갖는 case 문이 없을 때 실행될 문;} if…else 문의 조건식은 반드시 불리언 값으로 평가되지만 switch 문의 표현식은 불리언 값보다는 문자열, 숫자 값인 경우가 많다. if…else 문은 논리적 참, 거짓으로 실행할 코드 블록을 결정한다. switch 문은 논리적 참, 거짓보다는 다양한 상황(case)에 따라 실행할 코드 블록을 결정할 때 사용한다. 아래 예제를 살펴보자. switch 문의 표현식, 즉 변수 month의 평가 결과인 숫자 값 11과 일치하는 case 문으로 실행 순서가 이동한다. 12345678910111213141516171819202122232425262728293031323334// 월을 영어로 변환한다. (11 → 'November')var month = 11;var monthName;switch (month) { case 1: monthName = 'January'; case 2: monthName = 'February'; case 3: monthName = 'March'; case 4: monthName = 'April'; case 5: monthName = 'May'; case 6: monthName = 'June'; case 7: monthName = 'July'; case 8: monthName = 'August'; case 9: monthName = 'September'; case 10: monthName = 'October'; case 11: monthName = 'November'; case 12: monthName = 'December'; default: monthName = 'Invalid month';}console.log(monthName); // Invalid month 3. 반목문반복문(Loop statement)은 주어진 조건식의 평가 결과가 참인 경우 코드 블럭을 실행한다. 그 후 조건식을 다시 검사하여 여전히 참인 경우 코드 블록을 다시 실행한다. 이는 조건식이 거짓일 때까지 반복된다. 자바스크립트는 3가지의 반복문 for 문, while 문, do…while 문을 제공한다. 그 외에도 for..in 문, ES6에서 새롭게 도입된 for…of 문이 있다. for..in 문과 for…of 문에 대해서는 나중에 살펴보기로 하자. 3.1 for 문for 문은 조건식이 거짓으로 판별될 때까지 코드 블록을 반복 실행한다. 가장 일반적으로 사용되는 반복문의 형태는 아래와 같다. 변수 선언문의 변수 이름은 반복을 의미하는 iteration의 i를 사용하는 것이 일반적이다. 1234567for (변수 선언문 또는 할당문; 조건식; 증감식) { 조건식이 참인 경우 반복 실행될 문;}for (var i = 0; i &lt; 2; i++) { console.log(i);} 위 예제의 for 문은 변수 i가 0으로 초기화된 상태에서 시작하여 i가 2보다 작을 때까지 코드 블록을 2번 반복 실행한다. for 문의 실행 순서를 따라가며 어떻게 동작하는지 살펴보자. for 문을 실행하면 가장 먼저 변수 선언문 var i = 0이 실행된다. 변수 선언문은 단 한번만 실행된다. 변수 선언문의 실행이 종료되면 조건식으로 실행 순서가 이동한다. 현재 변수 i는 0이므로 조건식의 평가 결과는 true다. 조건식의 평가 결과가 true이므로 실행 순서가 코드 블록으로 이동하여 실행된다. 증감문으로 실행 순서가 이동하는 것이 아니라 코드 블록으로 실행 순서가 이동하는 것에 주의하자. 코드 블록의 실행이 종료하면 증감식으로 실행 순서가 이동한다. 증감식 i++가 실행되어 i는 1이 된다. 증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다. 변수 선언문으로 실행 순서가 이동하는 것이 아니라 조건식으로 실행 순서가 이동하는 것에 주의하자. 변수 선언문은 단 한번만 실행된다. 현재 변수 i는 1이므로 조건식의 평가 결과는 true다. 조건식의 평가 결과가 true이므로 실행 순서가 코드 블록으로 이동하여 실행된다. 코드 블록의 실행이 종료하면 증감식으로 실행 순서가 이동한다. 증감식 i++가 실행되어 i는 2가 된다. 증감식 실행이 종료되면 다시 조건식으로 실행 순서가 이동한다. 현재 변수 i는 2이므로 조건식의 평가 결과는 false다. 조건식의 평가 결과가 false이므로 for 문의 실행이 종료된다. 아래 예제는 위 예제를 역으로 반복하는 for 문이다. 변수 i가 1으로 초기화된 상태에서 시작하여 i가 0보다 같거나 커질 때까지 코드 블록을 2번 반복 실행한다. for 문 내에 for 문을 중첩해 사용할 수 있다. 아래는 두 개의 주사위를 던졌을 때, 두 눈의 합이 6이 되는 모든 경우의 수를 출력하는 예제다. 12345for (var i = 1; i &lt;= 6; i++) { for (var j = 1; j &lt;= 6; j++) { if (i + j === 6) console.log(`[${i}, ${j}]`); }} 출력 결과는 아래와 같다. 12345[1, 5][2, 4][3, 3][4, 2][5, 1] 3.2. while 문while 문은 주어진 조건식의 평가 결과가 참이면 코드 블록을 계속해서 반복 실행한다. 조건문의 평가 결과가 거짓이 되면 실행을 종료한다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 강제 변환되어 논리적 참, 거짓을 구별한다. 1234567var count = 0;// count가 3보다 작을 때까지 코드 블록을 계속 반복 실행한다.while (count &lt; 3) { console.log(count); count++;} // 0 1 2 조건식의 평가 결과가 언제나 참이면 무한루프가 된다. 무한루프를 탈출하기 위해서는 코드 블럭 내에 if문으로 탈출 조건을 만들고 break 문으로 코드 블럭을 탈출한다. 123456789var count = 0;// 무한루프while (true) { console.log(count); count++; // count가 3이면 코드 블록을 탈출한다. if (count === 3) break;} // 0 1 2 4. break 문switch 문과 while 문에서 살펴보았듯이 break 문은 코드 블록을 탈출한다. 좀 더 정확히 표현하자면 코드 블록을 탈출하는 것이 아니라 레이블 문, 반복문(for, for…in, for…of, while, do…while) 또는 switch 문의 코드 블록을 탈출한다. 레이블 문, 반복문, switch 문의 코드 블록 이외에 break 문을 사용하면 SyntaxError(문법 에러)가 발생한다. 123if (true) { break; // Uncaught SyntaxError: Illegal break statement} 5. continue 문continue 문은 반복문의 코드 블록 실행을 현 지점에서 중단하고 반복문의 증감식으로 이동한다. break 문처럼 반복문을 탈출하지는 않는다.아래는 문자열에서 특정 문자의 개수를 카운트하는 예제이다. 12345678910111213141516var string = 'Hello World.';var search = 'l';var count = 0;// 문자열은 유사배열이므로 for 문으로 순회할 수 있다.for (var i = 0; i &lt; string.length; i++) { // 'l'이 아니면 현 지점에서 실행을 중단하고 반복문의 증감식으로 이동한다. if (string[i] !== search) continue; count++; // continue 문이 실행되면 이 문은 실행되지 않는다.}console.log(count); // 3// 참고로 String.prototype.match 메소드를 사용해도 같은 동작을 한다.const regexp = new RegExp(search, 'g');console.log(string.match(regexp).length); // 3 위 예제의 for 문은 아래와 동일하게 동작한다. 1234for (var i = 0; i &lt; string.length; i++) { // 'l'이면 카운트를 증가시킨다. if (string[i] === search) count++;} 위와 같이 if 문 내에서 실행해야 할 코드가 한 줄이라면 continue 문을 사용했을 때보다 간편하며 가독성도 좋다. 하지만 if 문 내에서 실행해야 할 코드가 길다면 들여쓰기가 한 단계 더 깊어지므로 continue 문을 사용하는 것이 가독성이 더 좋다. 123456789101112131415161718192021// continue 문을 사용하지 않으면 if 문 내에 코드를 작성해야 한다.for (var i = 0; i &lt; string.length; i++) { // 'l'이면 카운트를 증가시킨다. if (string[i] === search) { count++; // code // code // code }}// continue 문을 사용면 if 문 밖에 코드를 작성할 수 있다.for (var i = 0; i &lt; string.length; i++) { // 'l'이 아니면 카운트를 증가시키지 않는다. if (string[i] !== search) continue; count++; // code // code // code}","link":"/2020/02/control-flow-statement/"},{"title":"데이터 타입 | javaScript","text":"데이터 타입(Data type. 줄여서 타입이라고도 부른다)은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 자바스크립트(ES6)는 7개의 데이터 타입을 제공한다. 7개의 데이터 타입은 원시 타입(primitive type)과 객체 타입(object/reference type)으로 분류할 수 있다. 원시 타입(primitive type) 숫자(number) 타입: 숫자. 정수와 실수 구분없이 하나의 숫자 타입만 존재 문자열(string) 타입: 문자열 불리언(boolean) 타입: 논리적 참(true)과 거짓(false) undefined 타입: var 키워드로 선언된 변수에 암묵적으로 할당되는 값 null 타입: 값이 없다는 것을 의도적으로 명시할 때 사용하는 값 Symbol 타입: ES6에서 새롭게 추가된 7번째 타입 객체 타입 (object/reference type): 객체, 함수, 배열 등 예를 들어 숫자(number) 타입의 값 1과 문자열(string) 타입의 값 ‘1’은 비슷하게 보이지만 전혀 다른 값이다. 숫자 타입의 값 1과 문자열 타입의 값 ‘1’은 값을 생성한 목적과 용도가 다르다. 숫자 타입의 값은 주로 산술 연산을 위해 생성하지만 문자열 타입의 값은 주로 텍스트를 화면에 출력하기 위해 생성한다. 또한 확보해야 할 메모리 공간의 크기도 다르고 메모리에 저장되는 2진수도 다르며 읽어 들여 해석하는 방식도 다르다. 이처럼 개발자는 명확한 의도를 가지고 타입을 구별하여 값을 생성할 것이고 자바스크립트 엔진은 타입을 구별하여 값을 취급할 것이다. 자바스크립트가 제공하는 데이터 타입의 특징에 대해 살펴보도록 하자. 1. 숫자 타입C나 Java의 경우, 정수(소숫점 이하가 없는 숫자)와 실수(소숫점 이하가 있는 숫자)를 구분하여 int, long, float, double 등과 같은 다양한 숫자 타입이 존재한다. 하지만 자바스크립트는 독특하게 하나의 숫자 타입만 존재한다. ECMAScript 사양에 따르면 숫자 타입의 값은 배정밀도 64비트 부동소수점 형식(double-precision 64-bit floating-point format)을 따른다. 즉, 모든 수를 실수로 처리하며 정수만을 표현하기 위한 데이터 타입(integer type)이 별도로 존재하지 않는다. 1234// 모두 숫자 타입이다.var integer = 10; // 정수var double = 10.12; // 실수var negative = -20; // 음의 정수 정수, 실수, 2진수, 8진수, 16진수 리터럴은 모두 메모리에 배정밀도 64비트 부동소수점 형식의 2진수로 저장된다. 자바스크립트는 2진수, 8진수, 16진수를 표현하기 위한 데이터 타입을 제공하지 않기 때문에 이들 값을 참조하면 모두 10진수로 해석된다. 12345678910var binary = 0b01000001; // 2진수var octal = 0o101; // 8진수var hex = 0x41; // 16진수// 표기법만 다를 뿐 모두 같은 값이다.console.log(binary); // 65console.log(octal); // 65console.log(hex); // 65console.log(binary === octal); // trueconsole.log(octal === hex); // true 자바스크립트의 숫자 타입은 정수만을 위한 타입이 없고 모든 수를 실수로 처리한다고 했다. 정수로 표시된다 해도 사실은 실수다. 따라서 정수로 표시되는 수 끼리 나누더라도 실수가 나올 수 있다. 1234// 숫자 타입은 모두 실수로 처리된다.console.log(1 === 1.0); // trueconsole.log(4 / 2); // 2console.log(3 / 2); // 1.5 숫자 타입은 추가적으로 3가지 특별한 값들도 표현할 수 있다. Infinity : 양의 무한대 -Infinity : 음의 무한대 NaN : 산술 연산 불가(not-a-number) 1234// 숫자 타입의 3가지 특별한 값console.log(10 / 0); // Infinityconsole.log(10 / -0); // -Infinityconsole.log(1 * 'String'); // NaN 2. 문자열 타입문자열(string) 타입은 텍스트 데이터를 나타내는데 사용한다. 문자열은 0개 이상의 16bit 유니코드 문자(UTF-16) 들의 집합으로 전세계 대부분의 문자를 표현할 수 있다. 문자열은 작은 따옴표(‘’), 큰 따옴표(“”) 또는 백틱(``)으로 텍스트를 감싼다. 자바스크립트에서 가장 일반적인 표기법은 작은 따옴표를 사용하는 것이다. 12345678// 문자열 타입var string;string = '문자열'; // 작은 따옴표string = \"문자열\"; // 큰 따옴표string = `문자열`; // 백틱 (ES6)string = '작은 따옴표로 감싼 문자열 내의 \"큰 따옴표\"는 문자열로 인식된다.';string = \"큰 따옴표로 감싼 문자열 내의 '작은 따옴표'는 문자열로 인식된다.\"; 다른 타입의 값과는 달리 문자열을 따옴표로 감싸는 이유는 키워드나 식별자와 같은 토큰과 구분하기 위함이다. 만약 문자열을 따옴표로 감싸지 않으면 자바스크립트 엔진은 키워드나 식별자와 같은 토큰으로 인식한다. 12// 따옴표로 감싸지 않은 hello를 식별자로 인식한다.var string = hello; // ReferenceError: hello is not defined 그리고 만약 따옴표로 문자열을 감싸지 않는다면 스페이스와 같은 공백 문자도 포함시킬 수 없다. C나 Java와 같은 언어와는 다르게 자바스크립트의 문자열은 원시 타입이며 변경 불가능한 값 (immutable value)다. 이것은 문자열이 생성되면 그 문자열을 변경할 수 없다는 것을 의미한다. 이에 대해서는 “11.1.2. 문자열과 불변성”에서 살펴보기로 하자. 3.템플릿 리터럴ES6부터 템플릿 리터럴(Template literal)이라고 불리는 새로운 문자열 표기법이 도입되었다. 템플릿 리터럴은 멀티라인 문자열(Multi-line string), 표현식 삽입(Expression interpolation), 태그드 템플릿(Tagged template) 등 편리한 문자열 처리 기능을 제공한다. 템플릿 리터럴은 런타임에 일반 문자열로 변환되어 처리된다. 템플릿 리터럴은 일반 문자열과 비슷해 보이지만, 작은 따옴표(‘’) 또는 큰 따옴표(“”) 같은 일반적인 따옴표 대신 백틱(backtick) `를 사용한다. 12var template = `Template literal`;console.log(template); // Template literal 3.1. 멀티라인 문자열일반 문자열 내에서 줄바꿈은 허용되지 않는다. 123var str = 'Helloworld.';// SyntaxError: Invalid or unexpected token 3.2. 표현식 삽입문자열은 문자열 연산자 +를 사용해 연결할 수 있다. + 연산자는 피연산자 중 하나 이상이 문자열인 경우, 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작한다. 123456var first = 'Ung-mo';var last = 'Lee';// ES5: 문자열 연결console.log('My name is ' + first + ' ' + last + '.');// My name is Ung-mo Lee. 템플릿 리터럴 내에서는 표현식 삽입(Expression interpolation)을 통해 간단히 문자열을 삽입할 수 있다. 이를 통해 문자열 연산자보다 가독성 좋고 간편하게 문자열을 조합할 수 있다. 123456var first = 'Ung-mo';var last = 'Lee';// ES6: 표현식 삽입console.log(`My name is ${first} ${last}.`);// My name is Ung-mo Lee. 표현식 삽입은 ${ }으로 표현식을 감싼다. 이때 표현식의 평가 결과가 문자열이 아니더라도 문자열로 강제 타입 변환되어 삽입된다. 1console.log(`1 + 2 = ${1 + 2}`); // 1 + 2 = 3 표현식 삽입은 반드시 템플릿 리터럴 내에서 사용해야 한다.템플릿 리터럴이 아닌 일반 문자열에서 표현식 삽입은 문자열 취급을 받는다. 1console.log('1 + 2 = ${1 + 2}'); // 1 + 2 = ${1 + 2} 4. 불리언 타입불리언(boolean) 타입의 값은 논리적 참, 거짓을 나타내는 true와 false 뿐이다. 12345var foo = true;console.log(foo); // truefoo = false;console.log(foo); // false 불리언 타입의 값은 참과 거짓으로 구분되는 조건에 의해 프로그램의 흐름을 제어하는 조건문에서 자주 사용한다. 이에 대해서는 “8.2. 조건문”에서 살펴보기로 하자. 5. undefined 타입undefined 타입의 값은 undefined가 유일하다. var 키워드로 선언한 변수는 undefined로 초기화된다. 다시 말해, 변수 선언에 의해 확보된 메모리 공간을 처음 할당이 이루어질 때까지 빈 상태(대부분 비어있지 않고 쓰레기 값(Garbage value)이 들어 있다)로 내버려두지 않고 자바스크립트 엔진이 undefined로 초기한다. 따라서 선언 이후 값을 할당하지 않은 변수에 접근하면 undefined가 반환된다. 12var foo;console.log(foo); // undefined 이처럼 undefined는 개발자가 의도적으로 할당하기 위한 값이 아니라 자바스크립트 엔진이 변수를 초기화할 때 사용하는 값이다. 변수를 참조했을 때 undefined가 반환된다면 참조한 변수가 선언 이후 값이 할당된 적인 없는 변수라는 것을 개발자는 간파할 수 있다. 자바스크립트 엔진이 변수 초기화에 사용하는 undefined를 개발자가 의도적으로 변수에 할당한다면 undefined의 본래의 취지와 어긋날 뿐더러 혼란을 줄 수 있으므로 권장하지 않는다. 그렇다면 변수에 값이 없다는 것을 명시하고 싶은 경우 어떻게 하면 좋을까? 그런 경우는 undefined를 할당하는 것이 아니라 null을 할당한다. 선언(Declaration)과 정의(Definition) undefined를 직역하면 “정의되지 않은”이다. 일반적으로 정의란 개념은 어떤 대상을 명확하게 규정하는 것을 의미한다. 자바스크립트의 undefined에서 말하는 정의란 변수에 값을 할당하여 변수의 실체를 명확히 하는 것을 말한다. 다른 프로그래밍 언어에서는 선언과 정의를 엄격하게 구분하여 사용하는 경우가 있다. 예를 들어 C에서 선언과 정의는 “실제로 메모리 주소를 할당하는가”로 구분한다. 단순히 컴파일러에게 식별자의 존재 만을 알리는 것은 선언이고 실제로 컴파일러에게 변수를 생성하도록 하여 식별자와 메모리 주소가 연결되면 정의로 구분한다. 자바스크립트의 경우, 변수를 선언하면 정의가 이루어지기 때문에 선언과 정의의 구분이 모호하다. 자바스크립트에서 선언은 식별자가 생성되었지만 값이 아직 할당되지 않은 상태를 말한다. 자바스크립트에서 정의는 식별자가 생성되었고 값까지 할당되어 있는 상태를 의미한다.123456// 변수 선언. 내부적으로 undefined로 정의된다.var foo;// 변수 선언과 정의var bar = 1;// 함수 정의. 식별자가 암묵적으로 생성되고 함수 객체가 할당된다.function baz {} 6. null타입null 타입의 값은 null이 유일하다. 자바스크립트는 대소문자를 구별(case-sensitive)하므로 null은 Null, NULL등과 다르다. 프로그래밍 언어에서 null은 변수에 값이 없다는 것을 의도적으로 명시(의도적 부재 Intentional absence)할 때 사용한다. 변수에 null을 할당하는 것은 변수가 이전에 참조하던 값을 더이상 참조하지 않겠다는 의미이다. 이는 이전에 할당되어 있던 값에 대한 참조를 명시적으로 제거하는 것을 의미하며 자바스크립트 엔진은 누구도 참조하지 않는 메모리 공간에 대해 가비지 콜렉션을 수행할 것이다. 12345var foo = 'Lee';// 이전에 할당되어 있던 값에 대한 참조를 제거. 변수 foo는 더이상 'Lee'를 참조하지 않는다.// 유용해 보이지는 않는다. 변수의 스코프를 좁게 만들어 변수 자체를 재빨리 소멸시키는 편이 낳다.foo = null; 함수가 유효한 값을 반환할 수 없는 경우, 명시적으로 null을 반환하기도 한다. 예를 들어, HTML 요소를 검색해 반환하는 document.querySelector 메소드는 조건에 부합하는 HTML 요소를 검색할 수 없는 경우, 에러 대신 null을 반환한다. 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; var element = document.querySelector('.myClass'); // HTML 문서에 myClass 클래스를 갖는 요소가 없다면 null을 반환한다. console.log(element); // null &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 7. symbol 타입심볼(symbol)은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다. 심볼은 주로 이름의 충돌 위험이 없는 객체의 유일한 프로퍼티 키(property key)를 만들기 위해 사용한다. 심볼 이외의 원시값은 리터럴을 통해 생성하지만 심볼은 Symbol 함수를 호출해 생성한다. 이때 생성된 심볼 값은 노출되지 않으며 다른 값과 절대 중복되지 않는 유일무이한 값이다. 12345678910// 심볼 값 생성var key = Symbol('key');console.log(typeof key); // symbol// 객체 생성var obj = {};// 심볼 key를 이름의 충돌 위험이 없는 유일한 프로퍼티 키로 사용한다.obj[key] = 'value';console.log(obj[key]); // value 8. 객체 타입자바스크립트의 데이터 타입은 원시 타입과 객체 타입으로 크게 분류한다고 했다. 그 이유는 무엇일까? 원시 타입과 객체 타입은 근본적으로 다르다는 의미일 것이다. 이에 대한 설명은 아직 객체에 대해 살펴보지 않았으므로 잠시 미루도록 하자. 중요한 것은 자바스크립트는 객체 기반의 언어이며 자바스크립트를 이루고 있는 거의 모든 것이 객체라는 것이다. 지금까지 살펴본 6가지의 데이터 타입 이외의 값은 모두 객체 타입이다. 9. 데이터 타입의 필요성데이터 타입은 왜 필요한 것일까? 데이터 타입의 필요성에 대해 살펴보도록 하자. 9.1. 데이터 타입에 의한 메모리 공간의 확보와 참조모든 값은 메모리에 저장하고 참조할 수 있어야 한다. 메모리에 값을 저장하기 위해서는 먼저 확보해야 할 메모리 공간의 크기를 알아야한다. 다시 말해 몇 byte의 메모리 공간을 사용해야 낭비와 손실없이 값을 저장할 수 있는지 알아야 한다. 예를 들어 아래와 같이 변수를 선언하고 숫자 값을 할당해 보자. 1var score = 100; 코드가 실행되면 컴퓨터는 숫자 값 100을 저장하기 위해 메모리 공간을 확보한 다음, 확보된 메모리에 숫자 값 100을 2진수로 저장한다. 이러한 처리를 하려면 숫자 값을 저장할 때 확보해야 할 메모리 공간의 크기를 알아야 한다. 자바스크립트 엔진은 데이터 타입, 즉 값의 종류에 따라 정해진 크기의 메모리 공간을 확보한다. 즉, 변수에 할당되는 값의 데이터 타입에 따라 확보해야 할 메모리 공간의 크기가 결정된다. 위 예제의 경우, 자바스크립트 엔진은 100을 숫자 타입의 값으로 해석하고 숫자 타입의 값 100을 저장하기 위해 8byte의 메모리 공간을 확보한다. 그리고 10진수 100을 2진수로 저장한다. 자바스크립트는 숫자 타입의 값을 생성할 때 배정밀도 64비트 부동소수점 포맷(double-precision 64-bit floating-point format)을 사용한다. 따라서 실제로 메모리에 저장되는 2진수 값은 위 그림과 다르다. 지금은 간단히 양의 정수로 저장된다고 생각하자. 데이터 타입에 따라 확보되는 메모리 공간의 크기 ECMAScript 사양은 문자열과 숫자 타입 이외의 데이터 타입의 크기를 명시적으로 규정하고 있지는 않다. 따라서 문자열과 숫자 타입을 제외하고 데이터 타입에 따라 확보되는 메모리 공간의 크기는 브라우저 제조사의 구현에 따라 다를 수 있다. 단, ECMAScript 사양에 숫자 타입은 배정밀도 64비트 부동소수점 포맷을 사용한다고 명시되어 있고, 배정밀도 64비트 부동소수점 포맷은 8byte로 숫자를 표현하므로 이 책에서는 숫자 값의 크기를 8byte로 설명하고 있다.이번에는 값을 참조하는 경우를 생각해보자. 식별자 score를 통해 숫자 타입의 값 100이 저장되어 있는 메모리 공간의 주소를 찾아갈 수 있다. 정확히 말하면 숫자 값 100이 저장되어 있는 메모리 공간의 선두 메모리 셀의 주소를 찾아갈 수 있다. 이때 값을 참조하려면 한번에 읽어 들여야 할 메모리 공간의 크기, 즉 메모리 셀의 개수(byte 수)를 알아야 한다. 변수 score의 경우, 저장되어 있는 값이 숫자 타입이므로 8byte 단위로 읽어 들이지 않으면 값이 훼손된다. 그렇다면 컴퓨터는 한번에 읽어 들여야 할 메모리 셀의 크기를 어떻게 알 수 있는 것일까? 변수 score에는 숫자 타입의 값이 할당되어 있으므로 자바스크립트 엔진은 변수 score를 숫자 타입으로 인식한다. 숫자 타입은 8byte 단위로 저장되어 있으므로 변수 score를 참조하면 8byte 단위로 메모리 공간에 저장된 값을 읽어 들인다. 9.2. 데이터 타입에 의한 값의 해석그런데 아직 문제가 남아 있다. 메모리에서 읽어 들인 2진수를 어떻게 해석해야 하는지에 대한 것이다. 모든 값은 데이터 타입을 갖으며 메모리에 2진수, 즉 비트(bit)의 나열로 저장된다. 메모리에 저장된 값은 데이터 타입에 따라 다르게 해석될 수 있다. 예를 들어, 메모리에 저장된 값 0100 0001를 숫자로 해석하면 65이지만 문자열로 해석하면 ‘A’이다. 123456// 2진수 01000001을 10진수 숫자로 해석하면 65이다.// parseInt는 문자열을 숫자로 변환한다.console.log(parseInt('01000001', 2)); // 65// 진수 01000001을 문자(Unicode)로 해석하면 'A'이다.// String.fromCharCode은 UTF-16 코드 유닛의 시퀀스로부터 문자열을 생성한다.console.log(String.fromCharCode(parseInt('01000001', 2))); // A 위에서 살펴본 예제의 변수 score에 할당된 값은 숫자 타입의 값이다. 따라서 변수 score를 참조하면 메모리 공간의 주소에서 읽어 들인 2진수를 숫자로 해석한다. 지금까지 살펴본 데이터 타입에 대해 정리해보자. 데이터 타입(Data type)은 값의 종류를 말한다. 자바스크립트의 모든 값은 데이터 타입을 갖는다. 데이터 타입이 필요한 이유는 아래와 같다. 값을 저장할 때 확보해야 하는 메모리 공간의 크기를 결정하기 위해 값을 참조할 때 한번에 읽어 들여야 할 메모리 공간의 크기를 결정하기 위해 메모리에서 읽어 들인 2진수를 어떻게 해석할 지를 결정하기 위해 10.동적 타이핑10.1 동적 타입 언어와 정적 타입 언어자바스크립트의 모든 값은 데이터 타입을 갖는다고 했다. 그렇다면 변수는 데이터 타입을 갖을까? C나 Java와 같은 정적 타입(Static/Strong type) 언어는 변수를 선언할 때 변수에 할당할 수 있는 값의 종류, 즉 데이터 타입을 사전에 선언해야 한다. 이를 명시적 타입 선언(explicit type declaration)이라 한다. 다음은 C에서 정수 타입의 변수를 선언하는 예이다. 12345// 변수 c에는 1byte 정수 타입의 값(-128 ~ 127)만을 할당할 수 있다.char c;// 변수 num에는 4byte 정수 타입의 값(-2,124,483,648 ~ 2,124,483,647)만을 할당할 수 있다.int num; 정적 타입 언어는 변수의 타입을 변경할 수 없으며 변수에 선언한 타입에 맞는 값만을 할당할 수 있다. 정적 타입 언어는 컴파일 시점에 타입 체크(선언한 데이터 타입에 맞는 값을 할당했는지 검사하는 처리)를 수행한다. 만약 타입 체크를 통과하지 못했다면 에러를 발생시키고 프로그램의 실행 자체를 막는다. 이를 통해 타입의 일관성을 강제하여 보다 안정적인 코드의 구현을 통해 런타임에 발생하는 에러를 줄인다. 대표적인 정적 타입 언어는 C, C++, Java, Kotlin, Go, Haskell, Rust, Scala 등이 있다. 자바스크립트는 정적 타입 언어와는 다르게 변수를 선언할 때 타입을 선언하지 않는다. 다만 var, let, const 키워드를 사용해 변수를 선언할 뿐이다. 자바스크립트의 변수는 정적 타입 언어와 같이 미리 선언한 데이터 타입의 값만을 할당할 수 있는 것이 아니다. 어떠한 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 하나의 변수를 선언하고 지금까지 살펴본 다양한 데이터 타입의 값을 할당한 다음, typeof 연산자로 변수의 데이터 타입을 조사해 보자. typeof 연산자(“7.8. typeof 연산자” 참고)는 자신의 뒤에 위치한 피연산자의 데이터 타입을 문자열로 반환한다. 1234567891011121314151617181920212223242526var foo;console.log(typeof foo); // undefinedfoo = 3;console.log(typeof foo); // numberfoo = 'Hello';console.log(typeof foo); // stringfoo = true;console.log(typeof foo); // booleanfoo = null;console.log(typeof foo); // objectfoo = Symbol(); // 심볼console.log(typeof foo); // symbolfoo = {}; // 객체console.log(typeof foo); // objectfoo = []; // 배열console.log(typeof foo); // objectfoo = function () {}; // 함수console.log(typeof foo); // function typeof 연산자로 변수를 연산해 보면 변수의 데이터 타입을 반환한다. 정확히 말하면 변수의 데이터 타입을 반환하는 것이 아니라 변수에 할당된 값의 데이터 타입을 반환한 것이다. 자바스크립트의 변수는 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있으므로 정적 타입 언어에서 말하는 데이터 타입과 개념이 다르다. 정적 타입 언어는 변수 선언 시점에 변수의 타입이 결정되고 변수의 타입을 변경할 수 없다. 자바스크립트는 값을 할당하는 시점에 변수의 타입이 동적으로 결정되고 변수의 타입을 언제든지 자유롭게 변경할 수 있다. 다시 말해 자바스크립트 변수는 선언이 아닌 할당에 의해 타입이 결정된다. 그리고 재할당에 의해 변수의 타입은 언제든지 동적으로 변할 수 있다. 이러한 특징을 동적 타이핑(Dynamic typing)이라 하며 자바스크립트를 정적 타입 언어와 구별하기 위해 동적 타입(Dynamic/Weak type) 언어라 부른다. 대표적인 동적 타입 언어는 자바스크립트, Python, PHP, Ruby, Lisp, Perl 등이 있다. 처음의 질문으로 돌아가 보자. 변수는 타입을 갖을까? 기본적으로 변수는 타입을 갖지 않는다. 하지만 값은 타입을 갖는다. 따라서 현재 변수에 할당되어 있는 값에 의해 변수의 타입이 동적으로 결정된다고 표현하는 것이 보다 적절하다. 변수는 값에 묶여 있는 값에 대한 별명이기 때문이다. 10.2. 동적 타입 언어와 변수동적 타입 언어는 변수에 어떤 데이터 타입의 값이라도 자유롭게 할당할 수 있다. 이러한 동적 타입 언어의 특징은 데이터 타입에 대해 무감각해질 정도로 편리하다. 하지만 언제나 그렇듯 편리함의 이면에는 위험도 도사리고 있다. 모든 소프트웨어 아키텍처에는 트레이드오프(trade-off)가 존재하며 모든 애플리케이션에 적합한 은 탄환(Silver bullet)은 없듯이, 동적 타입 언어 또한 구조적인 단점이 있다. 변수 값은 언제든지 변경될 수 있기 때문에 복잡한 프로그램에서는 변화하는 변수 값을 추적하기 어려울 수 있다. 뿐만 아니라, 변수의 타입이 고정되어 있지 않고 동적으로 변하는 동적 타입 언어의 변수는 값의 변경에 의해 타입도 언제든지 변경될 수 있다. 따라서 동적 타입 언어의 변수는 값을 확인하기 전에는 타입을 확신할 수 없다. 더욱이 자바스크립트는 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다. 즉, 숫자 타입의 변수일 것이라고 예측했지만 사실은 문자열 타입의 변수일 수도 있다는 말이다. 잘못된 예측에 의해 작성된 프로그램은 당연히 오류를 뿜어낼 것이다. 결국 동적 타입 언어는 유연성(flexibility)은 높지만, 신뢰성(reliability)은 떨어진다. 이러한 이유로 안정적인 프로그램을 만들기 위해 변수를 사용하기 이전에 데이터 타입을 체크해야 하는 경우가 있는데 이는 매우 번거로울 뿐만 아니라 코드량도 증가한다. 코드량이 증가하면 버그가 발생할 확률도 높아지며 테스트 분량도 증가한다. 따라서 변수를 사용할 때 주의할 사항은 아래와 같다. 변수는 꼭 필요한 경우에 한해 제한적으로 사용한다. 변수값은 재할당에 의해 언제든지 변경될 수 있다. 이로 인해 동적 타입 언어인 자바스크립트는 타입을 잘못 예측해 오류가 발생할 가능성이 크다. 변수의 개수가 많으면 많을수록 오류가 발생할 확률도 높아진다. 따라서 변수의 무분별한 남발은 금물이며 필요 최소한으로 유지하도록 주의해야 한다. 변수의 유효 범위(스코프)는 최대한 좁게 만들어 변수의 부작용을 억제해야 한다. 변수의 유효 범위가 넓으면 넓을수록 변수로 인해 오류가 발생할 확률은 높아진다. 변수의 유효 범위에 대해서는 “13. 스코프”에서 자세히 살펴보도록 하자. 전역 변수는 최대한 사용하지 않도록 한다. 어디서든지 참조/변경 가능한 전역 변수는 의도치 않게 값이 변경될 가능성이 높고 다른 코드에 영향을 줄 가능성도 높다. 따라서 전역 변수는 프로그램의 복잡성을 증가시키고 처리의 흐름을 추적하기 어렵게 만들고, 오류가 발생했을 경우, 오류의 원인을 특정하기 어렵게 만든다. 전역 변수의 문제점과 전역 변수의 사용을 억제하는 방법에 대해서는 “14. 전역 변수의 문제점”에서 자세히 살펴보도록 하자. 변수보다는 상수를 사용해 값의 변경을 억제한다. 상수를 사용하는 방법에 대해서는 “15.3. const 키워드”에서 살펴보도록 하자. 변수 이름은 변수의 목적이나 의미를 파악할 수 있도록 네이밍한다. 변수 이름 뿐만이 아니라 모든 식별자(변수, 함수, 클래스 이름 등)는 존재 이유를 파약할 수 있는 적절한 이름을 네이밍해야 한다. 특히 식별자의 유효 범위가 넓을수록 보다 명확한 이름을 명명하도록 노력하도록 하자. 개발자의 의도를 나타내는 명확한 네이밍은 코드를 이해하기 쉽게 만들며 이는 협업과 생산성 향상에 도움을 준다. 변수 이름은 첫아이 이름을 짓듯이 심사숙고해서 지어야 한다. 코드는 오해하지 않도록 작성해야 한다. 오해는 커뮤니케이션을 어렵게 하는 대표적인 원인으로 생산성을 떨어뜨리는 것은 물론 팀의 사기까지 저하시킨다. 코드는 동작하는 것만이 존재 목적은 아니다. 코드는 개발자를 위한 문서이기도 하다. 따라서 사람이 이해할 수 있는 코드, 즉 가독성이 좋은 코드가 좋은 코드다. 그럼 2만~","link":"/2020/02/data-type/"},{"title":"함수 | javaScript","text":"1. 함수란?함수는 자바스크립트에서 가장 중요한 핵심 개념입니다. 다른 자바스크립트의 핵심 개념인 스코프, 실행 컨텍스트, 클로저, 생성자 함수에 의한 객체 생성, 메소드, this, 프로토타입, 모듈화 등이 모두 함수와 깊은 관련이 있습니다. 따라서 함수는 자바스크립트를 정확히 이해하고 넘어 가야하는 핵심 중의 핵심이라고 할 수 있습니다. 프로그래밍 언어의 함수도 수학의 함수와 같은 개념입니다. 함수 f(x,y) = x + y를 자바스크립트의 함수로 표현해 봅시다. 12345function add(x, y) { return x + y;}add(2, 5) // 7 프로그래밍 언어의 함수는 일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것입니다. 함수 내부로 입력을 전달받는 변수를 매개변수(parameter), 입력을 (argument), 출력을 반환값(return value)이라 한다. 또한 함수는 값이며 여러 개 존재할 수 있으므로 특정 함수를 구별하기 위해 식별자인 함수 이름을 사용할 수 있다. 함수는 함수 정의를 통해 생성한다. 123function add(x, y) { return x + y;} 함수 정의만으로 함수가 실행되지 않는다. 인수를 매개변수를 통해 함수에 전달해야하다. 이를 함수 호출이라 한다. 함수를 호출하면 코드 블록에 담긴 무늘이 일괄적으로 실행되고 실행 결과, 반환값을 반환한다. 12345// 함수 호출var result = add(2, 5);// 함수 add에 인수 2, 5를 전달하면서 호출하면 반환값 7을 반환한다.console.log(result); //7 2. 함수의 사용 이유함수는 필요할 떄 여러 번 호출할 수 있다. 함수는 몇 번이든 호출할 수 있으므로 코드의 재사용이라는 측면에서 매우 유용하다. 함수를 사용하지 않고 같은 코드를 중복해서 여러 번 작성하면 그 코드를 수정해야 할 떄 중복된 횟수만큼 코드를 수정해야 한다. 코드의 중복을 억제하고 재사용성을 높이는 함수는 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성을 높이는 효과가 있다. 함수는 객체 타입의 값이다. 따라서 이름(식별자)을 붙일 수 있다.함수 이름은 변수 이름과 마찬가지로 함수 자신의 역할을 잘 설명해야 한다. 3. 함수 리터럴1234// 변수에 함수 리터럴을 할당var add = function add(x, y) { return x + y;}; 함수 리터럴의 구성 요소에 대한 설명은 아래와 같다. 함수 이름 함수 이름은 식별자이다. 따라서 식별자 네이밍 규칙을 준수해야 한다. 함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자이다. 함수 이름은 생략할 수 있다. 함수 이름이 있는 함수를 기명함수, 이름이 없는 함수를 익명함수라 한다. 매개변수 목록 0개 이상의 매개변수를 소괄호로 감싸고 쉼표로 구분한다. 매개변수에는 함수호출문의 인수가 순서대로 할당된다. 매개변수는 함수 몸체 내에서 변수와 동일하게 취급된다. 따라서 매개변수도 변수와 마찬가지로 식별자 네이밍 규칙을 준수해야 한다. 함수 몸체 함수가 호출되었을 떄 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드 블록이다. 함수 몸체는 함수 호출에 의해 실행된다. 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하여 값을 생성하는 표기 방식을 말한다. 따라서 함수 리터럴도 평가되어 값을 생성하며 이 값은 객체다. 즉, 함수는 객체다. 함수는 객체이지만 일반 객체와는 다르다. 일반 객체는 호출할 수 없지만 함수는 호출할 수 있다. 그리고 일반 객체에는 없는 함수 객체만의 고유한 프로퍼티를 갖는다. 4. 함수 정의함수를 정의 하는 방법은 4가지가 있다. 함수 선언문 123function add(x, y) { return x + y;} 함수 표현식 123var add = function(x, y) { return x + y;} Function 생성자 함수 1var add = new Function('x', 'y', 'return x + y'); 화살표 함수:ES6 1var add = (x, y) =&gt; x + y; 각각의 함수 정의 방식은 함수를 정의한다는 면에서는 동일하다. 단 미묘하지만 중요한 차이가 있다. 변수 선언과 함수 정의 함수 선언문이 평가되면 식별자가 암묵적으로 생성되고 함수 객체가 할당된다. 따라서 ECMAScript 사양에서도 변수는 선언, 함수는 정의라고 표현하고 있다.4.1. 함수 선언문함수 선언문을 사용하여 함수를 정의하는 방식은 아래와 같다. 12345678910// 함수 선언문function add(x, y) { return x + y;}//함수 참조console.dir(add); // f add(x, y)//함수 호출consle.log(add(2, 5)); // 7 함수 선언문은 함수 리터럴과 형태가 동일하다. 함수 리터럴은 함수 이름을 생략할 수 있으나 함수 선언문은 함수 이름을 생략할 수 없다. 123456// 함수 선언문은 함수 이름을 생략할 수 없다.function (x, y) { return x + y;}// syntaxError: Function statements require a function name; 함수 선언문은 표현식이 아닌 문이다. 즉 함수 선언문을 실행하면 완료값 undefined를 출력한다.함수 선언문이 만약 표현식인 문이라면 완료 값 undefined 대신 표현식이 평가되어 생성된 함수가 출력되어야 한다. 표현식인 문과 표현식이 아닌 문에서 살펴보았듯이 표현식이 아닌 문은 변수에 할당할 수 없다. 함수 선언문도 표현식이 아닌 문이므로 변수에 할당할 수 없다. 12345678// 함수 선언문은 표현식이 아닌 문이므로 변수에 할당할 수 없다.// 하지만 함수 선언문이 변수에 할당되는 것 처럼 보인다.var add = function add(x, y) { return x + y;}// 함수 호출console.log(add(2, 5)); // 7 함수 리터럴을 변수에 할당하거나 피연산자로 사용하면 함수 리터럴 표현식으로 해석한다. 123456789// 이름이 있는 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석한다.// 함수 선언문은 함수 이름을 생략할 수 없다.function foo() { console.log('foo'); }foo(); // foo// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식로 해석한다.// 함수 리터럴은 함수 이름을 생략할 수 있다.(function bar() { console.log('bar'); });bar(); // ReferenceError: bar is not defined 함수 리터럴”에서 “함수 이름은 함수 몸체 내에서만 참조할 수 있는 식별자다”라고 했다. 이는 함수 몸체 외부에서는 함수 이름으로 함수를 참조할 수 없으므로 함수 몸체 외부에서는 함수 이름으로 함수를 호출할 수 없다는 의미이다. 즉, 함수를 가리키는 식별자가 없다는 것과 마찬가지다. 따라서 위 예제의 bar 함수는 호출할 수 없다. 하지만 위 예제에서 함수 선언문으로 정의된 함수는 foo라는 이름으로 호출할 수 있었다. foo는 함수 몸체 내부에서만 유효한 식별자인 함수 이름이므로 foo로 함수를 호출할 수 없어야 한다. foo라는 이름으로 함수를 호출하려면 foo는 함수 이름이 아니라 함수 객체를 할당한 식별자이어야 한다. 그런데 위 예제에는 식별자 foo를 선언한 적도 없고 할당한 적도 없다. foo는 도대체 무엇인가? 결론부터 말하자면 foo는 생성된 함수 객체를 할당하고 있는 자바스크립트 엔진이 암묵적으로 생성한 식별자이다. 함수 선언문은 실행되어 함수 객체를 생성한다. 이떄 함수 이름은 함수 몸체 내부에서만 유효한 식별자 이므로 생성된 함수 객체를 가리키는 식별자가 필요하다. 함수 객체를 가리키는 식별자가 없으면 생성된 함수 객체를 호출할 수 없고 아무도 참조하고 있지 않는 함수 객체는 가비지 컬렉터에 의해 메모리에서 해제된다. 이를 위해 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다. 12345var add = function add(x, y) { return x + y;};console.log(add(2, 5)); // 7 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다.즉, 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수 이름 add이 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 add인 것이다.함수의 이름을 그대로 똑같이 식별자에 복사를 하는 것이다. 함수는 함수 이름으로 호출하는 것이 아니라 함수 객체를 가리키는 식별자로 호출한다. 함수 선언문 방식으로 생성된 함수를 호출한 것은 함수 이름 add이 아니라 자바스크립트 엔진이 암묵적으로 생성한 식별자 add인 것이다. 함수 이름과 변수 이름이 일치하므로 함수 이름으로 호출되는 듯 보이지만 사실은 식별자로 호출된 것이다. 4.2. 함수 표현식 자바스크립트의 함수는 일급 객체이다. 함수가 일급 객체라는 것은 함수를 값처럼 자유롭게 사용할 수 있다는 의미다. 함수는 일급 객체이므로 함수 리터럴로 생성한 함수 객체를 변수에 할당할 수 있다. 이러한 함수 정의 방식을 함수 표현식(Function expression)이라 한다. 123456// 함수 표현식var add = function(x, y) { return x + y;};console.log(add(2, 5)); // 7 함수 리터럴의 함수 이름은 생략할 수 있다. 이러한 함수를 익명 함수(anonymous function)이라 한다. 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적이다. 함수 선언문에서 살펴본 바와 같이, 함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용하여야 한다. 함수 이름은 함수 몸체 내부에서만 유효한 식별자이므로 함수 이름으로 함수를 호출할 수 없다. 1234567891011// 기명 함수 표현식var add = function foo (x, y) { return x + y;};// 함수 객체를 가리키는 식별자로 호출console.log(add(2, 5)); // 7// 함수 이름으로 호출하면 ReferenceError가 발생한다.// 함수 이름은 함수 몸체 내부에서만 유효한 식별자이다.console.log(foo(2, 5)); // ReferenceError: foo is not defined 자바스크립트 엔진은 함수 선언문의 함수 이름으로 식별자를 암묵적 생성하고 생성된 함수 객체를 할당하므로 함수 표현식과 유사하게 동작하는 것처럼 보인다. **함수 선언문은 “표현식이 아닌 문”이고 함수 표현식은 “표현식인 문”이다. 4.3 함수 생성 시점과 함수 호이스팅아래 예제를 살펴보자. 1234567891011121314151617// 함수 참조console.dir(add); // ƒ add(x, y)console.dir(sub); // undefined// 함수 호출console.log(add(2, 5)); // 7console.log(sub(2, 5)); // TypeError: sub is not a function// 함수 선언문function add(x, y) { return x + y;}// 함수 표현식var sub = function (x, y) { return x - y;}; 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 그러나 함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다. 이는 함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수의 생성 시점이 다르기 때문이다. 모든 선언문이 그러하듯 함수 선언문도 다른 코드가 한줄씩 순차적으로 실행되는 시점, 즉 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 다시 말해, 함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성된다. 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당한다. 즉, 코드가 한줄씩 순차적으로 실행되기 시자하는 런타임에는 이미 함수 객체가 생성되어 있고 함수 이름과 동일한 식별자에 할당까지 완료된 상태다.따라서 함수 선어문 이전에 함수를 참조할 수 있으며 호출할 수도 있다. 이런 자바스크립트 고유의 특징을 함수 호이스팅이라 한다. 함수 호이스팅과 변수 호이스팅은 미묘한 차이가 있으므로 주의하기 바란다. var 키워드로 사용한 변수 선언문과 함수 선언문은 모두 런타임 이전에 자바스크립트 엔진에 의해 먼저 실행되어 식별자를 생성한다는 점에서 동일하다. 하지만 var 키워드로 선언된 변수는 undefined로 초기화되고, 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다. 따라서 var 키워드로 사용한 변수 선언문 이전에 변수를 참조하면 변수 호이스팅에 의해 undefined로 평가되지만 함수 선언문으로 정의한 함수를 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다. 변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만, 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. 따라서 함수 표현식으로 함수를 정의하면 함수 호이스팅이 발생하는 것이 아니라 변수 호이스팅이 발생한다.함수 표현식 이전에 함수를 참조하면 undefined으로 평가된다. 따라서 이때 함수를 호출하면 undefined를 호출하는 것과 마찬가지이므로 타입 에러(TypeError)가 발생한다. 따라서 함수 표현식으로 정의한 함수는 반드시 함수 표현식 이후에 참조 또는 호출하여야 한다. 4.4 Function 생성자 함수자바스크립트가 기본 제공하는 빌트인 함수인 Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성하여 반환한다. (사실 new 연산자 없이 호출하여도 결과는 동일하다.) Function 생성자 함수로 지금까지 살펴본 add 함수를 생성해 봅시다. 123var add = new Function('x', 'y', 'return x + y');console.log(add(2, 5)); // 7 Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않으며 바람직하지도 않다. 123var add = new Function('x', 'y', 'return x + y');console.log(add(2, 5)); // 7 4.5. 화살표 함수ES6에서 새롭게 도입된 화살표 함수(Arrow function)는 function 키워드 대신 화살표(=&gt;, Fat arrow)를 사용하여 보다 간략한 방법으로 함수를 선언할 수 있다. 화살표 함수는 항상 익명 함수로 정의한다. 1234// 화살표 함수const add = (x, y) =&gt; x + y;console.log(add(2, 5)); // 7 화살표 함수는 생성자 함수로 사용할 수 없으며 기존의 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않는다. 5. 함수 호출함수는 함수를 가리키는 식별자와 한 쌍의 소괄호인 함수 호출 연산자로 호출한다.함수 호출 연산자 내에는 0개 이상의 인수(argument)를 쉼표로 구분하여 나열한다. 함수를 호출하면 현재의 실행 흐름을 중단하고 호출된 함수로 컨트롤을 넘긴다. 5.1. 매개변수와 인수함수의 실행을 위해 필요한 값을 함수 외부에서 함수 내부로 전달할 필요가 있는 경우, 매개변수(parameter, 인자)를 통해 인수(argument)를 전달한다. 인수는 값으로 평가될 수 있는 표현식이어야 하며 인수는 함수를 호출할 때 지정하며 개수와 타입에 제한이 없다. 12345678// 함수 선언문function add(x, y) { return x + y;}// 함수 호출// 인수 1과 2는 매개변수 x와 y에 순서대로 할당되고 함수 몸체의 문들이 실행된다.var result = add(1, 2); 매개변수는 함수를 정의할 때 선언하며 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 생성되고 일반 변수와 마찬가지로 undefined로 초기화된 이후 인수가 순서대로 할당된다. 함수가 호출될 때마다 매개변수는 이와 같은 단계를 거친다. 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다.즉, 매개변수의 스코프(유효 범위)는 함수 내부이다. 123456789function add(x, y) { console.log(x, y); // 2 5 return x + y;}add(2, 5);// 함수 add의 매개변수 x, y는 함수 몸체 내부에서만 참조할 수 있다.console.log(x, y); // ReferenceError: x is not defined; 함수는 매개변수의 개수와 인수의 개수를 체크하지 않는다. 즉, 함수를 호출할 때 매개변수의 개수만큼 인수를 전달하는 것이 일반적이지만 그렇지 않은 경우에도 에러가 발생하지는 않는다. 인수가 부족하여 인수가 할당되지 않은 매개변수의 값은 undefined이다. 12345function add(x, y) { return x + y;}console.log(add(2)); // NaN 위 예제의 매개변수 x에는 인수 2가 전달되지만, 매개변수 y에는 전달할 인수가 없다. 따라서 매개변수 y는 undefined가 초기화된 상태 그대로이다. 따라서 함수 몸체의 문 x + y는 2 + undefined와 같으므로 NaN이 반환된다. 인수가 매개변수보다 더 많은 경우, 초과되는 인수는 무시된다. 12345function add(x, y) { return x + y;}console.log(add(2, 5, 10)); // 7 사실 초과된 인수가 그냥 버려지는 것은 아니다. 모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다. 12345678function add(x, y) { console.log(arguments); // Arguments(3) [2, 5, 10, callee: ƒ, Symbol(Symbol.iterator): ƒ] return x + y;}add(2, 5, 10); arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다. 5.2. 인수 확인아래 예제를 살펴보자. 123function add(x, y) { return x + y;} 위 함수를 정의한 개발자의 의도는 아마도 2개의 숫자 타입 인수를 전달받아 그 합계를 반환하려는 것으로 추측된다. 하지만 코드상으로는 어떤 타입의 인수를 전달하여야 하는지, 어떤 타입의 값을 반환해야 하는지 명확하지 않다. 따라서 위 함수는 아래와 같이 호출될 수 있다. 123456function add(x, y) { return x + y;}console.log(add(2)); // NaNconsole.log(add('a', 'b')); // 'ab' 위 코드는 자바스크립트 문법상 어떠한 문제도 없으므로 자바스크립트 엔진은 아무런 이의 제기없이 위 코드를 실행할 것이다. 이러한 상황이 발생한 이유는 아래와 같다. 자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다. 자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다. 따라서 자바스크립트의 경우, 함수를 정의할 때 적절한 인수가 전달되었는지 확인이 필요하다. 12345678910function add(x, y) { if (typeof x !== 'number' || typeof y !== 'number') { throw new TypeError('매개변수에 숫자 타입이 아닌 값이 할당되었습니다.'); } return x + y;}console.log(add(2)); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다.console.log(add('a', 'b')); // TypeError: 매개변수에 숫자 타입이 아닌 값이 할당되었습니다. 5.3. 매개변수의 최대 개수ECMAScript 사양에서는 매개변수의 최대 개수에 명시적으로 제한하고 있지 않다.매개변수는 순서에 의미가 있다. 따라서 매개변수가 많아지면 함수를 호출할 때 전달해야 할 인수의 순서를 고려해야 한다. 이는 함수의 사용 방법을 어렵게 만들고 실수를 발생시킬 가능성을 높인다.따라서 매개변수는 최대 3개 이상을 넘지 않는 것을 권장한다. 객체를 인수로 사용하는 경우, 프로퍼티 키만 정확히 지정하면 매개변수의 순서를 신경쓰지 않아도 된다. 또한 명시적으로 값의 의미를 설명하는 프로퍼티 키를 사용하게 되므로 코드의 가독성도 좋아지고 실수도 줄어드는 효과가 있다.하지만 주의할 것은 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 함수 외부의 객체가 변경되는 부수 효과(side-effect)가 발생한다는 것이다. 5.4. 반환문함수는 return 키워드와 반환값으로 이루어진 반환문을 사용하여 실행 결과를 함수 외부로 반환(return)할 수 있다. 12345678function multiply(x, y) { return x * y; // 값의 반환}// 함수는 반환값으로 평가된다.var result = multiply(3, 5);console.log(result); // 15 multiply 함수는 두개의 인수를 전달받아서 곱한 결과값을 반환한다. 반환값은 return 키워드를 사용해 반환한다. 함수는 return 키워드를 사용해 자바스크립트에서 사용 가능한 모든 값을 반환할 수 있다. “5.3. 표현식”에서 살펴보았듯이 함수 호출은 표현식이다. 이때 함수 호출 표현식은 return 키워드가 반환한 값, 즉 반환값으로 평가된다. 반환문은 두가지 역할을 한다. 첫번째, 반환문은 함수의 실행을 중단하고 함수 몸체를 빠져나간다. 따라서 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다. 1234567function multiply(x, y) { return x * y; // 반환문 // 반환문 이후에 다른 문이 존재하면 그 문은 실행되지 않고 무시된다. console.log('실행되지 않는다.');}console.log(multiply(3, 5)); // 15 두번째, 반환문은 return 키워드 뒤에 지정한 값을 반환한다. return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다. 123456function foo () { // return 키워드 뒤에 반환값을 명시적으로 지정하지 않으면 undefined가 반환된다. return;}console.log(foo()); // undefined 함수는 반환문을 생략할 수 있다. 이때 함수는 함수 몸체의 마지막 문까지 실행한 후 암묵적으로 undefined를 반환한다. 12345function foo () { // 반환문을 생략하면 암묵적으로 undefined가 반환된다.}console.log(foo()); // undefined return 키워드와 반환값 사이에 줄바꿈이 있으면 의도치 않은 결과가 발생할 수 있다. 1234567function multiply(x, y) { // return 키워드와 반환값 사이에 줄바꿈이 있으면 return // 세미콜론 자동 삽입 기능(ASI)에 의해 세미콜론이 추가된다. x * y; // 무시된다.}console.log(multiply(3, 5)); // undefined 6. 참조에 의한 전달과 외부 상태의 변경원시 값은 값에 의한 전달(Pass by value), 객체는 참조에 의한 전달(Pass by reference) 방식으로 동작한다. 매개변수도 함수 몸체 내부에서 변수와 동일하게 취급되므로 매개변수 또한 타입에 따라 값에 의한 전달, 참조에 의한 전달 방식을 그대로 따른다. 123456789101112131415161718192021// 매개변수 primitive는 원시값을 전달받고, 매개변수 obj는 객체를 전달받는다.function changeVal(primitive, obj) { primitive += 100; obj.name = 'Kim';} // 외부 상태 var num = 100; var person = { name: 'Lee' }; console.log(num); // 100 console.log(person); // {name: 'Lee'} // 원시값은 값 자체가 복사되어 전달되고 객체는 참조값이 복사되어 전달된다. changeVal(num, person); // 원시 값은 원본이 훼손되지 않는다. console.log(num); // 100 // 객체는 원본이 훼손된다. console.log(person); // {name: 'Kim'} 원시 타입 인수는 값 자체가 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 그 값을 변경(재할당을 통한 교체)하여도 원본은 훼손되지 않는다. 다시 말해 외부 상태, 즉 함수 외부에서 함수 몸체 내부로 전달한 원시값의 원본을 변경하는 어떠한 부수 효과(side-effect)도 발생하지 않는다. 객체 타입 인수는 참조값이 복사되어 매개변수에 전달되기 때문에 함수 몸체에서 참조값을 통해 참조한 객체를 변경할 경우 원본이 훼손된다. 다시 말해 외부 상태, 즉 함수 외부에서 함수 몸체 내부로 전달한 참조값에 의해 원본 객체가 변경되는 부수 효과가 발생한다. 객체의 변경을 추적하려면 Observer 패턴등을 통해 객체를 참조를 공유하는 모든 이들에게 변경 사실을 통지하고 이에 대처하는 추가 대응이 필요하다. 이러한 문제의 해결 방법 중 하나는 객체를 불변 객체로 만들어 사용하는 것이다.객체의 복사본을 새롭게 생성하는 비용은 들지만 객체를 마치 원시 값처럼 변경 불가능한 값으로 동작하게 만드는 것이다. 이를 통해 객체의 상태 변경을 원천봉쇄하고 객체의 상태 변경이 필요한 경우에는 참조가 아닌 객체의 방어적 복사(defensive copy)를 통해 원본 객체를 완전히 복제, 즉 깊은 복사(Deep copy)(깊은 복사에 대해서는 Deep copying in JavaScript를 참고합시다.)를 통해 새로운 객체를 생성하여 재할당을 통해 교체한다. 이를 통해 외부 상태가 변경되는 부수 효과를 없앨 수 있다. 외부 상태를 변경하지 않고 의존하지도 않는 함수를 순수 함수라 한다. 순수 함수를 통해 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 프로그래밍 패러다임을 함수형 프로그래밍이라 한다. 7. 다양한 함수의 형태 7.1. 즉시실행함수함수 정의와 동시에 즉시 호출되는 함수를 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)라고 한다. 즉시 실행 함수는 단 한번만 호출되며 다시 호출할 수는 없다. 따라서 즉시 실행 함수는 함수 이름이 없는 익명 함수를 사용하는 것이 일반적이다. 1234567// 익명 즉시 실행 함수(function () { var a = 3; var b = 5; return a * b;}()); 함수 이름이 있는 기명 즉시 실행 함수도 사용할 수 있다. 하지만 그룹 연산자(…) 내의 기명 함수는 함수 선언문이 아니라 함수 리터럴로 평가되며 함수 이름은 함수 몸체에서만 참조할 수 있는 식별자이므로 즉시 실행 함수를 다시 호출할 수는 없다. 123456789// 기명 즉시 실행 함수(function foo() { var a = 3; var b = 5; return a * b;}());foo(); // ReferenceError: foo is not defined 즉시 실행 함수는 반드시 그룹 연산자 (…)로 감싸 주어야 한다. 그렇지 않으면 아래와 같이 에러가 발생한다. 123function () { // SyntaxError: Function statements require a function name // ...}(); 위 예제에서 에러가 발생하는 이유는 함수 정의가 함수 선언문의 형식에 맞지 않기 때문이다. 함수 선언문은 함수 이름을 생략할 수 없다. 그렇다면 기명 함수를 정의하여 그룹 연산자 없이 즉시 호출해보자. 123function foo() { // ...}(); // SyntaxError: Unexpected token ')' 위 예제에서도 에러가 발생한다. 그 이유는 자바스크립트 엔진이 암묵적으로 수행하는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)에 의해 함수 선언문이 끝나는 위치, 즉 함수 코드 블록의 닫는 중괄호 뒤에 “;”이 암묵적으로 추가되기 때문이다. 1function foo() {}(); // =&gt; function foo() {};(); 따라서 함수 선언문 뒤의 그룹 연산자에 피연산자가 없기 때문에 에러가 발생한다. 1(); // SyntaxError: Unexpected token ) 그룹 연산자의 피연산자는 값으로 평가되므로 기명 또는 무명 함수를 그룹 연산자로 감싸면 함수 리터럴로 평가되어 함수 객체가 된다. 12console.log(typeof (function f(){})); // functionconsole.log(typeof (function (){})); // function 즉, 그룹 연산자로 함수를 묶은 이유는 먼저 함수를 평가하여 함수 객체를 생성하기 위함이다. 따라서 먼저 함수를 평가하여 함수 객체를 생성할 수 있다면 아래와 같이 그룹 연산자 이외의 연산자를 사용할 수도 있다. 가장 일반적인 방법은 첫번째 방식이다. 이 책에서는 첫번째 방식을 사용하도록 하겠다. 123456789101112131415(function () { // ...}());(function () { // ...})();!function () { // ...}();+function () { // ...}(); 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다. 12345678910111213141516// 즉시 실행 함수도 일반 함수처럼 값을 반환할 수 있다.var res = (function () { var a = 3; var b = 5; return a * b;}());console.log(res); // 15//즉시 실행 함수에도 일반 함수처럼 인수를 전달할 수 있다.res = (function (a, b) { return a * b;}(3, 5));console.log(res); // 15 7.2. 재귀 함수함수가 자기 자신을 호출하는 것을 재귀 호출이라 한다. 재귀 함수는 자기 자신을 호출하는 행위, 즉 재귀 호출을 수행하는 함수를 말한다. 재귀 호출을 통해 반복 연산을 간단하게 구현할 수 있다. 123456789101112131415// 팩토리얼(계승)은 1부터 자신까지의 모든 양의 정수의 곱이다.// n! = 1 * 2 * ... * (n-1) * nfunction factorial(n) { // 탈출 조건: n이 1 이하일 때 재귀 호출을 멈춘다. if (n &lt;= 1) return 1; // 재귀 호출 return n * factorial(n - 1);}console.log(factorial(0)); // 0! = 1console.log(factorial(1)); // 1! = 1console.log(factorial(2)); // 2! = 2 * 1 = 2console.log(factorial(3)); // 3! = 3 * 2 * 1 = 6console.log(factorial(4)); // 4! = 4 * 3 * 1 * 1 = 24console.log(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120 재귀 함수는 자신을 무한 재귀 호출한다. 따라서 재귀 함수 내에는 재귀 호출을 멈출 수 있는 탈출 조건을 반드시 만들어야 한다. 위 예제의 경우 인수가 1 이하일 때 재귀 호출을 멈춘다. 탈출 조건이 없는 경우, 함수가 무한 호출되어 stack overflow 에러가 발생한다. factorial 함수 내부에서 자기 자신을 호출할 때 사용한 식별자 factorial은 함수 이름이다. 함수 이름은 함수 몸체 내부에서만 유효하다. 따라서 함수 내부에서는 함수 이름을 사용하여 자기 자신을 호출할 수 있다. 함수 표현식으로 정의한 함수 내부에서는 함수 이름은 물론 함수를 가리키는 식별자로도 자기 자신을 재귀 호출할 수 있다. 단, 함수 호출은 반드시 함수를 가리키는 식별자로 해야 한다. 1234567891011121314// 함수 표현식var factorial = function foo(n) { // 탈출 조건: n이 1 이하일 떄 재귀 호출을 멈춘다. if (n &lt; 1) return 1; // 함수를 가리키는 식별자로 자기 자신을 재귀 호출 return n * factorial( n - 1 ); // 함수 이름으로 자기 자신을 재귀 호출할 수도 있다. // console.log(factorial === foo); // true // return n * foo( n - 1 );}console.log(factorial(5)); // 5! = 5 * 4 * 3 * 2 * 1 = 120 대부분의 재귀함수는 for나 while문으로 구현할 수 있다.재귀 함수는 반복 연산을 간단히 구현할 수 있다는 장점이 있지만 무한 반복에 빠질 수 있고, 이로 인해 stack overflow 에러를 발생시킬 수 있으므로 주의해서 사용해야 한다. 따라서 재귀 함수는 반복문을 사용하는 것 보다 재귀 함수를 사용하는 것이 보다 직관적으로 이해하기 쉬울 때에만 한정적으로 사용하는 것이 바람직하다. 7.3. 중첩 함수함수 내부에 정의된 함수를 중첩 함수(nested function) 또는 내부 함수(inner function)라 한다. 그리고 중첩 함수를 포함하는 함수는 외부 함수(outer function)라 부른다. 일반적으로 중첩 함수는 자신을 포함하는 외부 함수를 돕는 헬퍼 함수(helper function)의 역할을 한다. 1234567891011121314function outer() { var x = 1; // 중첩 함수 function inner() { var y = 2; // 외부 함수의 변수를 참조할 수 있다. console.log(x + y); // 3 } inner();}outer(); ES6부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다. 함수 선언문의 경우, ES6 이전에는 코드의 최상위 또는 다른 함수 내부에서만 정의할 수 있었으나 ES6부터는 if 문이나 for 문 등의 코드 블록 내에서도 정의할 수 있다. 단, 호이스팅으로 인해 혼란이 발생할 수 있으므로 if 문이나 for 문 등의 코드 블록에서 함수 선언문을 통해 함수를 정의하는 것은 바람직하지 않다. 중첩 함수는 스코프와 클로저에 깊은 관련이 있다. 이에 대해서는 나중에 자세히 살펴보도록 하자. 7.4. 콜백 함수어떤 일을 반복 수행하는 repeat 함수를 정의해 보자. 12345678910111213141516171819// n만큼 어떤 일을 반복한다function repeat(n) { // i를 출력한다. for (var i = 0; i &lt; n; i++) { console.log(i); }} repeat(5); // 0 1 2 3 4// n만큼 어떤 일을 반복한다function repeat2(n) { for (var i = 0; i &lt; n; i++) { // i가 홀수일 때만 출력한다. if (i % 2) console.log(i); }}repeat2(5); // 1 3 위 repeat 함수는 경우에 따라 변경되는 일을 함수 f로 추상화하였고 이를 외부에서 전달받는다. 자바스크립트의 함수는 일급 객체이므로 함수의 매개변수를 통해 함수를 전달할 수 있다. repeat 함수는 더 이상 내부 로직에 강력히 의존하지 않고 외부에서 로직의 일부분을 함수로 전달받아 수행하므로 보다 유연한 구조를 갖게 되었다. 이처럼 함수의 매개변수를 통해 전달되는 함수를 콜백 함수(Callback function)라고 하며, 콜백 함수를 매개변수를 통해 전달받은 함수를 고차 함수(Higher-Order Function, HOF)라고 한다. 중첩 함수가 외부 함수를 돕는 헬퍼 함수의 역할을 하는 것처럼 콜백 함수도 고차 함수에 전달되어 헬퍼 함수의 역할을 한다. 단, 중첩 함수는 고정되어 있어서 교체하기 곤란하지만 콜백 함수는 함수 외부에서 고차 함수 내부로 주입하기 때문에 자유롭게 교체할 수 있다는 장점이 있다. 즉, 고차 함수는 콜백 함수를 자신의 일부분으로 합성한다. 고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정하여 호출한다. 다시 말해, 콜백 함수는 고차 함수에 의해 호출되며 이때 필요에 따라 인수도 전달될 수 있다. 따라서 고차 함수에 콜백 함수를 전달할 때, 콜백 함수를 호출하지 않고 함수 자체를 전달해야 한다. 콜백 함수가 고차 함수 내부에만 호출된다면 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다. 12345// 익명 함수 리터럴을 콜백 함수로 매개변수에 전달한다.// 익명 함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다.repeat(5, function (i) { if (i % 2) console.log(i);}); // 1 3 이때 콜백 함수로서 전달된 함수 리터럴은 고차 함수가 호출될 때마다 평가되어 함수 객체를 생성한다. 따라서 콜백 함수를 다른 곳에서도 호출할 필요가 있거나, 콜백 함수를 전달받는 함수가 자주 호출된다면 함수 외부에서 콜백 함수를 정의한 후 함수 참조를 고차 함수에 전달하는 편이 효율적이다. 1234567// logOdds 함수는 단 한번만 생성된다.var logOdds = function (i) { if (i % 2) console.log(i);};// 고차 함수에 함수 참조를 전달한다.repeat(5, logOdds); // 1 3 위 예제의 logOdds 함수는 단 한번만 생성된다. 하지만 콜백 함수를 익명 함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하면 고차 함수가 호출될 때마다 콜백 함수가 생성된다. 콜백 함수는 일반적으로 비동기 처리(이벤트 처리, Ajax 통신, Timer 함수 등)을 위해 사용하는 중요한 패턴이다. 1234567891011// 콜백 함수를 사용한 이벤트 처리// myButton 버튼을 클릭하면 콜백 함수를 실행한다.document.getElementById('myButton').addEventListener('click', function () { console.log('button clicked!');});// 콜백 함수를 사용한 비동기 처리// 1초 후에 메시지를 출력한다.setTimeout(function () { console.log('1초 경과');}, 1000); 콜백 함수는 비동기 처리 뿐 만 아니라 배열 고차 함수에서도 사용된다. 자바스크립트에서 배열은 사용 빈도가 매우 높은 자료 구조이고 배열을 다룰 때 배열 고차 함수는 매우 중요하다. 이에 대해서는 “27.9. 배열 고차 함수”에서 자세히 살펴볼 것이다. 12345678910111213// 콜백 함수를 사용하는 고차 함수 mapvar res = [1, 2, 3].map(function (item) { return item * 2;});console.log(res); // [2, 4, 6]// 콜백 함수를 사용하는 고차 함수 filterres = [1, 2, 3].filter(function (item) { return item % 2;});console.log(res); // [1, 3] 7.5. 순수 함수와 비순수 함수순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환하는 함수를 말한다. 즉, 순수 함수는 어떤 외부 상태에도 의존하지 않고 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존하여 반환값을 만든다.순수 함수의 또 하나의 특징은 함수의 외부 상태를 변경하지 않는다는 것이다. 1234567891011121314var conut = 0; // 현재 카운트를 나타내는 상태// 외부 상태에 의존하지 않으며 변경하지도 않는 순수 함수// 순수 함수는 동일한 인수가 전달되면 언제나 동일한 값을 반환한다.function increase(n) { return ++n;}// 순수 함수가 반환한 결과값을 변수에 재할당하여 상태를 변경conut = increase(conut);console.log(conut); // 1conut = increase(conut);console.log(conut); // 2 반대로 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 함수를 비순수 함수라고 한다. 비순수 함수의 또 하나의 특징은 순수 함수와는 달리 함수의 외부 상태를 변경하는 부수 효과(side effect)가 있다는 것이다. 1234567891011121314var count = 0; // 현재 카운트를 나타내는 상태: increase 함수에 의해 변화한다.// 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 비순수 함수// 비순수 함수는 외부 상태를 변경하는 부수 효과(side effect)가 있다.function increase() { return ++count; // 외부 상태를 변경한다.}// 비순수 함수는 외부 상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다.increase();console.log(count); // 1increase();console.log(count); // 2 함수가 외부 상태를 변경하면 상태 변화를 추적하기 어려워진다. 따라서 함수 외부 상태의 변경을 지양하는 순수 함수를 사용하는 것이 좋다. 위 예제의 increase 함수와 같은 비순수 함수는 코드의 복잡성을 증가시킨다. 비순수 함수를 최대한 줄이는 것은 부수 효과를 최대한 억제하는 것과 같다. 함수형 프로그래밍은 변수의 사용을 억제하여 상태 변경을 최대한 억제하고 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하려는 프로그래밍 패러다임이다. 변수 값은 누군가에 의해 언제든지 변경될 수 있고, 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 만들어 가독성을 해치고 오류 발생의 근본적 원인이 될 수 있기 때문이다. 함수형 프로그래밍은 결국 순수 함수를 통해 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이려는 노력의 한 방법이라고 할 수 있다. 이 책에서는 함수형 프로그래밍을 다루지는 않는다. 하지만 자바스크립트는 멀티 패러다임 언어이며 객체지향 프로그래밍 뿐만 아니라 부분적으로 함수형 프로그래밍을 적극적으로 활용하고 있다. 먼저 자바스크립트의 기본 개념과 동작 원리를 이해하고 함수형 프로그래밍에 대해 추가적인 학습을 권장한다.","link":"/2020/02/function/"},{"title":"깃 시작하기 | git & github","text":"깃으로 무엇을 할 수 있을까? 1. 버전 관리깃은 문서를 수정할 떄마다 언제 수정했는지, 어떤 것을 변경했는지 편하고 구체적으로 기록하기 위한 버전 관리 시스템입니다. 2. 백업하기 컴퓨터는 언젠가는 고장날 수 있는 불확실성을 가지고 있기 떄문에 우리는 구글드라이브나 드롭박스같은 인터넷 서비스를 사용합니다.백업 공간을 제공하는 인터넷 서비스 중에는 깃 파일을 위한 것도 여럿 있다. 이를 깃의 원격 저장소 또는 온라인 저장소라고 한다. 이러한 서비스 중 가장 많이 쓰이는 것이 바로 깃허브(GitHub)입니다. 3. 협업하기 깃허브와 같은 온라인 서비스를 사용하면 여러 사람이 함께 일할 수 있다는 강력한 장점이 생깁니다. 예를 들어 팀원 둘이서 작업을 할 경우 팀원 A가 작업을 해서 원격 저장소에 올리면 원격 저장소에 있는 문서를 팀원 B가 내려받아 작업하고, 작업이 끝나면 그 결과를 다시 원격 저장소에 올릴 수 있습니다. 이처럼 깃을 사용하면 팀원들이 파일을 서로 편하게 주고 받을 수 있어서 협업에 도움이 됩니다. 깃 설치하기Window에서는 Gitbash 사이트 가서 다운받으면 됨. Mac에서는 터미널에 기본적으로 내장되어 있어서 git이라고 입력하면 자동으로 다운됨(2020 기준) 1$ git 깃 환경 설정하기 터미널 창을 열고 아래 코드를 칩니다. 12$ git config --global user.name \"namkwon\" // 이름 저장$ git config --global user.mail \"namkwon12@gmail.com\" // 메일 저장 리눅스 명령 ‘pwd’명령은 현재 위치 경로가 나타남 1$ pwd 현재 디렉터리에 어떤 파일이나 디렉터리가 있는지 확인할 떄는 ‘ls’명령 1$ ls 리눅스 명령에 옵션을 추가하려면 붙임표(-)와 원하는 옵션을 나타내는 글자를 함께 입력한다.파일과 디렉터리 상세정보를 표시하려면 ls 뒤에 ‘-l’을 추가입력한다.숨긴 파일가 디렉터리까지 보고싶으면 ‘-a’를 추가 입력한다. 두 옵션을 함께 사용하고 싶으면 ‘-la’ 또는 ‘-al’ 12$ ls -la$ ls -al 터미널 창에서 디렉터리 이동하기 현재위치에서 상위 디렉터리로 이동하려면 ‘cd’명령 후에 space하고 ‘..’을 붙여주면 됨 1$ cd.. 가고 싶은 디렉터리로 이동하기 싶으면 ‘cd’명령 space하고 해당 디렉터리명 입력 1$ cd myFirstGit 터미널 창에서 디렉터리 만들기 및 삭제하기현재 디렉터리 안에 하위 디렉터리를 만들 때는 ‘mkdir’명령을 사용한다. ‘mkdir’뒤에는 자기가 짓고 싶은 디렉터리명 알아서~ 1$ mkdir NETFLIX 디렉터리 삭제 방법은 ‘rm’명령어이다. 이떄 ‘-r’ 옵션을 붙이면 디렉터리 안에 있는 하위 디렉터리와 파일까지 함께 삭제된다~ 1$ rm -r NETFLIX Vim에서 텍스트 문서 만들기 vim 명령어를 이용해서 텍스트를 만들어 볼게요. 1$ vim test.txt 이렇게 되면 빔문서가 열리는데 빔에는 문서를 작성하는 ‘입력모드’와 문서를 저장하는 ‘ex모드’가 있음. 빔은 처음에 ‘ex모드’로 열려서 키를 눌러도 반응이 없음. 빔에서 텍스트를 입력하려면 ex모드에서 I나 A를 눌러 입력모드로 바꿔야함. 입력 다 하고 저장하고 싶으면 ESC를 누르면됨. 그러면 ex모드로 돌아감 그 상태에서 저장하고 종료하고 싶으면 ‘:wq’명령을 입력하고 ENTER 누르면 됩니다. ‘w’는 저장을 의미하고 ‘q’는 종료를 의미한다. 텍스트 문서 내용 확인하기아까 만든 test.txt를 터미널에서 간단히 확인하고 싶을 때 ‘cat’명령어를 사용한다. 터미널 창에 나타날 것임!! 1$ cat test.txt","link":"/2020/04/git01/"},{"title":"let과 const | javaScript","text":"var 키워드로 선언한 변수의 문제점ES5까지 변수를 선언할 수 있는 유일한 방법은 var 키워드를 사용하는 것이었다. var 키워드로 선언된 변수는 아래와 같은 특징이 있다. 이는 다른 언어와는 구별되는 독특한 특징으로 주의를 기울이지 않으면 심각한 문제를 발생시킬 수 있다.. 1.1. 변수 중복 선언 허용var 키워드로 선언한 변수는 중복 선언이 가능하다. 아래 예제를 살펴보자. 12345var x = 1;// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.// 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.var x = 100;console.log(x); // 100 위 예제의 변수 x는 중복 선언되었다. 이처럼 같은 스코프 내에서 변수를 중복 선언하면 나중에 작성된 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다. 이때 에러는 발생하지 않는다. 위 예제와 같이 만약 동일한 변수 이름이 이미 선언되어 있는 것을 모르고 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수값이 변경되는 부작용이 발생한다. 따라서 변수의 중복 선언은 문법적으로 허용되지만 사용하지 않는 것이 좋다. 1.2. 함수 레벨 스코프var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 따라서 함수 외부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언하여도 모두 전역 변수가 된다. 123456789var x = 1;if (true) { // x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 변수 x는 중복 선언된다. // 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다. var x = 10;}console.log(x); // 10 for 문의 변수 선언문에서 var 키워드로 선언한 변수도 전역 변수가 된다. 123456789var i = 10;// for문에서 선언한 i는 전역 변수이다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.for (var i = 0; i &lt; 5; i++) { console.log(i); // 0 1 2 3 4}// 의도치 않게 변수의 값이 변경되었다.console.log(i); // 5 함수 레벨 스코프는 전역 변수를 남발할 가능성을 높인다. 이로 인해 의도치 않게 전역 변수가 중복 선언되는 경우가 발생한다. 1.3. 변수 호이스팅var 키워드로 변수를 선언하면 변수 호이스팅에 의해 변수 선언문이 스코프의 선두로 끌어 올려진 것처럼 동작한다. 즉, 변수 호이스팅에 의해 var 키워드로 선언한 변수는 변수 선언문 이전에 참조할 수 있다. 단, 할당문 이전에 변수를 참조하면 언제나 undefined를 반환한다. 1234567891011// 이 시점에는 변수 호이스팅에 의해 이미 변수 foo가 선언되었다. (1. 선언 단계)// 변수 foo는 undefined로 초기화된다. (2. 초기화 단계)console.log(foo); // undefined// 변수에 값을 할당 (3. 할당 단계)foo = 123;console.log(foo); // 123// 변수 선언은 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 실행된다.var foo; 변수 선언문 이전에 변수를 참조하는 것은 변수 호이스팅에 의해 에러를 발생시키지는 않지만 프로그램의 흐름 상 맞지 않을 뿐더러 가독성을 떨어뜨리고 오류를 발생시킬 여지를 남긴다. 2. let 키워드앞에서 살펴본 var 키워드의 단점을 보완하기 위해 ES6에서는 새로운 변수 선언 키워드 let과 const를 도입하였다. var 키워드와의 차이점을 중심으로 let 키워드에 대해 살펴보자. 2.1. 변수 중복 선언 금지var 키워드로 동일한 이름을 갖는 변수를 중복 선언하면 아무런 에러가 발생하지 않는다. 이때 변수를 중복 선언하면서 값까지 할당했다면 의도치 않게 먼저 선언된 변수값이 재할당되어 변경되는 부작용이 발생한다. 하지만 let 키워드로 동일한 이름을 갖는 변수를 중복 선언하면 문법 에러(SyntaxError)가 발생한다. 12345678var foo = 123;// var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다.// 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다.var foo = 456;let bar = 123;// let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다.let bar = 456; // SyntaxError: Identifier 'bar' has already been declared 2.2. 블록 레벨 스코프var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정하는 함수 레벨 스코프를 따른다. 하지만 let 키워드로 선언한 변수는 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 을 지역 스코프로 인정하는 블록 레벨 스코프(Block-level scope)를 따른다. 아래 예제를 살펴보자. 123456789let foo = 123; // 전역 변수{ let foo = 456; // 지역 변수 let bar = 456; // 지역 변수}console.log(foo); // 123console.log(bar); // ReferenceError: bar is not defined let 키워드로 선언된 변수는 블록 레벨 스코프를 따른다. 따라서 위 예제에서 코드 블록 내에 선언된 변수 foo와 지역 변수이다. 전역에서 선언된 변수 foo와는 다른 별개의 변수이다. 또한 변수 bar도 블록 레벨 스코프를 갖는 지역 변수이다. 따라서 전역에서는 변수 bar를 참조할 수 없다. 함수도 코드 블록이므로 스코프를 만든다. 이때 함수 내의 코드 블록은 함수 레벨 스코프에 중첩된다. 블록 레벨 스코프의 중첩 2.3. 변수 호이스팅var 키워드로 선언한 변수와는 달리 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 동작한다. 아래 예제를 살펴보자. 123console.log(foo); // ReferenceError: foo is not definedlet foo;이처럼 let 키워드로 선언한 변수를 변수 선언문 이전에 참조하면 참조 에러(ReferenceError)가 발생한다. “4.3. 변수 선언”에서 살펴본 바와 같이 var 키워드로 선언한 변수는 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 “선언 단계”와 “초기화 단계”가 한번에 진행된다. 즉, 선언 단계에서 스코프(실행 컨텍스트의 렉시컬 환경(Lexical Environment))에 변수 식별자를 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 그리고 즉시 초기화 단계에서 undefined로 변수를 초기화한다. 따라서 변수 선언문 이전에 변수에 접근하여도 스코프에 변수가 존재하기 때문에 에러가 발생하지 않는다. 다만 undefined를 반환한다. 이후 변수 할당문에 도달하면 비로소 값이 할당된다. 123456789// var 키워드로 선언한 변수는 런타임 이전에 선언 단계와 초기화 단계가 실행된다.// 따라서 변수 선언문 이전에 변수를 참조할 수 있다.console.log(foo); // undefinedvar foo;console.log(foo); // undefinedfoo = 1; // 할당문에서 할당 단계가 실행된다.console.log(foo); // 1 var 키워드로 선언한 변수의 생명 주기 let 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행된다. 즉, 런타임 이전에 자바스크립트 엔진에 의해 암묵적으로 선언 단계가 먼저 실행되지만 초기화 단계는 변수 선언문에 도달했을 때 실행된다. 만약 초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다. 따라서 스코프의 시작 지점부터 초기화 단계 시작 지점(변수 선언문)까지는 변수를 참조할 수 없다. 스코프의 시작 지점부터 초기화 시작 지점까지의 구간을 일시적 사각지대(Temporal Dead Zone; TDZ)라고 부른다. 123456789// 런타임 이전에 선언 단계가 실행된다.// 아직 변수가 초기화되지 않았다. 따라서 변수 선언문 이전에 변수를 참조할 수 없다.console.log(foo); // ReferenceError: foo is not definedlet foo; // 변수 선언문에서 초기화 단계가 실행된다.console.log(foo); // undefinedfoo = 1; // 할당문에서 할당 단계가 실행된다.console.log(foo); // 1 let 키워드로 선언한 변수의 생명 주기 결국 let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 보인다. 하지만 그렇지 않다. 아래 예제를 살펴보자. 123456let foo = 1; // 전역 변수{ console.log(foo); // ReferenceError: foo is not defined let foo = 2; // 지역 변수} let 키워드로 선언한 변수의 경우, 변수 호이스팅 발생하지 않는다면 위 예제는 전역 변수 foo의 값을 출력해야 한다. 하지만 let 키워드로 선언한 변수도 여전히 호이스팅이 발생하기 때문에 참조 에러(ReferenceError)가 발생한다. 자바스크립트는 ES6에서 도입된 let, const를 포함하여 모든 선언(var, let, const, function, function*, class 등)을 호이스팅한다. 단, ES6에서 도입된 let, const, class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다. 2.4. 전역 객체와 let전역 객체(Global Object, “21.4. 전역 객체” 참고)는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다. 전역 객체는 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 가리킨다. var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역(“21.4.3. 암묵적 전역” 참고) 그리고 전역 함수는 전역 객체의 프로퍼티가 된다. 전역 객체의 프로퍼티를 참조할 때 window를 생략할 수 있다. 1234567891011121314151617181920212223242526272829// 이 예제는 브라우저 환경에서 실행시켜야 한다.// 전역 변수var x = 1;// 암묵적 전역y = 2;function foo() {}// var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티이다.console.log(window.x); // 1// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.console.log(x); // 1// 암묵적 전역은 전역 객체의 프로퍼티이다.console.log(window.y); // 2console.log(y); // 2// 함수 선언문으로 정의한 전역 함수는 전역 객체의 프로퍼티이다.console.log(window.foo); // ƒ foo() {}// 전역 객체의 프로퍼티는 전역 변수처럼 사용할 수 있다.console.log(foo); // ƒ foo() {}let 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티가 아니다. 즉, window.foo와 같이 접근할 수 없다. let 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드. 이에 대해서는 “23. 실행 컨텍스트”에서 자세히 살펴볼 것이다.) 내에 존재하게 된다.// 이 예제는 브라우저 환경에서 실행시켜야 한다.let x = 1;// let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다.console.log(window.x); // undefinedconsole.log(x); // 1 3. const 키워드const 키워드는 상수(constant)를 선언하기 위해 사용한다. 하지만 반드시 상수만을 위해 사용하지는 않는다. 이에 대해서는 후반부에 설명한다. const의 특징은 let과 대부분 동일하므로 let과 다른 점을 중심으로 살펴보도록 하자. 3.1. 선언과 초기화const 키워드로 선언한 변수는 반드시 선언과 동시에 할당이 이루어져야 한다. 123456789101112131415const foo = 1;그렇지 않으면 아래와 같이 문법 에러(SyntaxError)가 발생한다.const foo; // SyntaxError: Missing initializer in const declarationconst 키워드로 선언한 변수는 let 키워드로 선언한 변수와 마찬가지로 블록 레벨 스코프를 가지며 변수 호이스팅이 발생하지 않는 것처럼 동작한다.{ // 변수 호이스팅이 발생하지 않는 것처럼 동작한다 console.log(foo); // ReferenceError: Cannot access 'foo' before initialization const foo = 1; console.log(foo); // 1}// 블록 레벨 스코프를 갖는다.console.log(foo); // ReferenceError: foo is not defined 3.2. 재할당 금지var 또는 let 키워드로 선언한 변수는 재할당이 자유로우나 const 키워드로 선언한 변수는 재할당이 금지된다. 12const foo = 1;foo = 2; // TypeError: Assignment to constant variable. 3.3. 상수const 키워드로 선언한 변수에 원시값을 할당한 경우, 변수값을 변경할 수 없다. 원시값은 변경 불가능한 값(immutable value)이므로 재할당없이 값을 변경할 수 있는 방법이 없기 때문이다. 이러한 특징을 이용해 const 키워드를 상수를 표현하는 데 사용하기도 한다. 변수의 상대 개념인 상수는 재할당이 금지된 변수를 말한다. 상수도 값을 저장하기 위한 메모리 공간이 필요하므로 변수라고 할 수 있다. 단, 변수는 언제든지 재할당을 통해 변수값을 변경할 수 있지만 상수는 재할당이 금지된다. 상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극적으로 사용해야 한다. 아래 예제를 살펴보자. 12345678// 세전 가격let preTaxPrice = 100;// 세후 가격// 0.1의 의미를 명확히 알기 어렵기 때문에 가독성이 좋지 않다.let afterTaxPrice = preTaxPrice + (preTaxPrice * 0.1);console.log(afterTaxPrice); // 110 코드 내에서 사용한 0.1은 어떤 의미로 사용하였는지 명확히 알기 어렵기 때문에 가독성이 좋지 않다. 또한 세율을 의미하는 0.1은 쉽게 바뀌지 않는 값이며 프로그램 전체에서 고정된 값을 사용해야 한다. 이때 세율을 상수로 정의하면 값의 의미를 쉽게 파악할 수 있고 변경될 수 없는 고정값으로 사용할 수 있다. 일반적으로 상수의 이름은 대문자로 선언하여 상수임을 명확히 나타낸다. 여러 단어로 이루어진 경우에는 언더스코어(_)로 구분하여 스네이크 케이스로 표현하는 것이 일반적이다. 1234567891011// 세율을 의미하는 0.1은 변경할 수 없는 상수로서 사용될 값이다.// 변수 이름을 대문자로 선언하여 상수임을 명확히 나타낸다.const TAX_RATE = 0.1;// 세전 가격let preTaxPrice = 100;// 세후 가격let afterTaxPrice = preTaxPrice + (preTaxPrice * TAX_RATE);console.log(afterTaxPrice); // 110 const 키워드로 선언된 변수는 재할당이 금지된다. const 키워드로 선언된 변수에 원시 값을 할당한 경우, 원시 값은 변경할 수 없는 값(immutable value)이고 const 키워드에 의해 재할당이 금지되므로 할당된 값을 변경할 수 있는 방법은 없다. 또한 상수는 프로그램 전체에서 공통 사용하므로 나중에 세율이 변경되면 상수만을 변경하면 되기 때문에 유지보수성이 대폭 향상된다. 3.3. const 키워드와 객체const 키워드로 선언된 변수에 원시값을 할당한 경우, 값을 변경할 수 없다. 하지만 const 키워드로 선언된 변수에 객체를 할당한 경우, 값을 변경할 수 있다. 변경 불가능한 값인 원시값은 재할당없이 변경(교체)할 수 있는 방법이 없지만 변경 가능한 값인 객체는 재할당없이도 직접 변경이 가능하기 때문이다. 12345678const person = { name: 'Lee'};// 객체는 변경 가능한 값이다. 따라서 재할당없이 변경이 가능하다.person.name = 'Kim';console.log(person); // {name: \"Kim\"} “11.1.1. 변경 불가능한 값”에서 살펴본 바와 같이, const 키워드는 재할당을 금지할 뿐 “불변(immutable)”을 의미하지는 않는다. 다시 말해, 새로운 값을 재할당하는 것은 불가능하지만 객체의 내용(프로퍼티의 추가, 삭제, 프로퍼티 값의 변경)을 변경하는 것은 가능하다. 객체의 내용이 변경되더라도 변수에 할당된 참조값은 변경되지 않는다. 4. var vs. let vs. const변수 선언에는 기본적으로 const를 사용하고 let은 재할당이 필요한 경우에 한정해 사용하는 것이 좋다. 원시 값의 경우, 가급적 상수를 사용하는 편이 좋다. 그리고 객체를 재할당하는 경우는 생각보다 흔하지 않다. const 키워드를 사용하면 의도치 않은 재할당을 방지해 주기 때문에 보다 안전하다.var와 let, 그리고 const 키워드는 다음처럼 사용하는 것을 추천한다. ES6를 사용한다면 var 키워드는 사용하지 않는다.재할당이 필요한 경우에 한정해 let 키워드를 사용한다. 이때 변수의 스코프는 최대한 좁게 만든다.변경이 발생하지 않고 읽기 전용으로 사용하는(재할당이 필요 없는 상수) 원시 값과 객체에는 const 키워드를 사용한다. const 키워드는 재할당을 금지하므로 var, let 키워드보다 안전하다.변수를 선언하는 시점에는 재할당이 필요할지 잘 모르는 경우가 많다. 그리고 객체는 의외로 재할당을 하는 경우가 드물다.(Angular, React, Vue.js와 같은 SPA 프레임워크의 경우, 상태가 변경되었음을 알리기 위해 객체를 재할당하는 경우도 있다.) 따라서 변수를 선언할 때에는 일단 const 키워드를 사용하도록 하자. 반드시 재할당이 필요하다면(반드시 재할당이 필요한지 한번 생각해 볼 일이다.) 그때 const 키워드를 let 키워드로 변경해도 결코 늦지 않는다.","link":"/2020/03/let_const/"},{"title":"깃으로 버전 관리하기 | git & github","text":"","link":"/2020/04/git02/"},{"title":"Array HOF 연습 문제 | With javaScript","text":"1. html 생성 아래 배열을 사용하여 html을 생성하는 함수를 작성하라. 1234567891011121314151617181920const todos = [ { id: 3, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: true }, { id: 1, content: 'Javascript', completed: false }];function render() { let html = ''; todos.forEach(function (todo) { html += `&lt;li id=\"${todo.id}\"&gt; &lt;label&gt;&lt;input type=\"checkbox\" ${todo.completed ? \"checked\" : ''}&gt;${todo.content}&lt;/label&gt; &lt;/li&gt; ` }); return html;}console.log(render()); 2. 특정 프로퍼티 값 추출요소의 프로퍼티(id, content, completed)를 문자열 인수로 전달하면 todos의 각 요소 중, 해당 프로퍼티의 값만을 추출한 배열을 반환하는 함수를 작성하라. 단, for 문이나 Array#forEach는 사용하지 않도록 하자. 123456789101112const todos = [ { id: 3, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: true }, { id: 1, content: 'Javascript', completed: false }];function getValues(key) { return todos.map( item =&gt; item[key])}console.log(getValues('id'));console.log(getValues('content')); console.log(getValues('completed')); 3. 프로퍼티 정렬요소의 프로퍼티(id, content, completed)를 문자열 인수로 전달하면 todos의 요소를 정렬하는 함수를 작성하라. 단, todos는 변경되지 않도록 하자. 참고: Array.prototype.sort 1234567891011121314151617const todos = [ { id: 3, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: true }, { id: 1, content: 'Javascript', completed: false }];function sortBy(key) { return todos.sort( (v, i) =&gt; (v[key] &gt; i[key] ? 1 : (v[key] &lt; i[key] ? -1 : 0)) );}console.log(sortBy('completed'));console.log(sortBy('id'));console.log(sortBy('content')); 4. 새로운 요소 추가새로운 요소(예를 들어 { id: 4, content: 'Test', completed: false } )를 인수로 전달하면 todos의 선두에 새로운 요소를 추가하는 함수를 작성하라. 단, Array#push는 사용하지 않도록 하자. 123456789101112let todos = [ { id: 3, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: true }, { id: 1, content: 'Javascript', completed: false }];function addTodo(newTodo) { todos.unshift(newTodo);}addTodo({ id: 4, content: 'Test', completed: false });console.log(todos); 5. 특정 요소 삭제 1234567891011let todos = [ { id: 3, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: true }, { id: 1, content: 'Javascript', completed: false }];function removeTodo(id) { return todos.filter( item =&gt; item.id !== id );}console.log(removeTodo(2)); 6. 특정 요소의 프로퍼티 값 반전 12345678910111213141516171819let todos = [ { id: 3, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: true }, { id: 1, content: 'Javascript', completed: false }];function toggleCompletedById(id) { const boxbox = todos.map( (item) =&gt; { if (item.id == id) item.completed = !item.completed; console.log(item); return item; }); Object.assign(todos, boxbox);}toggleCompletedById(1);console.log(todos); 7. 모든 요소의 completed 프로퍼티 값을 true로 설정todos의 모든 요소의 completed 프로퍼티 값을 true로 설정하는 함수를 작성하라. hint) 기존 객체의 특정 프로퍼티를 변경/추가하여 새로운 객체를 생성하려면 Object.assign 또는 스프레드 문법 을 사용한다. 1234567891011121314151617181920let todos = [ { id: 3, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: true }, { id: 1, content: 'Javascript', completed: false }];function toggleCompletedAll() { const boxbox = todos.map( (item) =&gt; { item.completed = true; console.log(item.completed); console.log(item); return item; }); Object.assign(todos, boxbox);}toggleCompletedAll();console.log(todos); 8. completed 프로퍼티의 값이 true인 요소의 갯수 구하기todos에서 완료(completed: true)한 할일의 갯수를 구하는 함수를 작성하라. 단, for 문, Array#forEach는 사용하지 않도록 하자. 1234567891011let todos = [ { id: 3, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: true }, { id: 1, content: 'Javascript', completed: false }];function countCompletedTodos() { return todos.filter(item =&gt; item.completed === true).length;}console.log(countCompletedTodos()); 9 id 프로퍼티의 값 중에서 최대값 구하기todos의 id 프로퍼티의 값 중에서 최대값을 함수를 작성하라. 단, for 문, Array#forEach는 사용하지 않도록 하자. 1234567891011let todos = [ { id: 3, content: 'HTML', completed: false }, { id: 2, content: 'CSS', completed: true }, { id: 1, content: 'Javascript', completed: false }];function getMaxId() { return Math.max(...todos.map(item =&gt; item.id))}console.log(getMaxId());","link":"/2020/03/hof/"},{"title":"모듈 | javaScript","text":"1. 모듈의 일반적인 의미 모듈(Module)이란 애플리케이션을 구성하는 개별적 요소로서 재사용 가능한 코드 조각을 말한다. 일반적으로 모듈은 기능을 기준으로 파일 단위로 분리되어 있다. 모듈이 성립하려면 모듈은 자신만의 파일 스코프를 가질 수 있어야 한다. 다시 말해, 자신만의 파일스코프를 갖는 모듈의 모든 자산은 캡슐화되어 다른 모듈에서 접근할 수 없다. 즉, 모듈은 개별적 존재로서 애플리케이션과 분리되어 존재한다. 하지만 모듈은 애플리케이션이나 다른 모듈에 의해 재사용되어야 의미가 있다. 따라서 모듈은 공개가 필요한 자산에 한정하여 명시적으로 선택적 공개가 가능하다. 이를 export라 한다. 공개(export)된 모듈의 자산은 다른 모듈에서 재사용할 수 있다. 이때 공개된 모듈의 자산을 사용하는 모듈을 모듈 사용자라 한다. 모듈 사용자는 필요한 자산을 공개한 모듈을 선택해 자신의 스코프 내로 불러 들여 재사용할 수 있다. 이를 import라 한다. 이처럼 모듈은 애플리케이션과 분리되어 개별적으로 존재하다가 필요에 따라 다른 모듈에 의해 재사용된다. 모듈은 기능별로 분리되어 개별적인 파일로 작성된다. 결론은 명확히 분리해서 애플리케이션을 구성할 수 있고, 재사용성이 좋아서 개발 효율성과 유지보수성을 높일 수 있다. 2. 자바스크립트와 모듈 C 언어는 #include, Java는 import 등 대부분의 프로그래밍 언어는 모듈 기능을 가지고 있다. 하지만 클라이언트 사이드 자바스크립트는 script 태그를 사용하여 외부의 자바스크립트 파일을 가져올 수는 있지만, 파일마다 독립적인 파일 스코프를 갖지 않고 하나의 전역 객체(Global Object)를 공유한다. 즉, 자바스크립트 파일을 여러 개의 파일로 분리하여 script 태그로 로드하여도 분리된 자바스크립트 파일들이 결국 하나의 자바스크립트 파일 내에 있는 것처럼 하나의 전역 객체를 공유한다. 따라서 분리된 자바스크립트 파일들이 하나의 전역을 갖게 되어 전역 변수가 중복되는 등의 문제가 발생할 수 있다. 이것으로는 모듈을 구현할 수 없다. 자바스크립트를 클라이언트 사이드에 국한하지 않고 범용적으로 사용하고자 하는 움직임이 생기면서 모듈 시스템은 반드시 해결해야 하는 핵심 과제가 되었다. 이런 상황에서 제안된 것이 CommonJS와 AMD(Asynchronous Module Definition)이다. 이로서 자바스크립트의 모듈 시스템은 크게 CommonJS와 AMD 진영으로 나뉘게 되었고 브라우저에서 모듈을 사용하기 위해서는 CommonJS 또는 AMD를 구현한 모듈 로더 라이브러리를 사용해야 하는 상황이 되었다. 서버 사이드 자바스크립트 런타임 환경인 Node.js는 모듈 시스템의 사실상 표준(de facto standard)인 CommonJS를 채택하였고 독자적인 진화를 거쳐, 현재는 CommonJS 사양과 100% 동일하지는 않지만 기본적으로 CommonJS 사양을 따르고 있다. 즉, Node.js에서는 표준은 아니지만 모듈 시스템이 지원된다. 따라서 Node.js 환경에서는 모듈 별로 독립적인 파일 스코프, 즉 모듈 스코프를 갖는다. 3. ES6 모듈 이러한 상황에서 ES6에서는 클라이언트 사이드 자바스크립트에서도 동작하는 모듈 기능을 추가하였다. 2020년 4월 현재, 인터넷 익스플로어를 제외한 대부분의 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서 ES6 모듈을 사용할 수 있다.(ES6 모듈 지원 현황) script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 일반적인 자바스크립트 파일이 아닌 ES6 모듈임을 명확히 하기 위해 ES6 모듈의 파일 확장자는 mjs를 사용할 것을 권장한다. 123&lt;script type=\"module\" src=\"apple.mjs\"&gt;&lt;/script&gt;&lt;script type=\"module\" src=\"banana.mjs\"&gt;&lt;/script&gt;&lt;script type=\"module\" src=\"samsung.mjs\"&gt;&lt;/script&gt; 3.1 모듈 스코프 ES6 모듈을 사용하지 않으면 자바스크립트 파일을 분리해도 독자적인 스코프를 갖지 않고 하나의 전역을 공유한다. 아래 예제를 살펴보자. 12345678910111213// foo.jsvar x = 'foo';// 변수 x는 전역 변수이다.console.log(window.x); // foo// bar.js// foo.js에서 선언한 전역 변수 x와 중복된 선언이다.var x = 'bar';// 변수 x는 전역 변수이다.// foo.js에서 선언한 전역 변수 x의 값이 재할당되었다.console.log(window.x); // bar 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script src=\"foo.js\"&gt;&lt;/script&gt; &lt;script src=\"bar.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; HTML에서 2개의 자바스크립트 파일을 로드하면 로드된 자바스크립트는 하나의 전역을 공유한다. 위 예제에서 로드된 2개의 자바스크립트 파일은 하나의 전역 객체를 공유한다. 즉, 하나의 전역 스코프를 갖는다. 따라서 foo.js에서 선언한 변수 x와 bar.js에서 선언한 변수 x는 중복 선언되며 의도치 않게 변수 x의 값이 덮어 써진다. ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다. 따라서, 모듈 내에서 var 키워드로 선언한 변수는 더 이상 전역 변수가 아니며 window 객체의 프로퍼티도 아니다. 123456// foo.mjsvar x = 'foo';console.log(x); // foo// 변수 x는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.console.log(window.x); // undefined 1234567// bar.mjs// 변수 x는 foo.mjs에서 선언한 변수 x와 스코프가 다른 변수이다.var x = 'bar';console.log(x); // bar// 변수 x는 전역 변수가 아니며 window 객체의 프로퍼티도 아니다.console.log(window.x); // undefined 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script type=\"module\" src=\"foo.mjs\"&gt;&lt;/script&gt; &lt;script type=\"module\" src=\"bar.mjs\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 모듈 내에서 선언한 변수는 모듈 외부에서 참조할 수 없다. 모듈 스코프가 다르기 떄문 1234// foo.mjsconst x = 'foo';console.log(x); // foo 123// bar.js// 다른 모듈에서 선언한 변수는 모듈 외부에서 참조할 수 없다. 스코프가 다르기 때문이다.console.log(x); // ReferenceError: x is not defined 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script type=\"module\" src=\"foo.mjs\"&gt;&lt;/script&gt; &lt;script type=\"module\" src=\"bar.mjs\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 3.2 export 키워드 모듈은 독자적인 모듈 스코프를 갖는다. 따라서 모듈 안에 선언한 모든 식별자는 기본적으로 해당 모듈 내부에서만 참조할 수 있다. 만약 모듈 안에 선언한 식별자를 외부에 공개하여 다른 모듈들이 참조할 수 있게 하고 싶다면 export키워드를 사용한다. 123456789101112131415// lib.mjs// 변수의 공개export const pi = Math.PI;// 함수의 공개export function square(x) { return x * x;}// 클래스의 공개export class Person { constructor(name) { this.name = name; }} 선언문 앞에 매번 export 키워드를 붙이는 것이 싫다면 export 대상을 모아 하나의 객체로 구성하여 한번에 export할 수도 있다. 123456789101112131415// lib.mjsconst pi = Math.PI;function square(x) { return x * x;}class Person { constructor(name) { this.name = name; }}// 변수, 함수 클래스를 하나의 객체로 구성하여 공개export { pi, square, Person }; 3.3 import 키워드 다른 모듈에서 공개(export)한 식별자를 자신의 모듈 스코프 내부로 로드하려면 import 키워드를 사용한다. 다른 모듈이 export한 식별자로 import하며 ES6 모듈의 파일 확장자를 생략할 수 없다. 12345678// app.mjs// 같은 폴더 내의 lib.mjs 모듈이 export한 식별자로 import한다.// ES6 모듈의 파일 확장자를 생략할 수 없다.import { pi, square, Person } from './lib.mjs';console.log(pi); // 3.141592653589793console.log(square(10)); // 100console.log(new Person('Lee')); // Person { name: 'Lee' } 1234567&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script type=\"module\" src=\"lib.mjs\"&gt;&lt;/script&gt; &lt;script type=\"module\" src=\"app.mjs\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 모듈이 export한 식별자를 각각 지정하지 않고 하나의 이름으로 한꺼번에 import할 수도 있다. 이떄 import되는 식별자는 as뒤에 지정한 이름의 객체에 프로퍼티로 할당된다. 1234567// app.mjs// lib.mjs 모듈이 export한 모든 식별자를 lib 객체의 프로퍼티로 모아 import한다.import * as lib from './lib.mjs';console.log(lib.pi); // 3.141592653589793console.log(lib.square(10)); // 100console.log(new lib.Person('Lee')); // Person { name: 'Lee' } 모듈이 export한 식별자 이름을 변경하여 import할 수도 있다. 1234567// app.mjs// lib.mjs 모듈이 export한 식별자 이름을 변경하여 import한다.import { pi as PI, square as sq, Person as P } from './lib.mjs';console.log(PI); // 3.141592653589793console.log(sq(2)); // 4console.log(new P('Kim')); // Person { name: 'Kim' } 모듈에서 하나의 식별자만을 export한다면 default 키워드를 사용할 수 있다. 12// lib.mjsexport default x =&gt; x * x; default 키워드와 함께 export한 모듈은 {}없이 임의의 이름으로 import한다. 1234// app.mjsimport square from './lib.mjs';console.log(square(3)); // 9 default 키워드를 사용하는 경우, var, let, const 키워드는 사용할 수 없다. 123// lib.mjsexport default const foo = () =&gt; {};// =&gt; SyntaxError: Unexpected token 'const'","link":"/2020/04/module/"},{"title":"npm(node.js) - 모듈관리 | npm","text":"npm 모듈 설치, 삭제, 버전 업데이트 관리 1 npm 모듈 관리에서 중요한 설치, 업데이트, 삭제 방법을 설명한다. 2 설치 및 업데이트 명령어에 버전을 명시하지 않으면, 최신버전으로 설치된다. 3 npm 대신에 모듈설치 부분에서 빠른속도, 안정성이 검증된 yam에 대해서는 다음 포스팅에 설명한다. 12345npm install module_name #npm 모듈 설치(로컬 설치)npm install -g module_name #npm 모듈 설치(전역 설치)npm update module_name #npm 모듈 업데이트npm uninstall module_name #npm 모듈 삭제npm docs # npm 모듈 설명 npm(node.js) - list설치된 전역 리스트 확인 1npm ls -g --depth=0 npm 설치된 패키지 버전 확인 12npm lsnpm list npm(node.js) - list, view기본 소스 123456# 현재 설치된 모듈 버전 확인npm list 모듈명npm list 모듈명 -g#모듈의 최신버전 확인npm view 모듈명 version npm 버전 확인 및 기타 에러 발생시 캐시 삭제 방법 1234npm -v #npm 버전 확인npm cache verify #npm 캐시 확인npm cache clean #npm 캐시 삭제npm cache clean --force # npm 캐시 강제 삭제 pakage.json1npm init # pakage.json을 만듬 npm(node.js) 도움말 옵션기본 소스 12345#npm 커맨드 확인npm -h#npm 커맨드 세부사항 확인npm 커맨드 -h","link":"/2020/04/npm/"},{"title":"객체 리터럴 | javaScript","text":"1. 객체란?자바스크립트는 객체(object) 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 원시 값을 제외한 나머지 값들(함수, 배열, 정규표현식 등)은 모두 객체이다. 원시 타입은 단 하나의 값만을 나타내지만 객체 타입(object / reference type)은 다양한 타입의 값(원시 값 또는 다른 객체)들을 하나의 단위로 구성한 복합적인 자료 구조(Data structure)이다. 또한 원시 타입의 값, 즉 원시 값은 변경 불가능한 값(immutable value)이지만 객체 타입의 값, 즉 객체는 변경 가능한 값(mutable value)이다. 자바스크립트에서 사용할 수 있는 모든 값은 프로퍼티 값이 될 수 있다. 자바스크립트의 함수는 일급 객체이므로 값으로 취급할 수 있다. 따라서 프로퍼티 값으로 함수를 사용할 수도 있다. 프로퍼티 값이 함수일 경우, 일반 함수와 구분하기 위해 메소드(Method)라 부른다. 이처럼 객체는 프로퍼티와 메소드로 구성된 집합체이다. 프로퍼티와 메소드의 역할은 아래와 같다. 프로퍼티: 객체의 상태를 나타내는 값(data) 메소드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작(behavior)이와 같이 객체는 객체의 상태를 나타내는 값(프로퍼티)과 프로퍼티를 참조하고 조작할 수 있는 동작(메소드)를 모두 포함할 수 있기 때문에 상태와 동작을 하나의 단위로 구조화할 수 있어 유용하다.","link":"/2020/02/object/"},{"title":"연산자 | javaScript","text":"연산자(Operator)는 하나 이상의 표현식을 대상으로 산술, 할당, 비교, 논리, 타입, 지수 연산(operation) 등을 수행해 하나의 값을 만든다. 이때 연산의 대상을 피연산자(Operand)라 한다. 피연산자는 값으로 평가될 수 있는 표현식이어야 한다.그리고 피연산자와 연산자의 조합으로 이루어진 연산자 표현식도 값으로 평가될 수 있는 표현식이다. 1234567891011121314151617// 산술 연산자5 * 4 // -&gt; 20// 문자열 연결 연산자'My name is ' + 'Lee' // -&gt; 'My name is Lee'// 할당 연산자color = 'red' // -&gt; 'red'// 비교 연산자3 &gt; 5 // -&gt; false// 논리 연산자true &amp;&amp; false // -&gt; false// 타입 연산자typeof 'Hi' // -&gt; string 피연산자가 “값”이라는 명사의 역할을 한다면 연산자는 “피연산자를 연산하여 새로운 값을 만든다”라는 동사의 역할을 한다고 볼 수 있다.다시 말해,피연산자는 연산의 대상이 되어야 하므로 값으로 평가할 수 있어야 한다.연산자는 값으로 평가된 피연산자를 연산해 새로운 값을 만든다. 자바스크립트가 제공하는 다양한 연산자에 대해 살펴보도록 하자. 1. 산술 연산자산술 연산자는 피연산자를 대상으로 수학적 계산을 수행해 새로운 숫자 값을 만든다. 산술 연산이 불가능한 경우, NaN을 반환한다. 산술 연산자는 피연산자의 개수에 따라 이항 산술 연산자와 단항 산술 연산자로 구분할 수 있다. 1.1 이항 산술 연산자이항 산술 연산자는 2개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 모든 이항 산술 연산자는 피연산자의 값을 변경하는 부수 효과(Side effect)가 없다. 다시 말해 어떤 산술 연산을 해도 피연산자의 값이 바뀌는 경우는 없다. 언제나 새로운 값을 만들 뿐이다. 123455 + 2; // -&gt; 75 - 2; // -&gt; 35 * 2; // -&gt; 105 / 2; // -&gt; 2.55 % 2; // -&gt; 1 1.2. 단항 산술 연산자단항(Unary) 산술 연산자는 1개의 피연산자를 산술 연산하여 숫자 타입의 값을 만든다. 주의할 것은 이항 산술 연산자와는 달리 증가/감소(++/–) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다. 다시 말해 증가/감소 연산을 하면 피연산자의 값을 변경하는 암묵적 할당이 이루어진다. 증가/감소(++/–) 연산자는 위치에 의미가 있다. 피연산자 앞에 위치한 전위 증가/감소 연산자(Prefix increment/decrement operator)는 먼저 피연산자의 값을 증가/감소시킨 후, 다른 연산을 수행한다. 피연산자 뒤에 위치한 후위 증가/감소 연산자(Postfix increment/decrement operator)는 먼저 다른 연산을 수행한 후, 피연산자의 값을 증가/감소시킨다. 1234567891011121314151617var x = 5, result;// 선할당 후증가 (Postfix increment operator)result = x++;console.log(result, x); // 5 6// 선증가 후할당 (Prefix increment operator)result = ++x;console.log(result, x); // 7 7// 선할당 후감소 (Postfix decrement operator)result = x--;console.log(result, x); // 7 6// 선감소 후할당 (Prefix decrement operator)result = --x;console.log(result, x); // 5 5 +단항 연산자는 피연산자에 어떠한 효과도 없다. 음수를 양수로 반전하지도 않는다. 그런데 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 숫자 타입으로 변환한 값을 생성해서 반환한다. 따라서 부수 효과는 없다. 123456789101112131415// 아무런 효과가 없다.+10; // -&gt; 10+(-10); // -&gt; -10// 문자열을 숫자로 타입 변환한다.+'10'; // -&gt; 10// 불리언 값을 숫자로 타입 변환한다.+true; // -&gt; 1// 불리언 값을 숫자로 타입 변환한다.+false; // -&gt; 0// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.+'Hello'; // -&gt; NaN – 단항 연산자는 피연산자의 부호를 반전한 값을 반환한다. + 단항 연산자와 마찬가지로 숫자 타입이 아닌 피연산자에 사용하면 피연산자를 숫자 타입으로 변환하여 반환한다. 이때 피연산자를 변경하는 것은 아니고 부호를 반전한 값을 생성해서 반환한다. 따라서 부수 효과는 없다. 1234567891011// 부호를 반전한다.-(-10); // -&gt; 10// 문자열을 숫자로 타입 변환한다.-'10'; // -&gt; -10// 불리언 값을 숫자로 타입 변환한다.-true; // -&gt; -1// 문자열을 숫자로 타입 변환할 수 없으므로 NaN을 반환한다.-'Hello'; // -&gt; NaN 1.3. 문자열 연결 연산자+연산자는 피연산자 중 하나 이상이 문자열인 경우 문자열 연결 연산자로 동작한다. 그 외의 경우는 덧셈 연산자로 동작한다. 아래 예제를 살펴보자. 12345678910111213141516171819// 문자열 연결 연산자'1' + 2; // -&gt; '12'1 + '2'; // -&gt; '12'// 산술 연산자1 + 2; // -&gt; 3// true는 1로 타입 변환된다.1 + true; // -&gt; 2// false는 0으로 타입 변환된다.1 + false; // -&gt; 1// null는 0으로 타입 변환된다.1 + null; // -&gt; 1// undefined는 숫자로 타입 변환되지 않는다.+undefined; // -&gt; NaN1 + undefined; // -&gt; NaN 이 예제에서 주목할 것은 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되기도 한다는 것이다. 위 예제에서 1 + true를 연산하면 자바스크립트 엔진은 암묵적으로 불리언 타입의 값인 true를 숫자 타입인 1로 타입을 강제 변환한 후 연산을 수행한다. 이를 암묵적 타입 변환(Implicit coercion) 또는 타입 강제 변환(Type coercion)이라고 한다. 앞서 살펴본 +/- 단항 연산자도 암묵적 타입 변환이 발생한 것이다. 이에 대해서는 “9. 타입 변환과 단축 평가”에서 자세히 살펴볼 것이다. 2. 할당 연산자할당 연산자(Assignment Operator)는 우항에 있는 피연산자의 평가 결과를 좌항에 있는 변수에 할당한다. 할당 연산자는 좌항의 변수에 값을 할당하므로 변수의 값이 변하는 부수 효과가 있다. 1234567891011121314151617181920212223242526var x;x = 10;console.log(x); // 10x += 5; // x = x + 5;console.log(x); // 15x -= 5; // x = x - 5;console.log(x); // 10x *= 5; // x = x * 5;console.log(x); // 50x /= 5; // x = x / 5;console.log(x); // 10x %= 5; // x = x % 5;console.log(x); // 0var str = 'My name is ';// 문자열 연결 연산자str += 'Lee'; // str = str + 'Lee';console.log(str); // 'My name is Lee' 3. 비교 연산자비교 연산자(Comparison Operator)는 좌항과 우항의 피연산자를 비교한 다음 그 결과를 불리언 값을 반환한다. 비교 연산자는 if 문이나 for 문과 같은 제어문의 조건식에서 주로 사용한다. 3.1 동등 / 일치 비교 연산자동등 비교(loose equality) 연산자와 일치 비교(strict equality) 연산자는 좌항과 우항의 피연산자가 같은 값을 갖는지 비교하여 불리언 값을 반환한다. 하지만 비교하는 엄격성의 정도가 다르다. 동등 비교 연산자는 느슨한 비교를 하지만 일치 비교 연산자는 엄격한 비교를 한다. 1234567891011121314// 동등 비교5 == 5; // -&gt; true// 타입은 다르지만 암묵적 타입 변환을 통해 타입을 일치시키면 동등하다.5 == '5'; // -&gt; true// 동등 비교. 결과를 예측하기 어렵다.'0' == ''; // -&gt; false0 == ''; // -&gt; true0 == '0'; // -&gt; truefalse == 'false'; // -&gt; falsefalse == '0'; // -&gt; truefalse == null; // -&gt; falsefalse == undefined; // -&gt; false 위 예제와 같은 코드를 작성할 개발자는 드물겠지만 이처럼 동등 비교(==) 연산자는 예측하기 어려운 결과를 만들어낸다. 위 예제는 이해하려 하지 않아도 된다. 다만 동등 비교 연산자를 사용하지 말고 일치 비교 연산자를 사용하면 된다. 일치 비교(===) 연산자는 좌항과 우항의 피연산자가 타입도 같고 값도 같은 경우에 한하여 true를 반환한다. 다시 말해 암묵적 타입 변환을 하지 않고 값을 비교한다. 123456789// 일치 비교5 === 5; // -&gt; true// 암묵적 타입 변환을 하지 않고 값을 비교한다.// 즉, 값과 타입이 모두 같은 경우만 true를 반환한다.5 === '5'; // -&gt; false// NaN은 자신과 일치하지 않는 유일한 값이다.NaN === NaN; // -&gt; false NaN은 자신과 일치하지 않는 유일한 값이다. 따라서 숫자가 NaN인지 조사하려면 빌트인 함수 isNaN을 사용한다 1234// 빌트인 함수 isNaN은 주어진 값이 NaN인지 체크하고 그 결과를 반환한다.isNaN(NaN); // -&gt; trueisNaN(10); // -&gt; falseisNaN(1 + undefined); // -&gt; true 숫자 0도 주의하도록 하자. 자바스크립트에는 양의 0과 음의 0이 있는데 이들을 비교하면 true를 반환한다. 123// 양의 0과 음의 0의 비교. 일치 비교/동등 비교 모두 true이다.0 === -0; // -&gt; true0 == -0; // -&gt; true Object.is 메소드 위에서 살펴본 바와 같이 동등 비교 연산자(==)와 일치 비교 연산자(===)는 +0과 -0을 동일하다고 평가한다. 또한 동일한 값인 NaN과 NaN을 비교하면 다른 값이라고 평가한다. ES6에서 새롭게 도입된 Object.is 메소드는 아래와 같이 예측 가능한 정확한 비교 결과를 반환한다. 그 외에는 일치 비교 연산자(===)와 동일하게 동작한다.12345-0 === +0; // -&gt; trueObject.is(-0, +0); // -&gt; falseNaN === NaN; // -&gt; falseObject.is(NaN, NaN); // -&gt; true 부동등 비교 연산자(!=)와 불일치 비교 연산자(!==)는 동등 비교(==) 연산자와 일치 비교(===) 연산자의 반대 개념이다. 123456789// 부동등 비교5 != 8; // -&gt; true5 != 5; // -&gt; false5 != '5'; // -&gt; false// 불일치 비교5 !== 8; // -&gt; true5 !== 5; // -&gt; false5 !== '5'; // -&gt; true 3.2. 대소 관계 비교 연산자대소 관계 비교 연산자는 피연산자의 크기를 비교하여 불리언 값을 반환한다. 12345// 대소 관계 비교5 &gt; 0; // -&gt; true5 &gt; 5; // -&gt; false5 &gt;= 5; // -&gt; true5 &lt;= 5; // -&gt; true 4. 삼항 조건 연산자삼항 조건 연산자(ternary operator)는 조건식의 평가 결과에 따라 반환할 값을 결정한다. 자바스크립트의 유일한 삼항 연산자이며 부수 효과는 없다. 삼항 조건 연산자 표현식은 아래와 같이 사용한다. 1조건식 ? 조건식이 true일때 반환할 값 : 조건식이 false일때 반환할 값 물음표(?) 앞의 첫번째 피연산자는 조건식, 즉 불리언 타입의 값으로 평가될 표현식이다. 만약 조건식의 평가 결과가 불리언 값이 아니면 불리언 값으로 암묵적 타입 변환된다. 이때 조건식이 참이면 콜론(:) 앞의 두번째 피연산자가 평가되어 반환되고, 거짓이면 콜론(:) 뒤의 세번째 피연산자가 평가되어 반환된다. 123456var x = 2;// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 삼항 조건 연산자는 다음 장에서 살펴볼 if…else 문을 사용해도 동일한 처리를 할 수 있다. 1234567var x = 2, result;// 2 % 2는 0이고 0은 false로 암묵적 타입 변환된다.if (x % 2) result = '홀수';else result = '짝수';console.log(result); // 짝수 하지만 if…else 문은 표현식이 아닌 문이다. 따라서 if…else 문은 값처럼 사용할 수 없다. 12345var x = 10;// if...else 문은 표현식이 아닌 문이다. 따라서 값처럼 사용할 수 없다.var result = if (x % 2) { result = '홀수'; } else { result = '짝수'; };// SyntaxError: Unexpected token if 삼항 조건 연산자 표현식은 값으로 평가할 수 있는 표현식인 문이다. 따라서 삼항 조건 연산자식은 값처럼 다른 표현식의 일부가 될 수 있어 매우 유용하다. 12345var x = 10;// 삼항 연산자 표현식은 표현식인 문이다. 따라서 값처럼 사용할 수 있다.var result = x % 2 ? '홀수' : '짝수';console.log(result); // 짝수 조건에 따라 어떤 값을 결정해야 한다면 if…else 문보다 삼항 조건 연산자 표현식을 사용하는 것이 유리하다. 하지만 조건에 따라 수행해야 할 문이 하나가 아니라 여러 개라면 if…else 문이 보다 가독성이 좋다. 5. 논리 연산자논리 연산자(Logical Operator)는 우항과 좌항의 피연산자(부정 논리 연산자의 경우, 우항의 피연산자)를 논리 연산한다. 123456789101112131415// 논리합(||) 연산자true || true; // -&gt; truetrue || false; // -&gt; truefalse || true; // -&gt; truefalse || false; // -&gt; false// 논리곱(&amp;&amp;) 연산자true &amp;&amp; true; // -&gt; truetrue &amp;&amp; false; // -&gt; falsefalse &amp;&amp; true; // -&gt; falsefalse &amp;&amp; false; // -&gt; false// 논리 부정(!) 연산자!true; // -&gt; false!false; // -&gt; true 논리 부정(!) 연산자는 언제나 불리언 값을 반환한다. 단, 피연산자가 반드시 불리언 값일 필요는 없다. 만약 피연산자가 불리언 값이 아니면 불리언 타입으로 암묵적 타입 변환된다. 123// 암묵적 타입 변환!0; // -&gt; true!'Hello'; // -&gt; false 논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식의 평가 결과는 불리언 값이 아닐 수도 있다. 논리합(||) 또는 논리곱(&amp;&amp;) 연산자 표현식은 언제나 2개의 피연산자 중 어는 한쪽으로 평가된다. 12// 단축 평가'Cat' &amp;&amp; 'Dog'; // -&gt; 'Dog' 12!(x || y) === (!x &amp;&amp; !y)!(x &amp;&amp; y) === (!x || !y) 6. 쉼표 연산자쉼표(,) 연산자는 왼쪽 피연산자부터 차례대로 피연산자를 평가하고 마지막 피연산자의 평가가 끝나면 마지막 피연산자의 평가 결과를 반환한다. 123var x, y, z;x = 1, y = 2, z = 3; // 3 7. 그룹 연산자그룹 연산자 (…)는 자신의 피연산자인 표현식을 가장 먼저 평가한다. 따라서 그룹 연산자를 사용하면 연산자의 우선 순위를 조절할 수 있다. 123410 * 2 + 3; // -&gt; 23// 그룹 연산자를 사용하여 우선 순위 조절10 * (2 + 3); // -&gt; 50 위 예제의 첫번째 문은 10 * 2를 먼저 연산하고 그 다음 20 + 3을 연산한다. 수학에서와 마찬가지로 곱셈 연산자 *가 덧셈 연산자 +보다 우선 순위가 높기 때문이다. 두번째 문은 그룹 연산자로 감싼 표현식을 먼저 연산한다. 따라서 2 + 3을 먼저 연산하고 그 다음 10 * 5를 연산한다. 8. typeof 연산자typeof 연산자는 피연산자의 데이터 타입을 문자열로 반환한다. typeof 연산자는 7가지 문자열 “string”, “number”, “boolean”, “undefined”, “symbol”, “object”, “function” 중 하나를 반환한다. “null”을 반환하는 경우는 없으며 함수의 경우 “function”을 반환한다. 이처럼 typeof 연산자가 반환하는 문자열은 7개의 데이터 타입과 정확히 일치하지는 않는다. 123456789101112typeof '' // -&gt; \"string\"typeof 1 // -&gt; \"number\"typeof NaN // -&gt; \"number\"typeof true // -&gt; \"boolean\"typeof undefined // -&gt; \"undefined\"typeof Symbol() // -&gt; \"symbol\"typeof null // -&gt; \"object\"typeof [] // -&gt; \"object\"typeof {} // -&gt; \"object\"typeof new Date() // -&gt; \"object\"typeof /test/gi // -&gt; \"object\"typeof function () {} // -&gt; \"function\" typeof 연산자로 null 값을 연산해 보면 “null”이 아닌 “object”를 반환하는 것에 주의하자. 이것은 자바스크립트의 첫 번째 버전의 버그이다. 하지만 기존 코드에 영향을 줄 수 있기 때문에 아직까지 수정되지 못하고 있다. 따라서 null 타입을 확인할 때는 typeof 연산자를 사용하지 말고 일치 연산자(===)를 사용하도록 하자. 1234var foo = null;typeof foo === null; // -&gt; falsefoo === null; // -&gt; true 또 하나 주의해야 할 것이 있다. 선언하지 않은 식별자를 typeof 연산자로 연산해 보면 ReferenceError가 발생하지 않고 “undefined”를 반환한다. 12// 식별자 undeclared는 선언한 적이 없다.typeof undeclared; // -&gt; undefined typeof 연산자가 선언하지 않은 식별자를 연산했을 때 “undefined”를 반환하는 것을 카일 심슨의 “You don’t know JS”에서는 특별한 안전 가드(safety guard)로 설명한다. 하지만 모던 자바스크립트 개발에서는 대부분 모듈을 사용하고 전역 변수인 플래그를 사용하지 않으므로 의도적으로 사용할 필요는 없다. 9. 지수 연산자ES7에서 새롭게 도입된 지수 연산자는 좌항의 피연산자를 밑으로, 우항의 피연산자를 지수로 거듭 제곱하여 숫자 타입의 값을 반환한다. 12342 ** 2; // -&gt; 42 ** 2.5; // -&gt; 5.656854249492382 ** 0; // -&gt; 12 ** -2; // -&gt; 0.25 지수 연산자가 도입되기 이전에는 Math.pow 메소드를 사용하였다. 1234Math.pow(2, 2); // -&gt; 4Math.pow(2, 2.5); // -&gt; 5.65685424949238Math.pow(2, 0); // -&gt; 1Math.pow(2, -2); // -&gt; 0.25 지수 연산자는 여러 개의 피연산자를 사용할 경우, Math.pow 메소드보다 가독성이 좋다. 122 ** 2 ** 2; // -&gt; 16Math.pow(Math.pow(2, 2), 2); // -&gt; 16 음수를 거듭제곱의 밑으로 계산하려면 아래와 같이 괄호로 묶어야 한다. 123-5 ** 2;// -&gt; SyntaxError: Unary operator used immediately before exponentiation expression. Parenthesis must be used to disambiguate operator precedence(-5) ** 2; // -&gt; 25 지수 연산자는 다른 산술 연산자와 마찬가지로 할당 연산자와 함께 사용할 수 있다. 12var num = 5;num **= 2; // -&gt; 25 지수 연산자는 모든 이항 연산자보다 우선 순위가 높다. 12 * 5 ** 2; // -&gt; 50 10. 연산자의 부수 효과대부분의 연산자는 다른 코드에 영향을 주지 않는다. 예를 들어, 1 * 2는 다른 코드에 어떠한 영향도 주지 않는다. 하지만 일부 연산자는 다른 코드에 영향을 주는 부수 효과(side effect)가 있다. 부수 효과가 있는 연산자는 할당(=) 연산자, 증가/감소(++/–) 연산자, delete 연산자이다. 123456789101112131415161718var x;// 할당 연산자는 변수 값이 변하는 부수 효과가 있다.// 이는 변수 x를 사용하는 다른 코드에 영향을 준다.x = 1;console.log(x); // 1// 증가/감소(++/--) 연산자는 피연산자의 값을 변경하는 부수 효과가 있다.// 피연산자 x의 값이 변경된다. 이는 변수 x를 사용하는 다른 코드에 영향을 준다.x++;console.log(x); // 2var o = { a: 1 };// delete 연산자는 객체의 프로퍼티를 삭제하는 부수 효과가 있다.// 이는 객체 o를 사용하는 다른 코드에 영향을 준다.delete o.a;console.log(o); // {} delete 연산자는 객체의 프로퍼티를 삭제한다. 이에 대해서는 객체에 대해 살펴본 다음 “프로퍼티 삭제”에서 알아보도록 하자.","link":"/2020/02/operator/"},{"title":"프로퍼티 어트리뷰트 | javaScript","text":"1.내부 슬롯과 내부 메소드내부 슬롯과 내부 메소드는 자바스크립트 엔진의 알고리즘을 설명하기 위해 ECMAScript 사양에서 사용하는 의사 프로퍼티와 의사 메소드이다. ECMAScript 사양에 등장하는 이중 대괄호 [[…]]로 감싼 이름들이 내부 슬롯과 내부 메소드이다. 내부 슬롯과 내부 메소드는 ECMAScript 사양에 정의된 대로 구현되어 자바스크립트 엔진에서 실제로 동작하지만 외부로 공개된 객체의 프로퍼티는 아니다. 즉, 내부 슬롯과 내부 메소드는 자바스크립트 엔진의 내부 로직이다. 그러므로 직접적으로 접근하거나 호출할 수가 없다. 2. 프로퍼티 어트리뷰트와 프로퍼티 디스크립터 객체자바스크립트 엔진은 프로퍼티를 생성할 때, 프로퍼티의 상태를 나타내는 프로퍼티 어트리뷰트를 기본값으로 자동 정의한다. 프로퍼티의 상태란 프로퍼티의 값(value), 값의 갱신 가능 여부(writable), 열거 가능 여부(enumerable), 재정의 가능 여부(configurable)를 말한다. 프로퍼티 어트리뷰트는 자바스크립트 엔진이 관리하는 내부 상태 값(meta-property)인 내부 슬롯([[Value]], [[Writable]], [[Enumerable]], [[Configurable]])이다. 따라서 프로퍼티 어트리뷰트에 직접 접근할 수 없지만, Object.getOwnPropertyDescriptor 메소드를 사용하여 간접적으로 확인할 수는 있다. 1234567const person = { name: 'Lee'};// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 반환한다.console.log(Object.getOwnPropertyDescriptor(person, 'name'));// {value: \"Lee\", writable: true, enumerable: true, configurable: true} Object.getOwnPropertyDescriptor 메소드를 호출할 때, 첫번째 매개변수에는 객체의 참조를 전달하고 두번째 매개변수에는 프로퍼티 키를 문자열로 전달한다. 이때 Object.getOwnPropertyDescriptor 메소드는 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터(PropertyDescriptor) 객체를 반환한다. 만약 존재하지 않는 프로퍼티나 상속받은 프로퍼티에 대한 프로퍼티 디스크립터를 요구하면 undefined가 반환된다. Object.getOwnPropertyDescriptor 메소드는 하나의 프로퍼티에 대해 프로퍼티 디스크립터 객체를 반환하지만 ES8에서 도입된 Object.getOwnPropertyDescriptors 메소드는 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다. 123456789101112131415const person = { name: 'Lee'};// 프로퍼티 동적 생성person.age = 20;// 모든 프로퍼티의 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체들을 반환한다.console.log(Object.getOwnPropertyDescriptors(person));/*{ name: {value: \"Lee\", writable: true, enumerable: true, configurable: true}, age: {value: 20, writable: true, enumerable: true, configurable: true}}*/ 3. 데이터 프로퍼티와 접근자 프로퍼티프로퍼티는 데이터 프로퍼티와 접근자 프로퍼티로 구분할 수 있다. 데이터 프로퍼티(Data property)키와 값으로 구성된 일반적인 프로퍼티이다. 지금까지 살펴본 모든 프로퍼티는 데이터 프로퍼티이다. 접근자 프로퍼티 (Accessor property)자체적으로 값을 갖지 않고 다른 데이터의 프로퍼티 값을 읽거나 저장할 떄 호출되는 접근자 함수로 구성된 프로퍼티이다. 3.1 데이터 프로퍼티데이터 프로퍼티(Data property)는 아래와 같은 프로퍼티 어트리뷰트를 갖는다. 이 프로퍼티 어트리뷰트는 자바스크립트 엔진이 프로퍼티를 생성할 때, 기본값으로 자동 정의된다. 프로퍼티 어트리뷰트 프로퍼티 디스크립터 객체의 프로퍼티 설명 [[Value]] value - 프로퍼티 키로 프로퍼티 값에 접근하면 반환되는 값이다.- 프로퍼티 키로 프로퍼티 값을 저장하면 [[Value]]에 값을 저장한다.이때 프로퍼티가 없으면 프로퍼티를 생성하고 생성된 프로퍼티의 [[Value]]에 값을 저장한다. [[Writable]] writable - 프로퍼티 값의 변경 가능 여부를 나타내며 불리언 값을 갖는다.-[[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없는 읽기 전용 프로퍼티가 된다. [[Configurable]] configurable - 프로퍼티의 재정의 가능 여부를 나타내며 불리언 값을 갖는다.- [[Configurable]]의 값이 false인 경우, 해당 프로퍼티의 삭제, 프로퍼티 어트리뷰트 값의 변경이 금지된다. 단, [[Writable]]이 true인 경우, [[Value]]의 변경과 [[Writable]]을 false로 변경하는 것은 허용된다. 1234567const person = { name: 'Lee'};// 프로퍼티 어트리뷰트 정보를 제공하는 프로퍼티 디스크립터 객체를 취득한다.console.log(Object.getOwnPropertyDescriptor(person, 'name'));// {value: \"Lee\", writable: true, enumerable: true, configurable: true} Object.getOwnPropertyDescriptor 메소드가 반환한 프로퍼티 디스크립터 객체를 살펴보면 value 프로퍼티의 값은 ‘Lee’이다. 이는 프로퍼티 어트리뷰트 [[Value]]의 값이 ‘Lee’인 것을 의미한다. writable, enumerable, configurable 프로퍼티 모두 true를 갖는다. 이것은 프로퍼티 어트리뷰트 [[Writable]], [[Enumerable]], [[Configurable]]의 값이 모두 true인 것을 말한다. 이처럼 프로퍼티가 생성될 때 [[Value]]의 값은 프로퍼티 값으로 초기화되며 [[Writable]], [[Enumerable]], [[Configurable]]의 기본값 true로 초기화된다. 이것은 프로퍼티를 동적 추가하여도 마찬가지다. 1234567891011121314const person = { name: 'Lee'};// 프로퍼티 동적 생성person.age = 20;console.log(Object.getOwnPropertyDescriptors(person));/*{ name: {value: \"Lee\", writable: true, enumerable: true, configurable: true}, age: {value: 20, writable: true, enumerable: true, configurable: true}}*/ 3.2. 접근자 프로퍼티접근자 프로퍼티(Accessor property)는 자체적으로는 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할 때 사용하는 접근자 함수(Accessor function)로 구성된 프로퍼티다. 접근자 프로퍼티는 아래와 같은 프로퍼티 어트리뷰트를 갖는다. 프로퍼티 어트리뷰트 프로퍼티 디스크립터 객체의 프로퍼티 설명 [[Get]] get 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 읽을 때 호출되는 접근자 함수이다.즉, 접근자 프로퍼티 키로 프로퍼티 값에 접근하면 프로퍼티 어트리뷰트 [[Get]]의 값즉 getter 함수가 호출되고 그 결과가 프로퍼티 값으로 반환된다. [[Set]] set 접근자 프로퍼티를 통해 데이터 프로퍼티의 값을 저장할 때 호출되는 접근자 함수이다. 즉, 접근자 프로퍼티 키로 프로퍼티 값을 저장하면 프로퍼티 어트리뷰트 [[Set]]의 값, 즉 setter 함수가 호출되고 그 결과가 프로퍼티 값으로 저장된다. [[Enumerable]] enumerable 데이터 프로퍼티의 [[Enumerable]]와 같다. [[Configurable]] Configurable 데이터 프로퍼티의 [[Configurable]]와 같다. 접근자 함수는 getter/setter 함수라고도 부른다. 접근자 프로퍼티는 getter와 setter 함수를 모두 정의할 수도 있고 하나만 정의할 수도 있다. 아래 예제를 살펴보자. 123456789101112131415161718192021222324252627282930313233343536373839const person = { // 데이터 프로퍼티 firstName: 'Ungmo', lastName: 'Lee', // fullName은 접근자 함수로 구성된 접근자 프로퍼티이다. // getter 함수 get fullName() { return `${this.firstName} ${this.lastName}`; }, // setter 함수 set fullName(name) { [this.firstName, this.lastName] = name.split(' '); }};// 데이터 프로퍼티를 통한 프로퍼티 값의 참조.console.log(person.firstName + ' ' + person.lastName); // Ungmo Lee// 접근자 프로퍼티를 통한 프로퍼티 값의 저장// 접근자 프로퍼티 fullName에 값을 저장하면 setter 함수가 호출된다.person.fullName = 'Heegun Lee';console.log(person); // {firstName: \"Heegun\", lastName: \"Lee\"}// 접근자 프로퍼티를 통한 프로퍼티 값의 참조// 접근자 프로퍼티 fullName에 접근하면 getter 함수가 호출된다.console.log(person.fullName); // Heegun Lee// firstName는 데이터 프로퍼티이다.// 데이터 프로퍼티는 value, writable, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.let descriptor = Object.getOwnPropertyDescriptor(person, 'firstName');console.log(descriptor);// {value: \"Heegun\", writable: true, enumerable: true, configurable: true}// fullName는 접근자 프로퍼티이다.// 접근자 프로퍼티는 get, set, enumerable, configurable 프로퍼티 어트리뷰트를 갖는다.descriptor = Object.getOwnPropertyDescriptor(person, 'fullName');console.log(descriptor);// {get: ƒ, set: ƒ, enumerable: true, configurable: true} person 객체의 firstName과 lastName 프로퍼티는 일반적인 데이터 프로퍼티다. 메소드 앞에 get, set이 붙은 메소드가 있는데 이것들이 바로 getter와 setter 함수이고 getter/setter 함수의 이름 fullName이 접근자 프로퍼티이다. 접근자 프로퍼티는 자체적으로 값(프로퍼티 어트리뷰트 [[Value]])을 가지지 않으며 다만 데이터 프로퍼티의 값을 읽거나 저장할 때 관여할 뿐이다. 이를 내부 슬롯/메소드 관점에서 설명하면 다음과 같다. 접근자 프로퍼티 fullName으로 프로퍼티 값에 접근하면 내부적으로 [[Get]] 내부 메소드가 호출되어 아래와 같이 동작한다. ECMAScript 스펙에서 정의한 [[Get]] 내부 메소드의 사양을 만족시키는 구현체가 자바스크립트 엔진에 존재한다는 것이 중요하지 [[Get]]이란 이름으로 실제 자바스크립트 엔진이 구현되었는지는 중요하지 않다. 어차피 [[Get]] 내부 메소드에 직접 접근할 수도 없다. 프로퍼티 키가 유효한지 확인한다. 프로퍼티 키는 문자열 또는 심볼이어야 한다. 프로퍼티 키 “fullName”은 문자열이므로 유효한 프로퍼티 키이다. 프로토타입 체인에서 프로퍼티를 검색한다. person 객체에 fullName 프로퍼티가 존재한다. 프로토타입 프로토타입(prototype)은 어떤 객체의 상위(부모) 객체의 역할을 하는 객체이다. 프로토타입은 하위(자식) 객체에게 자신의 프로퍼티와 메소드를 상속한다. 프로토타입 객체의 프로퍼티나 메소드를 상속받은 하위 객체는 자신의 프로퍼티 또는 메소드인 것처럼 자유롭게 사용할 수 있다. 프로토타입 체인은 프로토타입이 단방향 링크드 리스트 형태로 연결되어 있는 상속 구조를 말한다. 객체의 프로퍼티나 메소드에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티 또는 메소드가 없다면 프로토타입 체인을 따라 프로토타입의 프로퍼티나 메소드를 차례대로 검색한다. 프로토타입과 프로토타입 체인에 대해서는 “19. 프로토타입”에서 자세히 살펴보도록 하자. 검색된 fullName 프로퍼티가 데이터 프로퍼티인지 접근자 프로퍼티인지 확인한다. fullName 프로퍼티는 접근자 프로퍼티이다. 접근자 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값, 즉 getter 함수를 호출하여 그 결과를 반환한다. 프로퍼티 fullName의 프로퍼티 어트리뷰트 [[Get]]의 값은 Object.getOwnPropertyDescriptor 메소드가 반환하는 프로퍼티 디스크립터(PropertyDescriptor) 객체의 get 프로퍼티 값과 같다. 접근자 프로퍼티와 데이터 프로퍼티 구별 방법은 아래와 같다. 1234567// 일반 객체의 __proto__는 접근자 프로퍼티이다.Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');// {get: ƒ, set: ƒ, enumerable: false, configurable: true}// 함수 객체의 prototype은 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(function() {}, 'prototype');// {value: {…}, writable: true, enumerable: false, configurable: false} Object.getOwnPropertyDescriptor 메소드가 반환한 프로퍼티 어트리뷰트를 객체로 표현한 프로퍼티 디스크립터 객체를 유심히 살펴보자. 접근자 프로퍼티와 데이터 프로퍼티의 프로퍼티 디스크립터 객체의 프로퍼티가 다른 것을 알 수 있다. 4. 프로퍼티 정의프로퍼티 정의란 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나, 기존 프로퍼티의 프로퍼티 어트리뷰트를 재정의하는 것을 말한다. .예를 들어 프로퍼티 값을 갱신 가능하도록 할 것인지, 프로퍼티를 열거 가능하도록 할 것인지, 프로퍼티를 재정의 가능하도록 할 것인지 정의할 수 있다. 이를 통해 객체의 프로퍼티가 어떻게 동작해야 하는지를 명확히 정의할 수 있다. Object.defineProperty 메소드를 사용하면 프로퍼티의 어트리뷰트를 정의할 수 있다. 인수는 객체의 참조와 데이터 프로퍼티의 키인 문자열 그리고 프로퍼티 디스크립터 객체를 전달한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566const person = {};// 데이터 프로퍼티 정의Object.defineProperty(person, 'firstName', { value: 'Ungmo', writable: true, enumerable: true, configurable: true});Object.defineProperty(person, 'lastName', { value: 'Lee'});let descriptor = Object.getOwnPropertyDescriptor(person, 'firstName');console.log('firstName', descriptor);// firstName {value: \"Ungmo\", writable: true, enumerable: true, configurable: true}// 디스크립터 객체의 프로퍼티를 누락시키면 undefined, false가 기본값이다.descriptor = Object.getOwnPropertyDescriptor(person, 'lastName');console.log('lastName', descriptor);// lastName {value: \"Lee\", writable: false, enumerable: false, configurable: false}// [[Enumerable]]의 값이 false인 경우,// 해당 프로퍼티는 for…in 문이나 Object.keys 등으로 열거할 수 없다.// lastName 프로퍼티는 [[Enumerable]]의 값이 false이므로 열거되지 않는다.console.log(Object.keys(person)); // [\"firstName\"]// [[Writable]]의 값이 false인 경우, 해당 프로퍼티의 [[Value]]의 값을 변경할 수 없다.// lastName 프로퍼티는 [[Writable]]의 값이 false이므로 값을 변경할 수 없다.// 이때 값을 변경하면 에러는 발생하지 않고 무시된다.person.lastName = 'Kim';// [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 삭제할 수 없다.// lastName 프로퍼티는 [[Configurable]]의 값이 false이므로 삭제할 수 없다.// 이때 프로퍼티를 삭제하면 에러는 발생하지 않고 무시된다.delete person.lastName;// [[Configurable]]의 값이 false인 경우, 해당 프로퍼티를 재정의할 수 없다.// Object.defineProperty(person, 'lastName', { enumerable: true });// Uncaught TypeError: Cannot redefine property: lastNamedescriptor = Object.getOwnPropertyDescriptor(person, 'lastName');console.log('lastName', descriptor);// lastName {value: \"Lee\", writable: false, enumerable: false, configurable: false}// 접근자 프로퍼티 정의Object.defineProperty(person, 'fullName', { // getter 함수 get() { return `${this.firstName} ${this.lastName}`; }, // setter 함수 set(name) { [this.firstName, this.lastName] = name.split(' '); }, enumerable: true, configurable: true});descriptor = Object.getOwnPropertyDescriptor(person, 'fullName');console.log('fullName', descriptor);// fullName {get: ƒ, set: ƒ, enumerable: true, configurable: true}person.fullName = 'Heegun Lee';console.log(person); // {firstName: \"Heegun\", lastName: \"Lee\"} Object.defineProperty 메소드로 프로퍼티 정의할 때 프로퍼티 디스크립터 객체의 프로퍼티를 일부 생략할 수 있다. 프로퍼티 디스크립터 객체에서 생략된 어트리뷰트는 아래와 같이 기본값이 적용된다. 프로퍼티 디스크립터 객체의 프로퍼티 대응하는 프로퍼티 어트리뷰트 디스크립터 객체의 프로퍼트 누락 시의 기본값 value [[value]] undefined get [[Get]] undefined set [[Set]] undefined writable [[Writable]] false ennumerable [[ennumerable]] false configuration [[Configuration]] false Object.defineProperty 메소드는 한번에 하나의 프로퍼티만 정의할 수 있다. Object.defineProperties 메소드를 사용하면 여러 개의 프로퍼티를 한번에 정의할 수 있다. 123456789101112131415161718192021222324252627282930313233const person = {};Object.defineProperties(person, { // 데이터 프로퍼티 정의 firstName: { value: 'Ungmo', writable: true, enumerable: true, configurable: true }, lastName: { value: 'Lee', writable: true, enumerable: true, configurable: true }, // 접근자 프로퍼티 정의 fullName: { // getter 함수 get() { return `${this.firstName} ${this.lastName}`; }, // setter 함수 set(name) { [this.firstName, this.lastName] = name.split(' '); }, enumerable: true, configurable: true }});person.fullName = 'Heegun Lee';console.log(person); // {firstName: \"Heegun\", lastName: \"Lee\"} 5. 객체 변경 방지객체는 변경 가능한 값이므로 재할당없이 직접 변경이 가능하다. 즉, 프로퍼티를 추가하거나 삭제할 수 있고, 프로퍼티의 값을 갱신할 수 있으며 Object.defineProperty 또는 Object.defineProperties 메소드를 사용하여 프로퍼티 어트리뷰트를 재정의할 수도 있다. 자바스크립트는 객체의 변경을 방지할 수 있는 다양한 메소드를 제공한다. 객체 변경 방지 메소드 들은 객체의 변경을 금지하는 강도가 다르다. 5.1. 객체 확장 금지Object.preventExtensions 메소드는 객체의 확장을 금지한다. 객체 확장 금지란 프로퍼티 추가 금지를 의미한다. 즉, 확장이 금지된 객체는 프로퍼티 추가가 금지된다. 프로퍼티는 프로퍼티 동적 추가와 Object.defineProperty 메소드로 추가할 수 있다. 이 두가지 추가 방법이 모두 금지된다. 확장이 금지된 객체인지 여부는 Object.isExtensible 메소드로 확인 할 수 있다. 12345678910111213141516171819202122const person = { name: 'Lee' };// person 객체는 확장이 금지된 객체가 아니다.console.log(Object.isExtensible(person)); // true// person 객체의 확장을 금지하여 프로퍼티 추가를 금지한다.Object.preventExtensions(person);// person 객체는 확장이 금지된 객체다.console.log(Object.isExtensible(person)); // false// 프로퍼티 추가가 금지된다.person.age = 20; // 무시. strict mode에서는 에러console.log(person); // {name: \"Lee\"}// 프로퍼티 추가는 금지되지만 삭제는 가능하다.delete person.name;console.log(person); // {}// 프로퍼티 정의에 의한 프로퍼티 추가도 금지된다.Object.defineProperty(person, 'age', { value: 20 });// TypeError: Cannot define property age, object is not extensible 5.2. 객체 밀봉Object.seal 메소드는 객체를 밀봉한다. 객체 밀봉(seal)이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지를 의미한다. 즉, 밀봉된 객체는 읽기와 쓰기만 가능하게 된다. 밀봉된 객체인지 여부는 Object.isSealed 메소드로 확인 할 수 있다. 12345678910111213141516171819202122232425262728293031323334const person = { name: 'Lee' };// person 객체는 밀봉(seal)된 객체가 아니다.console.log(Object.isSealed(person)); // false// person 객체를 밀봉(seal)하여 프로퍼티 추가, 삭제, 재정의를 금지한다.Object.seal(person);// person 객체는 밀봉(seal)된 객체다.console.log(Object.isSealed(person)); // true// 밀봉(seal)된 객체는 configurable가 false이다.console.log(Object.getOwnPropertyDescriptors(person));/*{ name: {value: \"Lee\", writable: true, enumerable: true, configurable: false},}*/// 프로퍼티 추가가 금지된다.person.age = 20; // 무시. strict mode에서는 에러console.log(person); // {name: \"Lee\"}// 프로퍼티 삭제가 금지된다.delete person.name; // 무시. strict mode에서는 에러console.log(person); // {name: \"Lee\"}// 프로퍼티 값 갱신은 가능하다.Object.defineProperty(person, 'name', { value: 'Kim' });console.log(person); // {name: \"Kim\"}// 프로퍼티 어트리뷰트 재정의가 금지된다.Object.defineProperty(person, 'name', { configurable: true });// TypeError: Cannot redefine property: name 5.3. 객체 동결Object.freeze 메소드는 객체를 동결한다. 객체 동결(freeze)이란 프로퍼티 추가 및 삭제와 프로퍼티 어트리뷰트 재정의 금지, 프로퍼티 값 갱신 금지를 의미한다. 즉, 동결된 객체는 읽기만 가능하게 된다. 밀봉된 객체인지 여부는 Object.isFrozen 메소드로 확인 할 수 있다. 12345678910111213141516171819202122232425262728293031323334const person = { name: 'Lee' };// person 객체는 동결(freeze)된 객체가 아니다.console.log(Object.isFrozen(person)); // false// person 객체를 동결(freeze)하여 프로퍼티 추가, 삭제, 재정의, 쓰기를 금지한다.Object.freeze(person);// person 객체는 동결(freeze)된 객체다.console.log(Object.isFrozen(person)); // true// 동결(freeze)된 객체는 writable과 configurable가 false이다.console.log(Object.getOwnPropertyDescriptors(person));/*{ name: {value: \"Lee\", writable: false, enumerable: true, configurable: false},}*/// 프로퍼티 추가가 금지된다.person.age = 20; // 무시. strict mode에서는 에러console.log(person); // {name: \"Lee\"}// 프로퍼티 삭제가 금지된다.delete person.name; // 무시. strict mode에서는 에러console.log(person); // {name: \"Lee\"}// 프로퍼티 값 갱신이 금지된다.person.name = 'Kim'; // 무시. strict mode에서는 에러console.log(person); // {name: \"Lee\"}// 프로퍼티 어트리뷰트 재정의가 금지된다.Object.defineProperty(person, 'name', { value: 'Kim' });// TypeError: Cannot redefine property: name 5.4. 불변객체지금까지 살펴본 변경 방지 메소드들은 얕은 변경 방지(Shallow only)로 직속 프로퍼티만 변경이 방지되고 중첩 객체까지는 영향을 주지는 못하다. 따라서 Object.freeze 메소드로 객체를 동결하여도 중첩 객체까지 동결할 수 없다. 1234567891011121314const person = { name: 'Lee', address: { city: 'Seoul' }};// 얕은 객체 동결Object.freeze(person);console.log(Object.isFrozen(person)); // true// 중첩 객체까지 동결하지 못한다.console.log(Object.isFrozen(person.address)); // falseperson.address.city = 'Busan';console.log(person); // {name: \"Lee\", address: {city: \"Busan\"}} 객체의 중첩 객체까지 동결하여 변경이 불가능한 읽기 전용의 불변 객체(immutable object, “12.6. 참조에 의한 전달과 외부 상태의 변경” 참고)를 구현하려면 객체를 값으로 갖는 모든 프로퍼티에 대해 재귀적으로 Object.freeze 메소드를 호출해야 한다. 123456789101112131415161718192021222324252627282930function deepFreeze(target) { // 객체가 아니거나 동결된 객체는 무시하고 객체이고 동결되지 않은 객체만 동결한다. if (target &amp;&amp; typeof target === 'object' &amp;&amp; !Object.isFrozen(target)) { Object.freeze(target); /* 모든 프로퍼티를 순회하며 재귀적으로 동결한다. Object.keys 메소드는 객체 자신의 열거 가능한 프로퍼티 키를 배열로 반환한다. (\"19.15.2. Object.keys/values/entries 메소드\" 참고) forEach 메소드는 배열을 순회하며 배열의 각 요소에 대하여 콜백 함수를 실행한다. (\"27.9.2. Array.prototype.forEach\" 참고) */ Object.keys(target).forEach(key =&gt; deepFreeze(target[key])); } return target;}const person = { name: 'Lee', address: { city: 'Seoul' }};// 깊은 객체 동결deepFreeze(person);console.log(Object.isFrozen(person)); // true// 중첩 객체까지 동결한다.console.log(Object.isFrozen(person.address)); // trueperson.address.city = 'Busan';console.log(person); // {name: \"Lee\", address: {city: \"Seoul\"}}","link":"/2020/03/property_attribute/"},{"title":"Sass 세팅하기 및 변수에 대해서 | Sass(SCSS)","text":"SASS SCSS 차이 문법적 차이이며 요즘은 SCSS를 쓴다고 합니다. SCSS 세팅하기마음에 드는 변환기 아무거나 다운을 합니다. 필자는 를 사용함. SCSS 시작하기 코알라에서 작업할 디렉토리 선택하기 코알라 앱 내에서 scss 파일을 선택하여 compile 누른다. 그러면 css파일 코드 하단부에 sourceMappingURL=index.css.map이라는 것이 있습니다. 건들면 안됩니다. 12345678// 변수에 값 할당하기$color: red;$white: #fff;body { background: $color; color: $white;} 변수는 $(달러 사인)으로 시작 변수명를 줄 때는 영문 영문 + 숫자 영문 - _ 숫자 대소문자","link":"/2020/04/sass01/"},{"title":"Sass 선택자, mixin, include | Sass(SCSS)","text":"Sass 선택자 1234567&lt;div class=\"a\"&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;테스트1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\" class=\"aaa1\"&gt;테스트2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;테스트3&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 위 마크업을 scss로 선택자를 이용해 li를 선택하려면 12345678910111213141516.a { color: red; ul { border:1px solid red; &gt; li { border: 1px solid blue; a { text-decoration: none; &amp;:hover { color: red; } &amp;.aaa1 { color: blank;} } &amp;:last-child { border: 1px solid yellow }; } }} :hover 및 :last-child를 추가하고 싶을때는 해당 선택자 {}중괄호 안에서 &amp;:hover 추가 MixinMixin은 css의 keyframe이나 JS의 함수, 클래스와 비슷합니다. 반복되는 코드를 줄이기 위한 것 123456789101112// @mixin으로 기능저장 @mixin test{// Js로 생각하면 fn이라고 생각하면 됍니다. width:100px; height: 100px; border: 1px solid red;}div { // @include로 mixin을 만든 test 호출 @include test();} sass를 사용하지 않았을 때 .clear라는 css를 미리 만들어서 사용하죠? sass를 사용하면 간편하게 가능해집니다. 1234&lt;div&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt;&lt;/div&gt; 123456789101112@mixin clear { &amp;:after { content: \" \"; display: block; clear: both; }}div { @include clear() p { @include test(); }} Mixin 매개 변수를 활용해서 사용해보겠습니다. JS의 함수와 매우 비슷합니다. 12345@mixin border($color){ border: 1px solid $color;}div {@include border(blue); } 다른 예제입니다. 123456@mixin box($w, $h) { width: $w; height: $h;}div { @include box(300px, 400px); border: 1px solid red;}","link":"/2020/04/sass02/"},{"title":"Sass 문자보간에 대해서 | Sass(SCSS)","text":"#{}문자보간에 대해서 설명없이 예제를 보면 금방 이해됩니다. 바로 예제로 가겠습니다. 1234567// html&lt;div class=\"box\"&gt; test &lt;/div&gt;// scss$bx : box;div.#{$bx} { border: 1px solid red; } Mixin을 이용해서 만들어 볼게요. 1234567891011// html&lt;div&gt;Hi&lt;/div&gt;&lt;p&gt;Go&lt;/p&gt;// scss@mixin bx($position. $wid, $color) { border-#{$position}: $wid solid $color;}div { @include bx(left, 2px, blue);}p { @include bx(right, 10px , red);}","link":"/2020/04/sass03/"},{"title":"Sass @for 반목문과 @each 반복문 | Sass(SCSS)","text":"@for(반복문)에 대해서 @for에 변수명을 입력해서 작성한다. 보기쉽게 예제로 보자. 123456789101112131415161718192021// html&lt;ul class=\"list\"&gt; &lt;li class=\"ico1\"&gt;텍스트1&lt;/li&gt; &lt;li class=\"ico2\"&gt;텍스트2&lt;/li&gt; &lt;li class=\"ico3\"&gt;텍스트3&lt;/li&gt; &lt;li class=\"ico4\"&gt;텍스트4&lt;/li&gt; &lt;li class=\"ico5\"&gt;텍스트5&lt;/li&gt;&lt;/ul&gt;// 1부터 6미만(5까지)까지 반복을 하겠다.@for $i from 1 to 6 { .list .ico#{$i} { color: red; // 1.png ~ 4.png까지 자동으로 들어감 background-image:url(ico#{$i}.png); } .list li:nth-child(#{$i}):before { content: \"제목#{$i}\"; }} @each 반복문에 대해서 123456789&lt;h1 class=\"ico_book\"&gt;제목1&lt;/h1&gt;&lt;h1 class=\"ico_zoom\"&gt;제목2&lt;/h1&gt;&lt;h1 class=\"ico_phone\"&gt;제목3&lt;/h1&gt;@each $let in book, zoom, phone { .ico_#{$var}{ background: url(images/#{$var}.gif) no-repeat; }} 이제 감이 오셨죠? 한층 더 응용해볼게요. 123456789101112131415161718192021&lt;h1 class=\"ico_book\"&gt;제목1&lt;/h1&gt;&lt;h1 class=\"ico_zoom\"&gt;제목2&lt;/h1&gt;&lt;h1 class=\"ico_phone\"&gt;제목3&lt;/h1&gt;@each $let in book, zoom, phone { .ico_#{$var}{ background: url(images/#{$var}.gif) no-repeat; }}$heading:( h1: 30px, h2: 20px, h3: 15px)@each $elem, $v in $heading { #{$elem} { font-size: $v; }}","link":"/2020/04/sass04/"},{"title":"스코프 | javaScript","text":"1.스코프란?스코프(Scope, 유효범위)는 자바스크립트를 포함한 모든 프로그래밍 언어의 기본적이며 중요한 개념이다. 스코프의 이해가 부족하면 다른 개념을 이해하기 어려울 수 있다. 더욱이 자바스크립트의 스코프는 다른 언어의 스코프와 구별되는 특징을 가지므로 주의가 필요하다. 그리고 var 키워드로 선언한 변수와 let 또는 const 키워드로 선언한 변수의 스코프도 다르게 동작한다. 스코프는 변수 그리고 함수와 깊은 관련이 있다. 함수의 매개변수는 함수 몸체 내부에서만 참조할 수 있고 함수 몸체 외부에서는 참조할 수 없다고 했다. 이것은 매개변수를 참조할 수 있는 유효한 범위, 즉 매개변수의 스코프가 함수 몸체 내부로 한정되기 때문이다. 1234567891011function add(x, y) { // 매개변수는 함수 몸체 내부에서만 참조할 수 있다. // 즉, 매개변수의 스코프(유효범위)는 함수 몸체 내부이다. console.log(x, y); // 2 5 return x + y;}add(2, 5);// 매개변수는 함수 몸체 내부에서만 참조할 수 있다.console.log(x, y); // ReferenceError: x is not defined 변수는 코드의 가장 바깥 영역뿐만 아니라 코드 블록이나 함수 몸체 내에서도 선언할 수 있다. 이때 코드 블록이나 함수는 중첩될 수 있다. 12345678910111213141516171819202122var var1 = 1; // 코드의 가장 바깥 영역에서 선언된 변수if (true) { var var2 = 2; // 코드 블록 내에서 선언된 변수 if (true) { var var3 = 3; // 중첩된 코드 블록 내에서 선언된 변수 }}function foo() { var var4 = 4; // 함수 내에서 선언된 변수 function bar() { var var5 = 5; // 중첩된 함수 내에서 선언된 변수 }}console.log(var1); // 1console.log(var2); // 2console.log(var3); // 3console.log(var4); // ReferenceError: var4 is not definedconsole.log(var5); // ReferenceError: var5 is not defined 모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효 범위가 결정된다. 이를 스코프(Scope, 유효범위)라 한다. 즉, 스코프는 식별자가 유효한 범위를 말한다. 아래 예제가 어떻게 동작할지 생각해보자. 12345678910var x = 'global';function foo() { var x = 'local'; console.log(x); // ①}foo();console.log(x); // ② 자바스크립트 엔진은 이름이 같은 두개의 변수 중에서 어떤 변수를 참조해야 할 것인지를 결정해야 한다. 자바스크립트 엔진은 스코프를 통해 어떤 변수를 참조해야 할 것인지를 결정한다. 즉, 스코프란 자바스크립트 엔진이 식별자를 검색할 때 사용하는 규칙이라고도 할 수 있다. 자바스크립트 엔진은 코드를 실행할 때, 코드의 문맥(Context)를 고려한다. 코드가 어디서 실행되며 주변에 어떤 코드들이 있는지에 따라 위 예제의 ①과 ②처럼 동일한 코드도 다른 결과를 만들어 낸다. var 키워드로 선언한 변수의 중복 선언 var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언이 허용된다. 이는 의도치 않게 변수값이 재할당되어 변경되는 부작용을 발생시킨다.123456789function foo() { var x = 1; // var 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용한다. // 아래 변수 선언문은 자바스크립트 엔진에 의해 var 키워드가 없는 것처럼 동작한다. var x = 2; console.log(x); // 2}foo(); 하지만 let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다. 1234567function bar() { let x = 1; // let이나 const 키워드로 선언된 변수는 같은 스코프 내에서 중복 선언을 허용하지 않는다. let x = 2; // SyntaxError: Identifier 'x' has already been declared}bar(); 2. 스코프의 종류코드는 전역(global)과 지역(local)으로 구분할 수 있다. 이때 변수는 자신이 선언된 위치(전역 또는 지역)에 의해 자신이 유효한 범위인 스코프가 결정된다. 즉, 전역에서 선언된 변수는 전역 스코프를 갖는 전역 변수이고, 지역에서 선언된 변수는 지역 스코프를 갖는 지역 변수이다. 2.1. 전역과 전역 스코프전역이란 코드의 가장 바깥 영역을 말한다. 전역은 전역 스코프(global scope)를 만든다. 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수(global variable)가 된다. 전역 변수는 어디서든지 참조할 수 있다. 2.2. 지역과 지역 스코프지역이란 함수 몸체 내부를 말한다. 지역은 지역 스코프(local scope)를 만든다. 지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수(local variable)가 된다.지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서 유효하다. 3.스코프 체인함수는 전역에서 정의할 수도 있고 함수 몸체 내부에서 정의할 수도 있다. 함수 몸체 내부에서 함수가 정의된 것을 ‘함수의 중첩’이라 한다. 함수 몸체 내부에서 정의한 함수를 ‘중첩 함수(nested function)’, 중첩 함수를 포함하는 함수를 ‘외부 함수(outer function)’라고 부른다. 함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있다.이는 스코프는 함수의 중첩에 의해 계층적 구조를 갖는다는 것을 의미한다. 다시 말해 중첩 함수의 지역 스코프는 중첩 함수를 포함하는 외부 함수의 지역 스코프와 계층적 구조를 갖는다. 이떄 외부 함수의 지역 스코프를 중첩 함수의 상위 스코프라고 한다. 모든 지역 스코프의 최상위 스코프는 전역 스코프이다. 이렇게 스코프가 계층적으로 연결된 것을 스코프 체인(scope chain)이라 부른다. 위 그림에서 스코프 체인은 최상위 스코프인 전역 스코프, 전역에서 선언된 함수 outer의 지역 스코프, 함수 outer 내부에서 선언된 함수 inner의 지역 스코프로 이루어진다. 변수를 참조할 때, 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프에서 시작하여 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 이를 통해 상위 스코프에서 선언한 변수를 하위 스코프에서도 참조할 수 있다. 렉시컬 환경(Lexical Environment) 스코프 체인은 실행 컨텍스트(Execution Context)의 렉시컬 환경(Lexical Environment)을 단방향으로 연결(Channing)한 것이다. 전역 렉시컬 환경은 코드가 로드되면 곧바로 생성되고 함수의 렉시컬 환경은 함수가 호출되면 곧바로 생성된다. 이에 대해서는 “22. 실행 컨텍스트”에서 자세히 살펴보자.3.1. 스코프 체인에 의한 변수 검색자바스크립트 엔진은 스코프 체인을 따라 변수를 참조하는 코드의 스코프에서 상위 스코프 방향으로 이동하며 선언된 변수를 검색한다. 절대 하위 스코프로 내려가면 식별자를 검색하는 일은 없다. 이는 상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있지만 하위 스코프에서 유효한 변수를 상위 스코프에서 참조할 수 없다는 것을 의미한다. 스코프 체인으로 연결된 스코프의 계층적 구조는 부자 관계로 이루어진 상속(Inheritance)과 유사하다. 상속을 통해 부모의 자산을 자식이 자유롭게 사용할 수 있지만 자식의 자산을 부모가 사용할 수는 없다. 스코프 체인도 마찬가지 개념이다. 3.2. 스코프 체인에 의한 함수 검색아래 예제를 살펴보자. 전역에서 정의된 foo 함수와 bar 함수 내부에서 정의된 foo 함수가 있다. 123456789101112131415// 전역 함수function foo() { console.log('global function foo');}function bar() { // 중첩 함수 function foo() { console.log('local function foo'); } foo(); // ①}bar(); 함수 선언문으로 함수를 정의하면 자바스크립트 엔진에 의해 다른 코드가 실행되기 이전에 함수 객체가 먼저 생성된다. 그리고 자바스크립트 엔진은 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 생성된 함수 객체를 할당한다. ①에서 함수 foo를 호출하면 자바스크립트 엔진은 함수를 호출하기 위해 먼저 함수를 가리키는 변수 foo를 검색한다. 이처럼 함수도 변수에 할당되기 때문에 스코프를 갖는다. 따라서 스코프를 “변수를 검색할 때 사용하는 규칙”이라고 표현하기 보다는 “식별자를 검색하는 규칙”이라고 표현하는 것이 보다 적합하다. 4. 함수 레벨 스코프지역은 함수 몸체 내부를 말하고 지역은 지역 스코프를 만든다고 했다. 이는 코드 블록이 아닌 함수에 의해서만 지역 스코프가 생성된다는 의미이다. C나 Java 등 대부분의 프로그래밍 언어는 함수 몸체 만이 아니라 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만든다. 이러한 특성을 블록 레벨 스코프(Block level scope)라 한다. 하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정한다. 이러한 특성을 함수 레벨 스코프(Function level scope)라 한다. 아래 예제를 살펴보자. 1234567891011var x = 1;if (true) { // var 키워드로 선언된 변수는 함수의 코드 블록 만을 지역 스코프로 인정한다. // 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할 지라도 모두 전역 변수이다. // 따라서 x는 전역 변수이다. 이미 선언된 전역 변수 x가 있으므로 변수 x는 중복 선언된다. // 이는 의도치 않게 변수값이 변경되는 부작용을 발생시킨다. var x = 10;}console.log(x); // 10 전역 변수 x가 선언되었고 if 문의 코드 블록 내에도 변수 x가 선언되었다. 이때 if 문의 코드 블록 내에서 선언된 변수 x는 전역 변수다. var 키워드로 선언된 변수는 블록 레벨 스코프를 인정하기 때문에 함수 밖에서 선언된 변수는 코드 블록 내에서 선언되었다 할 지라도 모두 전역 변수이다. 따라서 전역 변수 x는 중복 선언되고 그 결과 의도치 않은 전역 변수의 값이 재할당된다. 하나 더 예제를 살펴보자. 123456789var i = 10;// for문에서 선언한 i는 전역 변수이다. 이미 선언된 전역 변수 i가 있으므로 중복 선언된다.for (var i = 0; i &lt; 5; i++) { console.log(i); // 0 1 2 3 4}// 의도치 않게 변수의 값이 변경되었다.console.log(i); // 5 var 키워드로 선언된 변수는 블록 레벨 스코프를 인정하지 않기 때문에 변수 i는 전역 변수가 된다. 따라서 전역 변수 i는 중복 선언되고 그 결과 의도치 않은 전역 변수의 값이 재할당된다. var 키워드로 선언된 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정하지만, ES6에서 도입된 let, const 키워드는 블록 레벨 스코프를 지원한다. 5. 렉시컬 스코프아래 예제의 실행 결과를 예측해보자. 12345678910111213var x = 1;function foo() { var x = 10; bar();}function bar() { console.log(x);}foo(); // ?bar(); // ? 렉시컬 스코프 또는 정적 스코프라 한다. 동적 스코프 방식처럼 상위 스코프가 동적으로 변하지 않고 함수 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되기 떄문에 정적 스코프라고 부른다. 자바스크립트를 비롯한 대부분의 프로그래밍 언어는 렉시컬 스코프를 따른다. 자바스크립트는 렉시컬 스코프를 따르므로 함수를 어디서 호출했는지가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.모든 함수 정의(함수 선언문 또는 함수 표현식)는 평가되어 함수 객체를 생성할 때, 자신이 정의된 스코프를 상위 스코프로서 기억한다.그리고 함수가 호출되면 언제나 자신이 기억하고 있는 자신이 정의된 스코프를 상위 스코프로 사용한다. 함수가 호출된 위치는 함수 자신이 기억하고 있는 스코프, 즉 상위 스코프 결정에 어떠한 영향을 주지 않는다. bar 함수가 호출되면 호출된 곳이 어디인지 관계없이 언제나 자신이 기억하고 있는 전역 스코프를 상위 스코프로 사용한다. 따라서 위 예제를 실행하면 전역 변수 x의 값 1을 두번 출력한다. 렉시컬 스코프는 클로저와 깊은 관계가 있다. 이에 대해서는 클로저에서 자세히 살펴보자!","link":"/2020/02/scope/"},{"title":"표현식과 문 | javaScript","text":"1. 값값(value)은 식(표현식, expression)이 평가(evaluate)되어 생성된 결과를 말합니다. 12345// 10 + 20은 평가되어 숫자값 30을 생성한다.10 + 20; // 30// 변수에는 10 + 20이 평가되어 숫자값 30을 변수에 할당한다.var sum = 10 + 20; # 2. 리터럴 리터럴은 값을 생성하는 가장 간단한 방법입니다. 즉, 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용하는 것입니다. 12345678910111213141516171819202122232425262728293031323334353637383940// 정수 리터럴100// 부동소수점 리터럴10.5// 2진수 리터럴0b010101// 8진수 리터럴(ES6에서 도입. 0o로 시작합니다.)0o101// 16진수 리터럴 (ES6에서 도입. 0x로 시작합니다.)0x41// 문자열 리터럴'Hello'\"World\"// 불리언 리터럴truefalse// null 리터럴null// undefined 리터럴undefined// 객체 리터럴{ name: 'Lee', address: 'Seoul' }// 배열 리터럴[ 1, 2, 3 ]// 함수 리터럴function() {}// 정규표현식 리터럴/[A-Z]+/g 3. 표현식표현식(expression)은 값으로 평가될 수 있는 문(statement)이다. 즉, 표현식이 평가되면 값을 생성하거나 값을 참조한다.앞서 살펴본 리터럴은 값으로 평가된다. 따라서 모든 식별자도 표현식이며 리터럴도 표현식인 셈이다. 1234567891011121314151617// 리터럴 표현식10'Hello'// 식별자 표현식 (선언이 이미 존재한다고 가정)sumperson.namearr[1]// 연산자 표현식10 + 20sum = 10sum !== 10// 함수/메소드 호출 표현식 (선언이 이미 존재한다고 가정)square()person.getName() 4. 문앞으로 자바스크립트를 설명할 때 “문(statement)”과 “표현식(expression)”이라는 용어가 자주 등장할 것이다. 따라서 문과 표현식은 확실히 이해할 필요가 있다. 문과 표현식을 구별하고 해석할 수 있다면 자바스크립트 엔진의 입장에서 코드를 읽을 수 있고 실행 결과 예측에 도움이 된다. 이는 버그를 줄이고 코드의 품질을 높여줄 것이다. 문(statement)은 프로그램을 구성하는 기본 단위이자 최소 실행 단위이다. 문의 집합으로 이루어진 것이 바로 프로그램이며 문을 작성하고 순서에 맞게 나열하는 것이 프로그래밍이다. 문은 여러 토큰들로 구성된다. 토큰(token)이란 문법적인 의미를 가지며, 문법적으로 더이상 나눌 수 없는 코드의 기본 요소를 의미한다. 예를 들어, 키워드, 식별자, 연산자, 리터럴, 세미콜론(;)이나 마침표(.) 등의 특수 기호는 문법적인 의미를 가지며, 문법적으로 더 이상 나눌 수 없는 코드의 기본 요소이므로 모두 토큰이다. 1234567891011121314// 변수 선언문var x;// 표현식 문(할당문)x = 5;// 함수 선언문function foo () {}// 조건문if (x &gt; 1) { console.log(x); }// 반복문for (var i = 0; i &lt; 2; i++) { console.log(i); } 5. 세미콜론과 세미콜론 자동 삽입 기능세미콜론( ; )은 문의 종료를 나타낸다. 따라서 문은 세미콜론으로 끝나야 한다. 단, 0개 이상의 문을 중괄호로 묶은 코드 블록 { … } 뒤에는 세미콜론을 붙이지 않는다. 예를 들어, if 문, for 문, 함수 등의 코드 블록 뒤에는 세미콜론을 붙이지 않는다. 이들 코드 블록은 언제나 문의 종료를 의미하는 자체 종결성(self closing)을 갖기 때문이다. 문의 끝에 붙이는 세미콜론은 옵션이다. 즉, 세미콜론은 생략 가능하다. 이는 자바스크립트 엔진이 소스 코드를 해석할 때, 문의 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이 암묵적으로 수행되기 때문이다. 하지만 세미콜론 자동 삽입 기능의 동작과 개발자의 예측이 일치하지 않는 경우가 간혹 있다. 정확히 말하면 아래 예제와 같이 개발자가 세미콜론 자동 삽입 기능의 동작을 제대로 예측하지 못해 제대로 활용하지 못하는 경우가 있다. 1234567891011121314function foo () { return {} // ASI의 동작 결과 =&gt; return; {}; // 개발자의 예측 =&gt; return {};}console.log(foo()); // undefinedvar bar = function () {}(function() {})();// ASI의 동작 결과 =&gt; var bar = function () {}(function() {})();// 개발자의 예측 =&gt; var bar = function () {}; (function() {})();// TypeError: (intermediate value)(...) is not a function 세미콜론을 반드시 붙여야 한다는 주장이 다수를 차지하지만 붙이지 말아야 한다 주장도 설득력이 있다. 하지만 ESLint와 같은 정적 분석 도구에서도 세미콜론 사용을 기본으로 설정하고 있고 (브랜든 아이크는 반대하고 있지만) TC39(ECMAScript 기술 위원회)도 세미콜론 사용을 권장하는 분위기이므로 이 책에서는 세미콜론을 붙이도록 하겠다. 6.표현식인 문과 표현식이 아닌 문표현식은 문의 일부일 수도 있고 그 자체로 문이 될 수도 있다. 123456// 변수 선언문은 값으로 평가될 수 없으므로 표현식이 아니다.var x;// 1, 2, 1 + 2, x = 1 + 2는 표현식이다.// x = 1 + 2은 표현식이면서 완전한 문이기도 하다.x = 1 + 2; 이처럼 표현식과 문은 유사하여 구별이 어렵다고 느낄 수 있다. 하지만 표현식과 문을 구별하는 방법은 의외로 간단하다. 표현식과 문을 구별하는 방법에 대해 살펴보자. 문에는 표현식인 문과 표현식이 아닌 문이 있다. 표현식인 문은 값으로 평가될 수 있는 문이며 표현식이 아닌 문은 값으로 평가될 수 없는 문을 말한다. 예를 들어 변수 선언문은 값으로 평가될 수 없다. 따라서 표현식이 아닌 문이다. 하지만 할당문은 값으로 평가될 수 있다. 따라서 표현식인 문이다. 표현식인 문과 표현식이 아닌 문을 구별하기 위한 가장 간단하고 명료한 방법은 변수에 할당해 보는 것이다. 표현식인 문은 값으로 평가되므로 변수에 할당할 수 있다. 하지만 표현식이 아닌 문은 값으로 평가할 수 없으므로 변수에 할당하면 에러가 발생한다. 아래 예제를 살펴보자. 12345// 변수 선언문은 표현식이 아닌 문이다.var x;// 할당문은 그 자체가 표현식이지만 완전한 문이기도 하다. 즉, 할당문은 표현식인 문이다.x = 100; 위 예제의 변수 선언문은 표현식이 아닌 문이다. 다시 말해 값으로 평가될 수 없다. 따라서 변수선언문은 값처럼 사용할 수 없다. 12// 표현식이 아닌 문은 값처럼 사용할 수 없다.var foo = var x; // SyntaxError: Unexpected token var","link":"/2020/02/statement/"},{"title":"1_Week | javaScript","text":"Webpack Babel eslint Prettier 커스터 마이징하기 실무에서는 현업을 위해 위에 4가지 툴이 필수라고 한다. 프론트엔드 신입으로 취업하기 위해 1주차 스터디의 내용을 정리 해볼게요. Webpack 시작하기","link":"/2020/04/study01/"},{"title":"Symbol | javaScript","text":"1. Symbol이란? 심볼은 ES6에서 새롭게 추가된 7번째 타입으로 변경 불가능한 원시 타입의 값이다.심볼 값은 다른 값과 중복되지 않는 유일 무이한 값이다. 따라서 주로 이름의 충돌 위험이 없는 유일한 프로퍼티 키를 만들기 위해 사용한다. 2. Symbol의 생성2.1 Symbol 함수 심볼 값은 Symbol 함수를 호출하여 생성한다. 다른 원시값, 즉 문자열, 숫자, 불리언, undefined, null 타입의 값은 리터럴 표기법을 통해 값을 생성할 수 있지만 심볼 값은 Symbol 함수를 호출하여 생성해야 한다. 이떄 생성된 심볼 값은 노출되지 않으며 다른 값과 절대 중복되지 않는 유일무이한 값이다. 123456// Symbol 함수를 호출하여 유일무이한 심볼 값을 생성한다.const mySymbol = symbol();// 심볼 값은 노출되지 않는다.console.log(mySymbol); // Symbol()console.log(typeof mySymbol); // symbol Symbol 함수는 String, Number, Boolean 생성자 함수와는 달리 new 연산자를 사용하지 않는다. new 연산자와 함께 생성자 함수 또는 클래스를 호출하면 객체(인스턴스)가 생성되지만 심볼 값은 변경 불가능한 원시 값이다. 1new Symbol(); // TypeError: Symbol is not a constructor Symbol 함수에는 선택적으로 문자열을 인수로 전달할 수 있다. 이 문자열은 생성된 심볼 값에 대한 설명으로 디버깅용도로만 사용되며 심볼 값 생성에 어떠한 영향도 주지 않는다. 12345// 심볼 값에 대한 설명이 같더라도 유일무이한 심볼 값을 생성한다.const mySymbol1 = Symbol('mySymbol');const mySymbol2 = Symbol('mySymbol');console.log(mySymbol1 === mySymbol2); // false 심볼 값도 문자열, 숫자, 불리언과 같이 객체처럼 접근하면 암묵적으로 레퍼 객체를 생성한다. 아래 예제의 description 프로퍼티와 toString 메소드는 Symbol.prototype의 프로퍼티이다. 12345// 심볼도 레퍼 객체를 생성한다const mySymbol = Symbol('mySymbol');console.log(mySymbol.description); // mySymbolconsole.log(mySymbol.toString()); // Symbol(mySymbol) 심볼 값은 암묵적으로 문자열이나 숫자 타입으로 변환되지 않는다. 12345const mySymbol = Symbol();// 심볼 값은 암묵적으로 타입 변환이 되지 않는다.console.log(mySymbol + ''); // TypeError: Cannot convert a Symbol value to a stringconsole.log(+mySymbol); // TypeError: Cannot convert a Symbol value to a string 단, 불리언 타입으로는 암묵적으로 타입 변환된다. 이를 통해 if문 등에서 존재 확인이 가능하다. 1234567const mySymbol = Symbol();// 불리언 타입으로는 암묵적으로 타입 변환된다console.log(!!mySymbol); // true// if 문 등에서 존재 확인을 위해 사용할 수 있다.if (mySymbol) console.log('mySymbol is not empty.'); 2.2 Symbol.for 메소드 Symbol.for 메소드는 인수로 전달받은 문자열을 키로 사용하여 키와 심볼 값의 쌍들이 저장되어 있는 전역 심볼 레지스트리(global symbol registry)에서 해당 키와 일치하는 심볼 값을 검색한다. 검색에 성공하면 새로운 심볼 값을 생성하지 않고 검색된 심볼 값을 반환한다.검색에 실패하면 새로운 심볼 값을 생성하여 Symbol.for 메소드의 인수로 전달된 키로 전역 Symbol 레지스트리에 저장한 후, 생성된 심볼 값을 반환한다. 123456// 전역 심볼 레지스트리에 mySymbol이라는 키로 저장된 심볼 값이 없으면 새로운 심볼 값을 생성const s1 = Symbol.for('mySymbol');// 전역 심볼 레지스트리에 mySymbol이라는 키로 저장된 심볼 값이 있으면 해당 심볼 값을 반환const s2 = Symbol.for('mySymbol');console.log(s1 === s2); // true Symbol.for 메소드를 사용하면 애플리케이션 전역에서 중복되지 않는 유일무이한 상수인 심볼 값을 단 하나만 생성하여 전역 심볼레지스트리를 통해 공유할 수 있다. Symbol.keyFor 메소드를 사용하면 전역 심볼 레지스트리에 저장된 심볼 값의 키를 추출할 수 있다. 12345// 전역 심볼 레지스트리에 mySymbol이라는 키로 저장된 심볼 값이 없으면 새로운 심볼 값을 생성const s = Symbol.for('mySymbol');// 전역 심볼 레지스트리에 저장된 심볼 값의 키를 추출console.log(Symbol.keyFor(s)); // mySymbol 3. Symbol과 상수예를 들어, 4방향 즉, 위, 아래, 오른쪽, 왼쪽을 나타내는 상수를 정의한다고 생각해 보자. 123456789101112131415// 위, 아래, 오른쪽, 왼쪽을 나타내는 상수.// 값 1, 2, 3, 4에는 특별한 의미가 없고 상수 이름에 의미가 있다const Direction = { UP: 1, DOWN: 2, LEFT: 3, RIGHT: 4};// 변수에 상수를 할당const myDirection = Direction.UP;if (myDirection === Direction.UP) { console.log('You are going UP.');} 위 예제와 같이 값에는 특별한 의미가 없고 상수 이름 자체에 의미가 있는 경우가 있다. 이때 문제는 상수값 1, 2, 3, 4가 다른 변수 값과 중복될 수 있다는 것이다. 이러한 경우, 중복될 가능성이 있는 무의미한 상수 대신 중복될 가능성이 없는 유일무이한 심볼 값을 사용할 수 있다. 123456789101112131415// 위, 아래, 오른쪽, 왼쪽을 나타내는 상수.// 중복될 가능성이 없는 심볼 값으로 상수값을 생성const Direction = { UP: Symbol('up'), DOWN: Symbol('down'), LEFT: Symbol('left'), RIGHT: Symbol('right')};// 변수에 상수를 할당const myDirection = Direction.UP;if (myDirection === Direction.UP) { console.log('You are going UP.');} 4. Symbol과 프로퍼티 키 객체의 프로퍼티 키는 빈 문자열을 포함하는 모든 문자열 또는 심볼 값으로 만들 수 있으며 동적으로 생성(Computed property name, “9.9.2 프로퍼티 키 동적 생성” 참고)할 수도 있다. 심볼 값으로 프로퍼티 키를 동적 생성하여 프로퍼티를 만들어 보자. 심볼 값으로 프로퍼티 키를 동적 생성하여 프로퍼티를 만들어 보자. 심볼 값을 프로퍼티 키로 사용하려면 프로퍼티 키로 사용할 심볼 값에 대괄호를 사용해야 한다. 프로퍼티에 접근할 때도 마찬가지로 대괄호를 사용해야 한다. 123456const obj = { // 심볼 값으로 프로퍼티 키를 동적 생성 [Symbol.for('mySymbol')]: 1};console.log(obj[Symbol.for('mySymbol')]); // 1 심볼 값은 유일무이한 값이므로 심볼 값으로 프로퍼티 키를 만들면 다른 프로퍼티 키와 절대 충돌하지 않는다. 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 미래에 추가될 어떤 프로퍼티 키와도 충돌할 위험이 없다. 5. Symbol과 프로퍼티 은닉 심볼 값으로 동적 생성한 프로퍼티 키로 만든 프로퍼티는 for…in 문이나 Object.keys, Object.getOwnPropertyNames 메소드로 찾을 수 없다. 이처럼 심볼 값으로 동적 생성한 프로퍼티 키로 프로퍼티를 만들면 프로퍼티를 숨길 수 있다. 123456789101112const obj = { // 심볼 값으로 프로퍼티 키를 동적 생성 [Symbol('mySymbol')]: 1};for (const key in obj) { console.log(key); // 아무것도 출력되지 않는다.}console.log(Object.keys(obj)); // []console.log(Object.getOwnPropertyNames(obj)); // [] 하지만 프로퍼티를 완전하게 숨길 수 있는 것은 아니다. ES6에서 도입된 Object.getOwnPropertySymbols 메소드를 사용하면 심볼 값으로 동적 생성한 프로퍼티 키로 만든 프로퍼티를 찾을 수 있다. 1234567891011const obj = { // 심볼 값으로 프로퍼티 키를 동적 생성 [Symbol('mySymbol')]: 1};// ES6 : getOwnPropertySymbolsconsole.log(Object.getOwnPropertySymbols(obj)); // [Symbol(mySymbol)]// 심볼 값을 찾을 수 있다.const symbolKey1 = Object.getOwnPropertySymbols(obj)[0];console.log(obj[symbolKey1]); // 1 6. Symbol과 표준 빌트인 객체 확장 일반적으로 표준 빌트인 객체에 사용자 정의 메소드를 직접 추가하여 확장하는 것은 권장하지 않는다. 1234567// 표준 빌트인 객체를 확장하는 것은 권장하지 않는다.// 즉, Array.prototype은 읽기 전용으로 사용하는 것이 좋다.Array.prototype.sum = function () { return this.reduce((p, c) =&gt; p + c, 0);};console.log([1, 2].sum()); // 3 그 이유는 개발자가 직접 추가한 메소드와 미래에 표준 사양으로 추가될 메소드가 이름이 중복될 수 있기 때문이다. 예를 들어, Array.prototype.find 메소드가 ES6에서 새롭게 도입되기 이전에 Array.prototype에 사용자 정의 find 메소드를 직접 추가했다면 새롭게 도입된 ES6의 Array.prototype.find 메소드와 이름이 중복되어 ES6의 Array.prototype.find 메소드를 이전에 추가했던 사용자 정의 find 메소드가 덮어쓴다. 표준 빌트인 메소드를 사용자 정의 메소드가 덮어쓴다면 문제가 된다. 하지만 중복될 가능성이 없는 심볼 값으로 프로퍼티 키를 생성하여 표준 빌트인 객체를 확장하면 표준 빌트인 객체의 기존 프로퍼티 키와 충돌하지 않는 것은 물론, 버전이 올라감에 따라 추가될지 모르는 어떤 프로퍼티 키와도 충돌할 위험이 없어 안전하게 표준 빌트인 객체를 확장할 수 있다. 123456// 심볼 값으로 프로퍼티 키를 동적 생성하면 다른 프로퍼티 키와 절대 충돌하지 않는다.Array.prototype[Symbol.for('sum')] = function () { return this.reduce((p, c) =&gt; p + c, 0);};console.log([1, 2][Symbol.for('sum')]()); // 3","link":"/2020/04/symbol/"},{"title":"this | javaScript","text":"1. this 객체 리터럴 방식으로 생성한 객체의 경우, 메소드 내부에서 메소드 자신이 속한 객체를 가리키는 식별자를 재귀적으로 참조할 수 있다. this는 자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수(Self-referencing variable)이다. this를 통해 자신이 속한 객체 또는 자신이 생성할 인스턴스의 프로퍼티나 메소드를 참조할 수 있다. this는 자바스크립트 엔진에 의해 암묵적으로 생성되며 코드 어디에서든지 참조할 수 있다. 함수를 호출하면 arguments 객체와 this가 암묵적으로 함수 내부에 전달된다. 함수 내부에서 arguments 객체를 지역 변수처럼 사용할 수 있는 것처럼 this도 지역 변수처럼 사용할 수 있다. 단, this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다. 바인딩 바인딩(binding)이란 식별자와 값을 연결하는 과정을 의미한다.객체 리터럴의 메소드 내부에서의 this는 메소드를 호출한 객체, 즉 circle을 가리킨다. 1234567891011121314// 생성자 함수function Circle(radius) { // this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius;}Circle.prototype.getDiameter = function () { // this는 생성자 함수가 생성할 인스턴스를 가리킨다. return 2 * this.radius;};// 인스턴스 생성const circle = new Circle(5);console.log(circle.getDiameter()); // 10 자바스크립트의 this는 함수가 호출되는 방식에 따라 this에 바인딩될 값, 즉 this 바인딩이 동적으로 결정된다. this는 코드 어디든지 참조가능하다. 전역에서도 함수 내부에서도 참조할 수 있다. 12345678910111213141516171819202122232425262728// this는 어디서든지 참조 가능하다.// 전역에서 this는 전역 객체 window를 가리킨다.console.log(this); // windowfunction square(number) { // 일반 함수 내부에서 this는 전역 객체 window를 가리킨다. console.log(this); // window return number * number;}square(2);const person = { name: 'Lee', getName() { // 메소드 내부에서 this는 메소드를 호출한 객체를 가리킨다. console.log(this); // {name: \"Lee\", getName: ƒ} return this.name; }};console.log(person.getName()); // Leefunction Person(name) { // 생성자 함수 내부에서 this는 생성자 함수가 생성할 인스턴스를 가리킨다. console.log(this); // Person { name: \"Lee\" } this.name = name;}const me = new Person('Lee'); 2.함수 호출 방식과 this 바인딩 this가 가리키는 값, 즉 this 바인딩은 함수의 호출 방식, 즉 함수가 어떻게 호출되었는지에 따라 동적으로 결정된다. 2.1 일반 함수 호출 기본적으로 this에는 전역 객체(Global object)가 바인딩된다. 12345678function foo() { console.log(\"foo's this: \", this); // window function bar() { console.log(\"bar's this: \", this); // window } bar();}foo(); 일반 함수로 호출하면 함수 내부의 this에는 전역 객체가 바인딩된다.다만, this는 객체의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수이므로 객체를 생성하지 않는 일반 함수에서 this는 의미가 없다. 따라서 아래 예제처럼 strict mode가 적용된 일반 함수 내부의 this에는 undefined가 바인딩된다. 12345678910function foo() { 'use strict'; console.log(\"foo's this: \", this); // undefined function bar() { console.log(\"bar's this: \", this); // undefined } bar();}foo(); 메소드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 중첩 함수 내부의 this에는 전역 객체가 바인딩된다. 123456789101112131415161718192021222324// var 키워드로 선언한 변수 value는 전역 객체의 프로퍼티이다.var value = 1;// const 키워드로 선언한 변수 value는 전역 객체의 프로퍼티가 아니다.// const value = 1;const obj = { value: 100, foo() { console.log(\"foo's this: \", this); // {value: 100, foo: ƒ} console.log(\"foo's this.value: \", this.value); // 100 // 메소드 내에서 정의한 중첩 함수 function bar() { console.log(\"bar's this: \", this); // window console.log(\"bar's this.value: \", this.value); // 1 } // 메소드 내에서 정의한 중첩 함수도 일반 함수로 호출되면 // 중첩 함수 내부의 this에는 전역 객체가 바인딩된다. bar(); }};obj.foo(); 콜백 함수 내부의 this에도 전역 객체가 바인딩된다. 어떠한 함수라도 일반 함수로 호출되면 this에 전역 객체가 바인딩된다. 123456789101112131415var value = 1;const obj = { value: 100, foo() { console.log(\"foo's this: \", this); // {value: 100, foo: ƒ} // 콜백 함수 내부의 this에는 전역 객체가 바인딩된다. setTimeout(function () { console.log(\"callback's this: \", this); // window console.log(\"callback's this.value: \", this.value); // 1 }, 100); }};obj.foo(); 이처럼 일반 함수로 호출된 모든 함수(중첩 함수, 콜백 함수 포함) 내부의 this에는 전역 객체가 바인딩된다. 자바스크립트는 this를 명시적으로 바인딩할 수 있는 Function.prototype.apply, Function.prototype.call, Function.prototype.bind 메소드를 제공한다. 12345678910111213var value = 1;const obj = { value: 100, foo() { // 콜백 함수에 명시적으로 this를 바인딩한다. setTimeout(function () { console.log(this.value); // 100 }.bind(this), 100); }};obj.foo(); 2.2. 메소드 호출 메소드 내부의 this는 메소드를 호출한 객체, 즉 메소드 이름 앞의 마침표(.) 연산자 앞에 기술한 객체에 바인딩된다. 12345678910const person = { name: 'Lee', getName() { // 메소드의 this는 메소드를 호출한 객체에 바인딩된다. return this.name; }};// 메소드 getName을 호출한 객체는 person이다.console.log(person.getName()); 123456789101112131415function Person(name) { this.name = name;}Person.prototype.getName = function () { return this.name;};const me = new Person('Lee');// getName 메소드를 호출한 객체는 me이다.console.log(me.getName()); // ① LeePerson.prototype.name = 'Kim';// getName 메소드를 호출한 객체는 Person.prototype이다.console.log(Person.prototype.getName()); // ② Kim ①의 경우, getName 메소드를 호출한 객체는 me이다. 따라서 getName 메소드 내부의 this는 me를 가리키며 this.name은 ‘Lee’이다. ②의 경우, getName 메소드를 호출한 객체는 Person.prototype이다. Person.prototype도 객체이므로 직접 메소드를 호출할 수 있다. 따라서 getName 메소드 내부의 this는 Person.prototype를 가리키며 this.name은 ‘Kim’이다. 2.3. 생성자 함수 호출 생성자 함수 내부의 this에는 생성자 함수가 (미래에) 생성할 인스턴스가 바인딩된다. 1234567891011121314151617// 생성자 함수function Circle(radius) { // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}// 인스턴스의 생성// 반지름이 5인 Circle 객체를 생성const circle1 = new Circle(5);// 반지름이 10인 Circle 객체를 생성const circle2 = new Circle(10);console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 20 2.4. Function.prototype.apply/call/bind 메소드에 의한 간접 호출 Function.prototype.apply, Function.prototype.call 메소드는 인수로 this와 인수 리스트를 전달받아 함수를 호출한다.apply와 call 메소드는 Function.prototype의 메소드이다. 즉, apply와 call 메소드는 Function 생성자 함수를 constructor 프로퍼티로 가리키는 모든 함수가 상속받아 사용할 수 있다. apply와 call 메소드의 사용 방법은 아래와 같다. 1234567891011121314/** * 주어진 this 바인딩과 인수 리스트 배열을 사용하여 함수를 호출한다. * @param thisArg - this로 사용될 객체 * @param argsArray - 함수에게 전달할 인수 리스트의 배열 또는 유사 배열 객체 * @returns 호출된 함수의 반환값 */Function.prototype.apply(thisArg[, argsArray])/** * 주어진 this 바인딩과 인수 리스트를 사용하여 함수를 호출한다. * @param thisArg - this로 사용될 객체 * @param arg1, arg2, ... - 함수에게 전달할 인수 리스트 * @returns 호출된 함수의 반환값 */Function.prototype.call (thisArg[, arg1[, arg2[, ...]]]) 아래 예제를 살펴보자 123456789101112function getThisBinding() { return this;}// this로 사용할 객체const thisArg = { a: 1 };console.log(getThisBinding()); // window// 함수(getThisBinding)를 호출하면서 인수로 전달한 객체를 호출한 함수의 this에 바인딩한다.console.log(getThisBinding.apply(thisArg)); // Object { a: 1 }console.log(getThisBinding.call(thisArg)); // Object { a: 1 } apply와 call 메소드의 본질적인 기능은 함수를 호출하는 것이다. apply와 call 메소드는 함수를 호출하면서 첫번째 인수로 전달한 특정 객체를 호출한 함수의 this에 바인딩한다. apply와 call 메소드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 동일하게 동작한다. 위 예제는 호출할 함수,즉 getThisBinding 함수에 인수를 전달하지 않는다.apply와 call 메소드를 통해 getThisBinding 함수를 호출하면서 인수를 전달해 보자. 123456789101112131415161718function getThisBinding() { console.log(arguments); return this;}// this로 사용할 객체const thisArg = { a: 1 };// 함수(getThisBinding)를 호출하면서 인수로 전달한 객체를 호출한 함수의 this에 바인딩한다.// apply 메소드는 호출할 함수의 인수를 배열로 묶어 전달한다.console.log(getThisBinding.apply(thisArg, [1, 2, 3]));// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]// { a: 1 }// call 메소드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다.console.log(getThisBinding.call(thisArg, 1, 2, 3));// Arguments(3) [1, 2, 3, callee: ƒ, Symbol(Symbol.iterator): ƒ]// { a: 1 } apply 메소드는 호출할 함수의 인수를 배열로 묶어 전달한다. call 메소드는 호출할 함수의 인수를 쉼표로 구분한 리스트 형식으로 전달한다. 이처럼 apply와 call 메소드는 호출할 함수에 인수를 전달하는 방식만 다를 뿐 this로 사용할 객체를 전달하면서 함수를 호출하는 것은 동일하다. apply와 call 메소드의 대표적인 용도는 arguments 객체와 같은 유사 배열 객체에 배열 메소드를 사용하는 경우이다. arguments 객체는 배열이 아니기 때문에 Array.prototype.slice와 같은 배열의 메소드를 사용할 수 없으나 apply와 call 메소드를 이용하면 가능하다. 12345678910111213function convertArgsToArray() { console.log(arguments); // arguments 객체를 배열로 변환 // slice: 배열의 특정 부분에 대한 복사본을 생성한다. const arr = Array.prototype.slice.apply(arguments); // const arr = Array.prototype.slice.call(arguments); console.log(arr); return arr;}convertArgsToArray(1, 2, 3); // [ 1, 2, 3 ] Function.prototype.bind 메소드는 apply와 call 메소드와는 달리 함수를 호출하지 않고 this로 사용할 객체만을 전달한다. 123456789101112function getThisBinding() { return this;}// this로 사용할 객체const thisArg = { a: 1 };// bind 메소드는 함수에 this로 사용할 객체를 전달한다.// bind 메소드는 함수를 호출하지는 않는다.console.log(getThisBinding.bind(thisArg)); // getThisBinding// bind 메소드는 함수를 호출하지는 않으므로 명시적으로 호출해야 한다.console.log(getThisBinding.bind(thisArg)()); // {a: 1} bind 메소드는 메소드의 this와 메소드 내부의 중첩 함수 또는 콜백 함수의 this가 불일치하는 문제를 해결하기 위해 유용하게 사용된다. 123456789101112131415161718function Person(name) { this.name = name;}Person.prototype.doSomething = function (callback) { // ① callback();};function foo() { console.log(this.name); // ②}const person = new Person('Lee');person.doSomething(foo); // ''// =&gt; window.name은 브라우저 창의 이름을 나타내는 빌트인 프로퍼티이다. window.name의 기본값은 ''이다.// 만약 Node.js 환경에서 실행하면 undefined가 출력된다. 콜백 함수 foo가 호출되기 이전인 ①의 시점에서 this는 doSomething 메소드를 호출한 객체, 즉 person 객체를 가리킨다. 그러나 콜백 함수 foo가 일반 함수로서 호출된 ②의 시점에서 this는 전역 객체 window를 가리킨다. 따라서 foo 함수 내부에서 참조한 this.name은 window.name과 같다. 이때 위 예제에서 콜백 함수 foo는 외부 함수 doSomething를 돕는 헬퍼 함수(보조 함수)의 역할을 하기 때문에 외부 함수 doSomething 내부의 this와 콜백 함수 내부의 this가 상이하면 문맥상 문제가 발생한다. 따라서 콜백 함수 내부의 this를 콜백 함수를 호출하는 외부 함수 내부의 this와 일치시켜 주어야 한다. 이때 bind 메소드를 사용하여 this를 일치시킬 수 있다. 물론 apply와 call 메소드를 사용할 수도 있다. 123456789101112131415161718function Person(name) { this.name = name;}Person.prototype.doSomething = function (callback) { // ① callback.bind(this)(); // callback.apply(this); // callback.call(this);};function foo() { console.log(this.name); // ②}const person = new Person('Lee');person.doSomething(foo); // Lee 지금까지 함수 호출 방식에 따라 this 바인딩이 동적으로 결정되는 것에 대해 살펴보았다. 이를 정리해 보면 아래와 같다 함수 호출 방식 this 바인딩 일반 함수 호출 전역 객체 메소드 호출 메소드를 호출한 객체 생성자 함수 호출 생성자 함수가 (미래에) 생성할 인스턴스 Function.prototype.apply/call/bind 메소드에 의한 간접 호출 Function.prototype.apply/call/bind 메소드에 인자로 전달한 객체","link":"/2020/03/this/"},{"title":"전역 변수의 문제점 | javaScript","text":"전역 변수의 무분별한 사용은 위험하다. 전역 변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역 변수를 사용하여야 한다. 전역 변수의 문제점과 전역 변수의 사용을 억제할 수 있는 방법에 대해 살펴보도록 하자. 1. 변수의 생명 주기 1.1. 지역 변수의 생명 주기변수는 선언에 의해 생성되고 할당을 통해 값을 갖는다. 그리고 언젠가 소멸한다. 즉, 변수는 생물과 유사하게 생성되고 소멸되는 생명 주기(Life cycle)가 있다. 변수에 생명 주기가 없다면 한번 선언된 변수는 프로그램을 종료하지 않는 한 영원히 메모리 공간을 점유하게 된다. 변수는 자신이 선언된 위치에서 생성되고 소멸한다. 전역 변수의 생명 주기는 애플리케이션의 생명 주기와 같다. 하지만 함수 내부에서 선언된 지역 변수는 함수가 호출되면 생성되고 함수가 종료하면 소멸한다. 아래 예제를 살펴보자. 12345678function foo() { var x = 'local'; console.log(x); // local return x;}foo();console.log(x); // ReferenceError: x is not defined 지역 변수 x는 foo 함수가 호출되기 이전까지는 생성되지 않는다. foo 함수를 호출하지 않으면 함수 내부의 변수 선언문이 실행되지 않기 때문이다. “4.4. 변수 선언의 실행 시점과 변수 호이스팅”에서 살펴보았듯이 변수 선언은 다른 코드가 실행되기 이전에 변수 선언이 어디에 있던지 상관없이 가장 먼저 실행된다. 다시 말해, 변수 선언은 코드가 한 줄씩 순차적으로 실행되는 시점인 런타임(runtime)에 실행되는 것이 아니라 런타임 이전 단계에서 자바스크립트 엔진에 의해 먼저 실행된다. 그런데 엄밀히 말하자면 위 설명은 전역 변수에 한정된 것이다. 함수 내부에서 선언한 변수는 함수가 호출된 직후에 함수 몸체의 다른 코드가 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 위 예제의 foo 함수를 호출하면 함수 몸체의 다른 문들이 순차적으로 실행되기 이전에 변수 x의 선언문이 자바스크립트 엔진에 의해 가장 먼저 실행되어 변수 x가 선언되고 undefined로 초기화된다. 그 후, 함수 몸체의 문들이 순차적으로 실행되기 시작하고 변수 할당문이 실행되면 변수 x에 값이 할당된다. 그리고 함수가 종료하면 변수 x도 소멸되어 생명 주기가 종료된다. 따라서 함수 내부에서 선언된 지역 변수 x는 foo 함수가 호출되어 실행되는 동안에만 유효하다. 즉, 지역 변수의 생명 주기는 함수의 생명 주기와 일치한다. 지역 변수의 생명 주기 위 예제를 조금 변형한 퀴즈를 풀어보자. 아래 예제의 ①에서 출력되는 값은 무엇인가? 12345678910var x = 'gloabl';function foo() { console.log(x); // ① var x = 'local'; return x;}foo();console.log(x); // gloabl 함수 foo 내부에서 선언된 지역 변수 x는 ①의 시점에 이미 선언되고 undefined로 초기화 되었다. 따라서 전역 변수 x를 참조하는 것이 아니라 지역 변수 x를 참조하여 값을 출력한다. 즉, 지역 변수는 함수 전체에서 유효하다. 단, 변수 할당문이 실행되기 이전까지는 undefined 값을 갖는다.이처럼 호이스팅은 스코프를 단위로 동작한다. 전역 변수의 호이스팅은 전역 변수의 선언이 전역 스코프의 선두로 끌어 올려진 것처럼 동작한다. 따라서 전역 변수는 전역 전체에서 유효하다. 지역 변수의 호이스팅은 지역 변수의 선언이 지역 스코프의 선두로 끌어 올려진 것처럼 동작한다. 따라서 지역 변수는 함수 전체에서 유효하다. 즉, 호이스팅은 변수 선언이 스코프의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 말한다. 1.2. 전역 변수의 생명 주기함수와는 달리 전역 코드는 명시적인 호출없이 실행된다. 다시 말해 전역 코드는 함수 호출과 같이 전역 코드를 실행하는 특별한 진입점(entry point)이 없고 코드가 로드되자마자 곧바로 해석되고 실행된다.진입점(entry point)C나 Java으로 작성된 코드를 실행하면 가장 먼저 main 함수가 호출된다. 이 main 함수는 프로그램이 시작되는 지점이므로 이를 진입점 또는 시작점이라고 한다.함수는 함수 몸체의 마지막 문 또는 return 문이 실행되면 종료한다. 하지만 전역 코드에는 return 문을 사용할 수 없으므로 마지막 문이 실행되어 더 이상 실행할 문이 없을 때 종료한다. return 문의 위치return 문은 함수 몸체 내부에서만 사용할 수 있다. 전역에서 return 문을 사용하면 문법 에러(SyntaxError: Illegal return statement)가 발생한다. 참고로 Node.js는 모듈 시스템에 의해 파일 별로 독립적인 파일 스코프를 갖는다. 따라서 Node.js 환경에서는 파일의 가장 바깥 영역에 return 문을 사용해도 에러가 발생하지 않는다.var 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 된다. 이는 전역 변수의 생명 주기가 전역 객체의 생명 주기와 일치한다는 것을 말한다. 전역 객체전역 객체(Global Object)는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 생성되는 특수한 객체이다. 전역 객체는 클라이언트 사이드 환경(브라우저)에서는 window, 서버 사이드 환경(Node.js)에서는 global 객체를 의미한다.전역 객체에는 표준 빌트인 객체(Object, String, Number, Function, Array…)들과 환경에 따른 호스트 객체(클라이언트 web API 또는 Node.js의 호스트 API), 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. 전역 객체에 대해서는 “21.4. 전역 객체” 그리고 “23. 실행 컨텍스트”에서 자세히 살펴볼 것이다.브라우저 환경에서 전역 객체는 window이므로 브라우저 환경에서 var 키워드로 선언한 전역 변수는 전역 객체 window의 프로퍼티이다. 이 전역 객체 window는 웹페이지를 종료하기 전까지 유효하다. 따라서 브라우저 환경에서 var 키워드로 선언한 전역 변수는 웹페이지를 종료할 때까지 유효하다. 즉, 전역 변수의 생명 주기는 전역 객체의 생명 주기와 일치한다. 전역 변수의 생명 주기 2. 전역 변수의 문제점암묵적 결합전역 변수를 선언한 의도는 전역, 즉 코드 어디에서든지 전역 변수를 사용하겠다는 것이다. 이는 모든 코드가 전역 변수를 참조하고 변경할 수 있는 암묵적 결합(implicit coupling)을 허용하는 것으로 변수의 유효 범위가 크면 클수록 코드의 가독성은 나빠지고 의도치 않게 상태가 변경될 수 있는 위험성도 높아진다. 긴 생명 주기전역 변수는 생명 주기가 길다. 따라서 메모리 리소스도 오랜 기간 소비한다. 또한 전역 변수의 상태를 변경할 수 있는 시간도 길고, 모든 함수가 참조할 수 있기 때문에 상태를 변경할 기회도 많다. 더욱이 var 키워드는 변수의 중복 선언을 허용하므로 생명 주기가 긴 전역 변수는 변수 이름이 중복될 가능성이 있다. 변수 이름이 중복되면 의도치 않은 재할당이 이루어진다. 12345678var x = 1;// ...// 변수의 중복 선언. 기존 변수에 값을 재할당한다.var x = 100;console.log(x); // 100 지역 변수는 전역 변수보다 생명 주기가 휠씬 짧다. 크지 않은 함수의 지역 변수는 생존 시간이 극히 짧다. 따라서 지역 변수의 상태를 변경할 수 있는 시간도 짧고 기회도 적다. 이는 전역 변수보다 상태 변경에 의한 오류가 발생할 확률이 작다는 것을 의미한다. 또한 메모리 리소소도 짧은 기간만 소비한다.스코프 체인 상에서 종점에 존재전역 변수는 또 하나의 문제는 스코프 체인 상에서 종점에 존재한다는 것이다. 이는 변수를 검색할 때 전역 변수가 가장 마지막에 검색된다는 것을 말한다. 즉, 전역 변수의 검색 속도가 가장 느리다. 검색 속도의 차이는 그다지 크지 않지만 속도의 차이는 분명히 있다. 네임 스페이스 오염자바스크립트에서 가장 큰 문제점 중의 하나는 파일이 분리되어 있다하여도 하나의 전역 스코프를 공유한다는 것이다. 따라서 다른 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 예상치 못한 결과를 가져올 수 있다. #3. 전역 변수 사용 억제 방법전역 변수의 무분별한 사용은 위험하다. 전역 변수를 반드시 사용하여야 할 이유를 찾지 못한다면 지역 변수를 사용하여야 한다. 변수의 스코프는 좁을수록 좋다. 전역 변수를 절대 사용하지 말라는 의미는 아니다. 무분별한 전역 변수의 남발은 억제해야 한다는 것이다. 전역 변수의 사용을 억제할 수 있는 몇가지 방법에 대해 살펴보자. 3.1. 즉시 실행 함수함수의 정의와 동시에 호출되는 즉시 실행 함수는 단 한번만 호출된다. 모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다. 이러한 특성을 이용해 전역 변수의 사용을 제한하는 방법이다. 123456(function () { var foo = 10; // 즉시 실행 함수의 지역 변수 // ...}());console.log(foo); // ReferenceError: foo is not defined 이 방법을 사용하면 전역 변수를 생성하지 않으므로 라이브러리 등에 자주 사용된다. 3.2. 네임 스페이스 객체전역에 네임 스페이스(Namespace) 역할을 담당할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가하는 방법이다. 1234567891011121314var MYAPP = {}; // 전역 네임 스페이스 객체MYAPP.name = 'Lee';console.log(MYAPP.name); // Lee네임 스페이스 객체에 또 다른 네임 스페이스 객체를 프로퍼티로 추가하여 네임 스페이스를 계층적으로 구성할 수도 있다.var MYAPP = {}; // 전역 네임 스페이스 객체MYAPP.person = { name: 'Lee', address: 'Seoul'};console.log(MYAPP.person.name); // Lee 네임 스페이스를 분리하여 식별자 충돌을 방지하는 효과는 있으나 네임 스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용해 보이지는 않는다. 3.3. 모듈 패턴모듈 패턴은 클래스를 모방하여 관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다. 모듈 패턴은 자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다. 모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다는 것이다. 캡슐화는 외부에 공개될 필요가 없는 정보를 외부에 노출시키지 않고 숨기는 것을 말하며 정보 은닉(information hiding)이라고도 한다. Java의 경우, 클래스를 구성하는 멤버에 대하여 public, private, protected 등의 접근 제한자(Access modifier)를 사용해 공개 범위를 한정할 수 있다. public으로 선언된 데이터 또는 메소드는 외부에서 접근이 가능하지만 private으로 선언된 경우는 외부에서 접근할 수 없고 내부에서만 사용된다. 이것은 클래스 외부에는 제한된 접근 권한을 제공하며 원하지 않는 외부의 접근에 대해 내부를 보호하는 기능을 한다. 하지만 자바스크립트는 public, private, protected 등의 접근 제한자를 제공하지 않는다. 모듈 패턴은 전역 네임 스페이스의 오염을 막는 기능은 물론 한정적이기는 하지만 캡슐화를 구현하기 위해 사용한다. 12345678910111213141516171819202122var Counter = (function () { // private 변수 var num = 0; // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다. return { increase() { return ++num; }, decrease() { return --num; } };}());// private 변수는 외부로 노출되지 않는다.console.log(Counter.num); // undefinedconsole.log(Counter.increase()); // 1console.log(Counter.increase()); // 2console.log(Counter.decrease()); // 1console.log(Counter.decrease()); // 0 위 예제의 즉시 실행 함수는 객체를 반환한다. 이 객체에는 외부에 노출하고 싶은 변수나 함수를 담아 반환한다. 이때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버(public menber)이다. 외부로 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근할 수 없는 프라이빗 멤버(private member)가 된다. 3.4. ES6 모듈전역 변수의 남발을 억제하기 위해 ES6에서 도입된 모듈을 사용할 수도 있다. 모던 브라우저(Chrome 61, FF 60, SF 10.1, Edge 16 이상)에서 ES6 모듈을 사용할 수 있다. script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 모듈의 파일 확장자는 mjs를 권장한다. 12&lt;script type=\"module\" src=\"lib.mjs\"&gt;&lt;/script&gt;&lt;script type=\"module\" src=\"app.mjs\"&gt;&lt;/script&gt; 하지만 ES6 모듈은 IE를 포함한 구형 브라우저는 동작하지 않으며, 브라우저의 ES6 모듈 기능을 사용하더라도 트랜스파일링이나 번들링이 필요하기 때문에 아직까지는 브라우저가 지원하는 ES6 모듈 기능보다는 Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.ES6 모듈 그리고 Webpack 등의 모듈 번들러를 도입하기 위한 방법에 대해서는 “ES6 모듈”, “Babel과 Webpack을 이용한 ES6 환경 구축”에서 자세히 살펴보기로 하자.","link":"/2020/02/var/"},{"title":"변수 | javaScript","text":"1. 변수란 무엇인가? 변수(Variable)는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 메모리 공간을 식별하기 위해 붙인 이름을 말한다. 간단히 말하자면 변수는 프로그래밍 언어에서 값을 저장하고 참조하는 매커니즘으로 값의 위치를 가리키는 상징적인 이름이다. 상징적 이름인 변수는 프로그래밍 언어의 컴파일러 또는 인터프리터에 의해 값이 저장된 메모리 공간의 주소로 치환되어 실행된다. 따라서 개발자가 직접 메모리 주소를 통해 값에 저장하고 참조할 필요가 없고 변수를 통해 안전하게 값에 접근할 수 있다. 1234567891011121314// 변수는 하나의 값을 저장하기 위한 수단이다.var userName = 'Namkwon';var userRole = 'Admin';// 객체나 배열과 같은 자료 구조를 사용하면 여러 개의 값을 하나로 그룹화하여 하나의 값처럼 사용할 수 있다.var user = { name: 'Namkwon'; role: 'Admin';} var user = [ { name: 'Namkwon', role: 'Admin' }, { name: 'Kim', role: 'Developer' }]; 여기서 잠깐! 메모리란? 메모리(memory)는 데이터를 저장할 수 있는 메모리 셀(memory cell)들의 집합체이다. 셀 하나의 크기는 1byte(8bit)이며 컴퓨터는 셀의 크기 , 즉 1byte 단위로 데이터를 저장(write)하거나 읽어(read)들인다. 컴퓨터는 모든 데이터를 2진수로 처리한다. 따라서 메모리에 저장되는 데이터는 데이터의 종류(숫자, 텍스트, 이미지, 동영상 등)와 상관없이 2진수다. 각각의 셀은 고유의 메모리 주소(memory address)를 갖는다. 이 메모리 주소는 메모리 공간의 위치를 나타내며 0부터 시작하여 메모리의 크기만큼 정수로 표현된다. 예를 들어 4GB의 메모리는 0부터 4,294,967,295 까지의 메모리 주소를 갖는다. 2. 식별자 변수 이름을 식별자(identifier)라고도 부른다. 식별자는 어떤 값을 구별하여 식별해낼 수 있는 고유한 이름을 말한다. 사람을 이름으로 구별하여 식별하는 것처럼 값도 식별자로 구별하여 식별할 수 있다. 값은 메모리 공간에 저장되어 있다. 따라서 식별자는 메모리 공간에 저장되어 있는 어떤 값을 구별하여 식별해낼 수 있어야 한다. 이를 위해 식별자는 어떤 값이 저장되어 있는 메모리 주소를 기억(저장)해야 한다. 식별자는 값이 아니라 메모리 주소를 기억하고 있다.식별자로 값을 구별하여 식별한다는 것은 식별자가 기억하고 있는 메모리 주소를 통해 메모리 공간에 저장된 값에 접근할 수 있다는 것을 의미한다. 즉, 식별자는 메모리 주소에 붙인 이름이라고 할 수 있다. 식별자라는 용어는 변수 이름에만 국한해서 사용하지 않는다. 예를 들어, 변수, 함수, 클래스 등의 이름은 모두 식별자다. 식별자인 변수 이름으로는 메모리 상에 존재하는 변수값을 식별할 수 있고, 함수 이름으로는 메모리 상에 존재하는 함수(자바스크립트에서는 함수는 값이다) 를 식별할 수 있다. 즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 부른다. 변수, 함수, 클래스 등의 이름과 같은 식별자는 네이밍 규칙을 준수해야 하며, “선언(declaration)”에 의해 자바스크립트 엔진에 식별자의 존재를 알린다. 이제 변수를 선언하는 방법에 대해 알아보자! 3. 변수 선언 변수 선언(Variable declaration)이란 변수를 생성하는 것을 말한다. 음.. 좀 더 자세히 말하면 값을 저장하기 위한 메모리 공간을 확보(allocate)하고 변수 이름과 확보된 메모리 공간의 주소를 연결하여 값을 저장할 수 있도록 준비 하는 것이다. 변수 선언에 의해 확보된 메모리 공간은 확보가 해제(release)되기 이전까지는 누구도 확보된 메모리 공간을 사용할 수 없도록 보호되므로 안전하게 사용할 수 있다. 변수를 사용하려면 반드시 선언이 필요합니다! 변수를 선언할 떄는 var, let, const 키워드(keyword)를 사용합니다! 아래의 코드를 보시죠. 1var score; // 변수 선언(변수 선언문) var 키워드는 뒤에 오는 변수 이름으로 새로운 변수를 선언할 것을 지시하는 키워드입니다. 잠깐! 키워드(keyword)란? 키워드는 자바스크립트 코드를 실행하는 자바스크립트 엔진이 수행할 동작을 규정한 일종의 명령어 입니다! 자바스크립트 엔진은 키워드를 만나면 자신이 수행해야 할 약속된 동작을 수행합니다. 매우 간단하게 설명을 하면 const 키워드가 실행되면 자바스크립트 엔진은 새로운 변수를 선언합니다~위의 코드처럼 변수를 선언한 이후, 아직 변수에 값을 할당하지 않았습니다. 따라서 변수 선언에 의해 확보된 메모리 공간은 비어 있을 것으로 생각할 수 있으나 확보된 메모리공간에는 자바스크립트 엔진에 의해 undefined라는 값이 암묵적으로 할당되어 초기화된다. 이것은 자바스크립트의 독특한 특징이다. undefined란? undefined는 자바스크립트가 제공하는 원시 타입의 값(Primitive value)입니다. 나중에 자세히 설명할께요~ 자바스크립트 엔진은 변수 선언을 아래의 2단계를 거쳐 수행한다. 선언 단계(Declaration phase): 변수 이름을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다. 초기화 단계(Initialization phase): 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당한다. var 키워드를 사용한 변수 선언은 선언 단계와 초기화 단계가 동시에 진행됩니다. var score;는 선언 단계를 통해 변수 이름 score를 등록하고, 초기화 단계를 통해 변수 score에 암묵적으로 undefined를 할당하여 초기화합니다. 일반적으로 초기화(Initialization)란 변수가 선언된 이후 최초로 값을 할당하는 것을 말합니다. var 키워드로 선언한 변수는 undefined로 암묵적인 초기화가 자동 수행됩니다.따라서 var 키워드로 변수는 선언 이후 어떠한 값도 할당하지 않아도 undefined라는 값을 갖습니다. 변수를 사용하려면 반드시 선언이 필요합니다. 변수 뿐만이 아니라 모든 식별자(함수, 클래스 등)가 그렇습니다. 만약 선언하지 않은 식별자에 접근하면 ReferenceError(참조 에러)가 발생합니다. ReferenceError는 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러입니다. 4. 변수 선언의 실행 시점과 변수 호이스팅변수 선언문보다 변수를 참조하는 코드가 앞에 있다. 자바스크립트 코드는 한 줄씩 순차적으로 실행되므로 console.log(score);가 가장 먼저 실행되고 순차적으로 다음 줄에 있는 코드를 실행한다. 따라서 console.log(score);가 실행되는 시점에는 아직 변수 score의 선언이 실행되지 않았으므로 참조 에러(ReferenceError)가 발생할 것처럼 보인다. 하지만 참조 에러가 발생하지 않고 undefined가 출력된다. 그 이유는 변수 선언이 소스 코드가 한 줄씩 순차적으로 실행되는 시점, 즉 런타임(run-time)이 아니라 그 이전 단계에서 먼저 실행되기 때문이다. 자바스크립트 엔진은 소스 코드를 한 줄씩 순차적으로 실행하기에 앞서 먼저 코드의 평가 과정을 거치면서 코드 실행을 위한 준비를 한다. 이때, 즉 코드 실행을 위한 준비 단계인 코드의 평가 과정에서 자바스크립트 엔진은 변수 선언을 포함한 모든 선언문(변수 선언문, 함수 선언문 등)을 소스 코드에서 찾아내어 먼저 실행한다. 그리고 코드의 평가 과정이 끝나면 비로소 변수 선언을 포함한 모든 선언문을 제외하고 코드가 한 줄씩 순차적으로 실행한다.","link":"/2020/02/variable/"},{"title":"알아두면 쓸데있는 VSCode | IDE","text":"단축키 모음Mac기준으로 작성하였습니다. 양해부탁드려요 1234단계적으로 선택영역을 확장하거나 축소할 수 있음Window: ctrl + shift + 좌/우Mac: ctrl + shift + 좌/우 123라인, 선택영역만 잡아서 위,아래 줄내림 하기Mac: option + 위/아래 123블록 이동하기Mac: cmd + shift + \\ 1234567함수명 리팩토링하기F2전역에서 이름 리팩토링F2 1234567탐색기 열기cmd + 0탐색기를 연 상태에서 다시 에디터창으로 이동cmd + 1 123터미널 창 열기control + ` 1234567네비게이션 이동cmd + shift + .그 다음에shift + 좌/우 123파일 바로가기cmd + p 123파일명은 기억이 안 나고 심볼명만 기억이 날 떄cmd + t 123파일 안에 있는 모든 심볼로 이동하기cmd + shift + 0 123456창 나누기 cmd + 2cmd + 3창 총 3개로 나뉨 123456에디터에서 에디터의 터미널 말고 iterm으로 이동cmd + shift + c반대로 터미널에서 에디터를 열려면code . (작동이 안 된다면 에디터에 검색창을 열고 path를 검색하면 'code'명령 설치가 뜸) 12바로 가기 키cmd + k + s 확장도구 Material icon Theme을 마켓에서 다운하기! GitLens 깃 관련된 정보를 쭉 볼 수 있다(파일히스토리, 라인히스토리, 코드 비교등등) 누가 커밋했는지(aka 블레임)도 나온다. Bookmarks 북마크 했던 목록이 쭉 생김 cmd + option + k를 하면 북마크가 생깁니다.!!!!(유용) ThemeNight owl, atom dark 추천합니다.. 마켓플레이스에서 다운!","link":"/2020/04/vscode/"},{"title":"Webpack 실전에 적용하기 | javaScript","text":"웹팩이란? 웹팩이란 최신 버전 사용 가능한 프레임 워크에서 가장 많이 사용되는 모듈 모듈러 (Module Bundler) 입니다. 웹팩에서의 모듈 웹팩에서 다양한 기능을 제공합니다. 웹 응용 프로그램 제작 HTML, CSS, 자바 스크립트, 이미지, 글꼴 등. 이 파일 하나 하나가 모두 모듈입니다. 웹팩의 필요성 파일 단위의 자바 기능 모듈 관리파일 단위로 변수를 관리하고 싶은 욕구 , 자바 스크립트 모듈화에 대한 욕구를 예전 까진 AMD , common.js를 와 같은 라이브러리로 풀어 왔습니다 웹 개발 작업 자동화 도구HTML, CSS, JS 압축이미지 압축CSS 전 처리기 변환 웹 애플리케이션의 빠른 속도 Node.js &amp; NPM웹팩을 사용하기 위해서는 Node.js와 NPM을 컴퓨터에 설치해야합니다. 간단하기 떄문에 자세한 설명은 패스하겠습니다. NPM 설치 및 명령어는 제 블로그 NPM문서를 참고해주세요. 웹팩 시작하기 빈 폴더에서 package.json을 설치 합니다 1npm init -y 웹팩 관련 라이브러리와 lodash라이브러리 설치 12npm i webpack webpack-cli -Dnpm i lodash 폴더에 index.html파일을 생성합니다. 123456789&lt;html&gt; &lt;head&gt; &lt;title&gt;Webpack Demo&lt;/title&gt; &lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=\"src/index.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 프로젝트 루트 레벨에 index.js를 생성 12345678910function component() { var element = document.createElement('div'); /* lodash is required for the next line to work */ element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element;}document.body.appendChild(component()); 웹팩 빌드 및 빌드 결과물을 실행 12345678910111213// index.jsimport _ from 'lodash';function component() { var element = document.createElement('div'); /* lodash is required for the next line to work */ element.innerHTML = _.join(['Hello', 'webpack'], ' '); return element;}document.body.appendChild(component()); 1234567891011&lt;!-- index.html --&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;Webpack Demo&lt;/title&gt; &lt;!-- &lt;script src=\"https://unpkg.com/lodash@4.16.6\"&gt;&lt;/script&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;script src=\"src/index.js\"&gt;&lt;/script&gt; --&gt; &lt;script src=\"dist/main.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 웹팩 빌드 완료를 실행하기 위한 package.json 파일의 script 객체 안에 명령어 추가 123\"script\": { \"build\": \"webpack --mode=none\"} 터미널 or 배쉬에서 npm run build 명령어를 실행 후 index.html을 라이브 서버로 실행 프로젝트 폴더 루트 레벨에 webpack.config.js 파일을 생성 123456789101112// webpack.config.js// `webpack` command will pick up this config setup by defaultvar path = require('path');module.exports = { mode: 'none', entry: './src/index.js', output: { filename: 'main.js', path: path.resolve(__dirname, 'dist') }}; mode란? mode란 none, production, dev 이 3가지가 있습니다. 제품 출시를 할 떄는 production으로 하며 dev는 개발중일 떄, none은 아무것도 하지 않는다는 뜻입니다. package.json파일을 통해 같이 수정 123\"scripts\": { \"build\": \"webpack\"} 다시 npm run build로 실행해보세요. 빌드 완료 다음은 각 웹팩의 속성을 파해쳐보겠습니다.2만","link":"/2020/04/webpack01/"},{"title":"Webpack 실전에 적용하기2 | javaScript","text":"웹팩의 4가지 주요 속성 웹팩의 빌드(파일 변환) 과정을 이해하기 위해서는 아래 4가지 주요 속성에 대해서 알고 있어야 합니다. entry output loader plugin 각 주요 속성에 대해서 자세히 살펴보겠습니다. 1. Entry entry 속성은 웹팩에서 웹 자원을 변환하기 위해 필요한 최초 진입점이자 자바스크립트 파일 경로입니다. 1234// webpack.config.jsmodule.exports = { entry: './src/index.js'}; 위 코드는 웹팩을 실행했을 때 src폴더 밑의 index.js을 대상으로 웹팩이 빌드를 수행하는 코드입니다. Entry 파일에는 어떤 내용이 들어가야 할까? entry 속성에 지정된 파일에는 웹 어플리케이션의 전반적인 구조와 내용이 담겨져 있어야 합니다.웹팩이 해당 파일을 가지고 웹 애플리케이션에서 사용되는 모듈들의 연관 관계를 이해하고 분석하기 떄문에 애플리케이션을 동작시킬 수 있는 내용들이 담겨져 있어야 합니다. 이 그림 한장으로 모든 설명을 종결하겠습니다. 위와 같은 모듈 간의 의존 관계가 생기는 구조를 디펜던시 그래프라고 합니다. Entry 유형 앞에서 살펴본 것처럼 엔트리 포인트는 1개가 될 수도 있지만 아래와 같이 여러 개가 될 수도 있습니다. 1234entry: { login: './src/LoginView.js', main: './src/MainView.js'} 위와 같이 엔트리 포인트를 분리하는 경우는 싱글 페이지 애플리케이션이 아닌 멀티 페이지 애플리케이션에 적합합니다. 2. Output output속성은 웹팩을 돌리고 난 결과물의 파일 경로를 의미합니다. 123456// webpack.config.jsmodule.exports = { output: { filename: 'bundle.js' }}; 앞에서 배운 entry속성과는 다르게 객체 형태로 옵션들을 추가해야 합니다. Output 속성 옵션 형태 최소한 filename은 지정해줘야 하며 일반적으로 path속성을 함께 정의합니다. 123456789// webpack.config.jsvar path = require('path');module.exports = { output: { filename: 'bundle.js', path: path.resolve(__dirname, './dist') }}; 여기서 filename 속성은 웹팩으로 빌드한 파일의 이름을 의미하고, path 속성은 해당 파일의 경로를 의미합니다. 그리고 path 속성에서 사용된 path.resolve() 코드는 인자로 넘어온 경로들을 조합하여 유효한 파일 경로를 만들어주는 Node.js API입니다. 1output: './dist/bundle.js'; Output 파일 이름 옵션 앞에서 살펴본 filename 속성에 여러 가지 옵션을 넣을 수 있습니다. 결과 파일 이름에 entry 속성을 포함하는 옵션 12345module.exports = { output: { filename: '[name].bundle.js' }}; 결과 파일 이름에 웹팩 내부적으로 사용하는 모듈 ID를 포함하는 옵션 12345module.exports = { output: { filename: '[id].bundle.js' }}; 매 빌드시 마다 고유 해시 값을 붙이는 옵션 12345module.exports = { output: { filename: '[name].[hash].bundle.js' }}; 웹팩의 각 모듈 내용을 기준으로 생생된 해시 값을 붙이는 옵션 12345module.exports = { output: { filename: '[chunkhash].bundle.js' }}; 이렇게 생성된 결과 파일의 이름에는 각각 엔트리 이름, 모듈 아이디, 해시 값 등이 포함됩니다. 3. Loader","link":"/2020/04/webpack02/"},{"title":"forEach, map, reduce 차이점 | javaScript","text":"javascript에서 forEach, map, reduce 차이점을 알아보자혼자서 할 때마다 맨날 mdn 뒤적뒤적 거리면서 보는게 짜증나서 이 글에서 정리를 해보려고한다. forEach, map, reduce의 공통점은 배열을 이용한다는 점이다. 배열의 값을 조작해서 원하는 결과값을 도출하는데 의미가 있다. forEach는 문밖에서 리턴값을 받지 못한다. 이거랑 map이랑 맨날 헷갈려가지고 검색폼에 데이터를 뿌릴 때 오류나서 맨날 mdn에서 찾아봤다.(이제 좀 외웠으면 제발…머리야..) 123456const testArr = [1, 2, 3, 4, 5, 6, 7, 8];const matchArray = testArr.forEach(item =&gt; { return item;});console.log(matchArray) // undefinded undefined가 출력된다 map의 경우에는 문밖에서도 리턴값이 출력된다 그렇다 forEach와 map의 차이점은 return값을 문밖으로 반환하냐 안 하냐에 따라 달렸다.!! 123456const testArr = [1, 2, 3, 4, 5, 6, 7, 8];const matchArray = testArr.map(item =&gt; { return item;});console.log(matchArray) // [1, 2, 3, 4, 5, 6, 7, 8] 그러면 reduce에 대해서 살펴보자 123456const testArr = [1, 2, 3, 4, 5, 6, 7, 8];const matchArray = testArr.reduce((lastitem, firstitem) =&gt; { return lastitem + firstitem}, 0);console.log(matchArray) // 36 reduce는 map과 다르게 배열로 반환하지 않고 값으로 출력한다.","link":"/2020/04/%EA%B3%A0%EC%B0%A8%ED%95%A8%EC%88%98%EC%B0%A8%EC%9D%B4/"},{"title":"디스트럭처링 할당 | javaScript","text":"1. 배열 디스트럭처링 할당 ES5에서 구조화된 배열을 디스트럭처링하여 1개 이상의 변수에 할당하기 위한 방법은 아래와 같다. 12345678// ES5var arr = [1, 2, 3];var one = arr[0];var two = arr[1];var three = arr[2];console.log(one, two, three); // 1 2 3 ES6의 배열 디스트럭처링 할당은 배열의 각 요소를 배열로부터 추출하여 1개 이상의 변수에 할당한다. 이때 할당 기준은 배열의 인덱스이다. 즉, 순서대로 할당된다. 123456789let x, y;[x, y] = [1, 2];// 위의 문과 아래의 문은 동치이다.const [x, y] = [1, 2];여러 개의 변수를 배열 형태로 선언하면 반드시 우변에 배열을 할당해야 한다.const [x, y];// -&gt; SyntaxError: Missing initializer in destructuring declaration 배열 디스트럭처링 할당의 기준은 배열의 인덱스이다. 즉, 순서대로 할당된다. 이때 변수의 개수와 배열 요소의 개수가 반드시 일치할 필요는 없다. 12345678910111213let x, y, z;[x, y] = [1, 2];console.log(x, y); // 1 2[x, y] = [1];console.log(x, y); // 1 undefined[x, y] = [1, 2, 3];console.log(x, y); // 1 2[x, , z] = [1, 2, 3];console.log(x, z); // 1 3 배열 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. 123456789let x, y, z;// 기본값[x, y, z = 3] = [1, 2];console.log(x, y, z); // 1 2 3// 기본값보다 할당된 값이 우선된다[x, y = 10, z = 3] = [1, 2];console.log(x, y, z); // 1 2 3 배열 디스트럭처링 할당은 배열에서 필요한 요소만 추출하여 변수에 할당하고 싶을 때 유용하다. 아래 예제는 Date 객체에서 년도, 월, 일을 추출하는 예제이다. 123456789const today = new Date();console.log(today); // Sun Mar 22 2020 22:00:55 GMT+0900 (대한민국 표준시)const formattedDate = today.toISOString().substring(0, 10);console.log(formattedDate); // \"2020-03-22\"// 문자열을 분리하여 배열로 변환한 후, 배열 디스트럭처링 할당을 통해 필요한 요소를 취득한다.const [year, month, day] = formattedDate.split(\"-\");console.log([year, month, day]); // [\"2020\", \"03\", \"22\"] 배열 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 Rest 요소(Rest element) …을 사용할 수 있다. Rest 요소는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다. 123// Rest 요소const [x, ...y] = [1, 2, 3];console.log(x, y); // 1 [ 2, 3 ] 2. 객체 디스트럭처링 할당 ES5에서 객체의 각 프로퍼티를 객체로부터 디스트럭처링하여 변수에 할당하기 위해서는 프로퍼티 키를 사용해야 한다. 1234567// ES5var user = { firstName: \"Ungmo\", lastName: \"Lee\" };var firstName = user.firstName;var lastName = user.lastName;console.log(firstName, lastName); // Ungmo Lee ES6의 객체 디스트럭처링 할당은 객체의 각 프로퍼티를 객체로부터 추출하여 1개 이상의 변수에 할당한다. 배열 디스트럭처링 할당과 마찬가지로 객체 디스트럭처링 할당을 위해서는 할당 연산자 왼쪽에 값을 할당 받을 변수를 선언해야 한다. 이를 위해 여러 개의 변수를 객체 리터럴 형태로 선언한다. 이때 할당 기준은 프로퍼티 키이다. 즉, 순서는 의미가 없으며 변수 이름과 프로퍼티 키가 일치하면 할당된다. 12345678const user = { firstName: \"Ungmo\", lastName: \"Lee\" };// ES6 객체 디스트럭처링 할당// 변수 lastName, firstName을 선언하고 객체 user를 디스트럭처링하여 할당한다.// 이때 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다. 순서는 의미가 없다.const { lastName, firstName } = user;console.log(firstName, lastName); // Ungmo Lee 위 예제에서 객체 리터럴 형태로 선언한 변수는 lastName, firstName이다. 이는 프로퍼티 축약 표현을 통해 선언한 것이다. 123const { lastName, firstName } = user;// 위와 아래는 동치이다.const { lastName: lastName, firstName: firstName } = user; 따라서 객체의 프로퍼티 키와 다른 변수 이름으로 프로퍼티 값을 할당 받으려면 아래와 같이 변수를 선언한다. 123456789const user = { firstName: \"Ungmo\", lastName: \"Lee\" };// ES6 객체 디스트럭처링 할당// 프로퍼티 키를 기준으로 디스트럭처링 할당이 이루어진다.// 프로퍼티 키가 lastName인 프로퍼티 값을 ln에 할당한다.// 프로퍼티 키가 firstName인 프로퍼티 값을 fn에 할당한다.const { lastName: ln, firstName: fn } = user;console.log(fn, ln); // Ungmo Lee 객체 디스트럭처링 할당을 위한 변수에 기본값을 설정할 수 있다. 12345const { firstName = \"Ungmo\", lastName } = { lastName: \"Lee\" };console.log(firstName, lastName); // Ungmo Leeconst { firstName: fn = \"Ungmo\", lastName: ln } = { lastName: \"Lee\" };console.log(fn, ln); // Ungmo Lee 객체 디스트럭처링 할당은 프로퍼티 키로 객체에서 필요한 프로퍼티 값만을 추출할 수 있다. 1234const todo = { id: 1, content: \"HTML\", completed: true };const { id } = todo;console.log(id); // 1 객체 디스트럭처링 할당은 객체를 인수로 전달받는 함수의 매개변수에도 사용할 수 있다. 12345678function printTodo(todo) { console.log( `할일 ${todo.content}은 ${todo.completed ? \"완료\" : \"비완료\"} 상태입니다.` );}printTodo({ id: 1, content: \"HTML\", completed: true });// 할일 HTML은 완료 상태입니다. 위 예제에서 객체를 인수로 전달받는 매개변수 todo에 객체 디스트럭처링 할당을 사용하면 보다 간단하고 가독성 좋게 표현이 가능하다. 123456function printTodo({ content, completed }) { console.log(`할일 ${content}은 ${completed ? \"완료\" : \"비완료\"} 상태입니다.`);}printTodo({ id: 1, content: \"HTML\", completed: true });// 할일 HTML은 완료 상태입니다. 배열의 요소가 객체인 경우, 배열 디스트럭처링 할당과 객체 디스트럭처링 할당을 혼용할 수 있다. 123456789const todos = [ { id: 1, content: \"HTML\", completed: true }, { id: 2, content: \"CSS\", completed: false }, { id: 3, content: \"JS\", completed: false },];// todos 배열의 두번째 요소인 객체로부터 id 프로퍼티만을 추출한다.const [, { id }] = todos;console.log(id); // 2 중첩 객체의 경우는 아래와 같이 사용한다. 123456789101112const user = { name: \"Lee\", address: { zipCode: \"03068\", city: \"Seoul\", },};const { address: { city },} = user;console.log(city); // 'Seoul' 객체 디스트럭처링 할당을 위한 변수에 Rest 파라미터와 유사하게 Rest 프로퍼티 …을 사용할 수 있다. Rest 프로퍼티는 Rest 파라미터와 마찬가지로 반드시 마지막에 위치해야 한다. 123// Rest 프로퍼티const { x, ...rest } = { x: 1, y: 2, z: 3 };console.log(x, rest); // 1 { y: 2, z: 3 }","link":"/2020/03/%EB%94%94%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%B2%98%EB%A7%81/"},{"title":"리액트 입문하기 | React","text":"리액트란?","link":"/2020/03/%EB%A6%AC%EC%95%A1%ED%8A%B81/"},{"title":"배열(Array) | javaScript","text":"1. 배열 배열은 객체이며 typeof로 해도 객체로 나온다. 12const arr = [1, 2, 3, 4];typeof arr // Object","link":"/2020/03/%EB%B0%B0%EC%97%B4/"},{"title":"브라우저의 렌더링 과정 | javaScript","text":"브라우저의 렌더링 과정 구글의 V8 자바스크립트 엔진으로 빌드된 자바스크립트 런타임 환경(Runtime Environment)인 Node.js의 등장으로 자바스크립트는 웹 브라우저를 벗어나 서버 사이드 애플리케이션 개발에서도 사용할 수 있는 범용 개발 언어가 되었다. 하지만 자바스크립트가 가장 많이 사용되는 분야는 역시 웹 브라우저 환경에서 동작하는 웹 페이지/애플리케이션의 클라이언트 사이드이다. 웹 애플리케이션의 클라이언트 사이드 자바스크립트는 브라우저에서 HTML, CSS와 함께 실행된다. 따라서 브라우저 환경을 고려할 때 보다 효율적인 클라이언트 사이드 자바스크립트 프로그래밍이 가능하다. 이를 위해 브라우저가 HTML, CSS, JS로 작성된 텍스트 문서를 어떻게 파싱(parsing, 해석)하여 브라우저에 렌더링하는지 살펴보자. **파싱** 파싱(parsing)은 프로그래밍 언어의 문법에 맞게 작성된 텍스트 문서를 읽어 들여 실행하기 위해 텍스트 문서의 문자열을 토큰으로 분해하고, 토큰에 문법적 의미와 구조를 반영하여 트리 구조의 자료 구조인 파스 트리를 생성하는 일련의 과정을 말한다. **렌더링** HTML, CSS, JS로 작성된 문서를 파싱하여 브라우저에 시각적으로 출력하는 것을 말한다. 브라우저는 아래와 같은 과정을 거쳐 렌더링을 실행한다. 브라우저는 HTML, CSS, JS, IMG, FONT, FILE 등의 렌더링에 필요한 리소스를 요청하고 서버로부터 응답을 받는다. 브라우저의 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하고 이들을 결합하여 렌더 트리를 생성한다. 브라우저의 자바스크립트 엔진은 서버로부터 응답된 자바스크립트를 파싱하여 AST를 생성하고 바이트코드로 변환하여 실행한다. 이떄 자바스크립트는 DOM API를 통해 DOM, CSSOM을 변경할 수 있다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합된다. 렌더 트리를 기반으로 HTML 요소의 레이아웃(위치와 크기)를 계산하고 브라우저의 화면에 HTML 요소를 페인팅한다. 1. 요청과 응답 브라우저의 핵심 기능은 필요한 리소스(HTML, CSS, 자바스크립트, 이미지, 폰트 등의 정적 파일 또는 서버가 동적으로 생성한 데이터)를 서버에 요청(Request)하고 서버의 응답(Response)을 받아 브라우저에 시각적으로 렌더링하는 것이다. 서버에 요청을 하기 위해 브라우저는 주소창을 제공한다. 브라우저의 주소창에 URL을 입력하고 엔터 키를 입력하면 URL의 호스트 이름은 DNS를 통해 IP 주소로 변환되고 이 IP 주소를 갖는 서버에게 요청(request)를 전송한다. 반드시 브라우저의 주소창을 통해 서버에게 정적 파일만을 요청할 수 있는 것은 아니다. 자바스크립트를 통해 동적으로 서버에 요청을 전송하여 정적/동적 데이터를 요청할 수도 있다. 이에 대해서는 “ajax”와 “REST API”에서 자세히 살펴보자요청과 응답은 개발자 도구의 Network 패널에서 확인할 수 있다. 브라우저의 주소창에 https://poiemaweb.com을 입력하고 엔터 키를 입력하여 서버에 루트 요청을 전송해 보자. 아래 그림처럼 poiemaweb.com 서버에 대해 요청한 내용과 응답한 내용을 개발자 도구의 Network 패널에서 확인할 수 있다. 개발자 도구의 Network 패널을 활성화하기 이전에 브라우저가 이미 응답을 받은 경우, 응답된 리소스가 표시되지 않는다. 따라서 Network 패널에 아무런 리소스가 표시되지 않은 경우, 새로고침을 실행하여야 한다. 위 그림을 살펴보면 index.html(poiemaweb.com)뿐만 아니라 CSS, 자바스크립트, 이미지, 폰트 파일들도 응답된 것을 확인할 수 있다. 요청도 하지 않은 이들 리소스가 왜 응답되었을까? 이는 브라우저의 렌더링 엔진이 HTML(index.html)을 파싱하는 도중에 외부 리소스를 로드하는 태그, 즉 CSS 파일을 로드하는 link 태그, 이미지 파일을 로드하는 이미지 태그, 자바스크립트를 로드하는 script 태그 등을 만나면 HTML의 파싱을 일시 중단하고 해당 리소스 파일을 서버로 요청하기 때문이다. 2. HTTP 1.1와 HTTP 2.0 HTTP(HyperText Transfer Protocol)는 웹에서 브라우저와 서버가 통신을 하기 위한 프로토콜(규약)이다. 1989년, HTML, URL과 함께 팀 버너스 리 경(Sir Tim Berners-Lee)이 고안한 HTTP는 1991년 최초로 문서화되었고 1996년 HTTP/1.0, 1999년 HTTP/1.1, 2015년 HTTP/2가 발표되었다. 이중 HTTP/1.1과 HTTP/2 버전의 차이에 대해 간략히 살펴보자. HTTP/1.1은 기본적으로 커넥션(connection) 당 하나의 요청과 응답 만을 처리한다. 즉, 여러 개의 요청을 한번에 전송할 수 없고 응답 또한 마찬가지다. 따라서 HTML 문서 내에 포함된 여러 개의 리소스 요청 즉, CSS 파일을 로드하는 link 태그, 이미지 파일을 로드하는 이미지 태그, 자바스크립트를 로드하는 script 태그 등에 의한 리소스 요청이 개별적으로 전송되고 응답 또한 개별적으로 전송된다. 이처럼 HTTP/1.1은 리소스의 동시 전송이 불가능한 구조이므로 요청할 리소스의 개수에 비례하여 응답 시간도 증가하는 단점이 있다. HTTP/1.1은 다중 요청/응답이 불가하다는 단점이 있지만 HTTP/2는 커넥션 당 여러 개의 요청과 응답, 즉 다중 요청/응답이 가능하다. 따라서 HTTP/2.0은 여러 개의 리소스의 동시 전송이 가능하므로 HTTP/1.1에 비해 페이지 로드 속도가 약 50% 정도 빠르다고 한다. 3. HTML 파싱과 DOM 생성 브라우저의 요청에 의해 서버가 응답한 HTML 문서는 문자열로 이루어진 순수한 텍스트이다. 순수한 텍스트인 HTML 문서를 브라우저에 시각적인 픽셀로 렌더링하려면 HTML 문서를 브라우저가 이해할 수 있는 자료 구조(객체)로 변환하여 메모리에 저장해야 한다. 예를 들어 아래와 같은 index.html이 서버로부터 응답되었다고 가정해보자. 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li id=\"apple\"&gt;Apple&lt;/li&gt; &lt;li id=\"banana\"&gt;Banana&lt;/li&gt; &lt;li id=\"orange\"&gt;Orange&lt;/li&gt; &lt;/ul&gt; &lt;script src=\"app.js\"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 브라우저의 렌더링 엔진은 아래 그림과 같은 과정을 통해 응답 받은 HTML 문서를 파싱하여 DOM(Document Object Model)을 생성한다. 1 서버에 존재하던 HTML 파일이 브라우저의 요청에 의해 응답된다. 이때 서버는 요청된 HTML 파일을 읽어 들여 메모리에 저장한 다음 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답한다. 2 브라우저는 서버가 응답한 HTML 문서를 바이트(2진수) 형태로 응답 받는다. 그리고 바이트 형태의 HTML 문서는 meta 태그의 charset 어트리뷰트에 의해 지정된 인코딩 방식(예를 들어 UTF-8)을 기준으로 문자열로 변환된다. 3 문자열로 변환된 HTML 문서를 읽어 들여 문법적 의미를 갖는 코드의 최소 단위인 토큰(Token)들로 분해한다. 4 각 토큰들을 객체로 변환하여 노드(Node) 들을 생성한다. 토큰의 내용에 따라 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드가 생성된다. 노드는 이후 DOM을 구성하는 기본 요소가 된다. 5 HTML 문서는 HTML 요소들의 집합으로 이루어지며 HTML 요소는 중첩 관계를 갖는다. 즉, HTML 요소의 컨텐츠 영역(시작 태그와 종료 태그 사이)에는 텍스트 뿐만 아니라 다른 HTML 요소도 포함될 수 있다. 이때 HTML 요소 간에는 중첩 관계에 의해 부자 관계가 형성된다. 이러한 HTML 요소 간의 부자 관계를 반영하여 모든 노드들을 트리 자료 구조로 구성한다. 이 노드들로 구성된 트리 자료 구조를 DOM(Document Object Model)이라 부른다. 4. CSS 파싱과 CSSOM 생성 렌더링 엔진은 HTML을 처음부터 한줄씩 순차적으로 파싱하여 DOM을 생성해 나간다. 이처럼 렌더링 엔진은 DOM을 생성해 나가다가 CSS를 로드하는 link 태그나 style 태그를 만나면 DOM 생성을 일시 중단한다. 그리고 link 태그의 href 어트리뷰트에 정의된 CSS 파일을 서버에 요청하여 로드한 CSS나 style 태그 내의 CSS를 HTML과 동일한 파싱 과정(바이트 → 문자 → 토큰 → 노드 → CSSOM)을 거치며 해석하여 CSSOM(CSS Object Model)을 생성한다. 이후 CSS 파싱을 완료하면 HTML 파싱이 중단된 지점부터 다시 HTML을 파싱하기 시작하여 DOM 생성을 재개한다.위에서 살펴본 index.htm을 다시 살펴보자. index.htm에는 CSS 파일을 로드하는 link 태그가 존재한다. 123456&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt;... 렌더링 엔진은 meta 태그까지 HTML을 순차적으로 해석한 다음, link 태그를 만나면 DOM 생성을 일시 중단하고 link 태그의 href 어트리뷰트에 정의된 CSS 파일을 서버에 요청한다. 예를 들어 아래와 같은 style.css 파일이 서버로부터 응답되었다고 가정해보자. 1234567body { font-size: 18px;}ul { list-style-type: none;} 서버로부터 CSS 파일이 응답되면 렌더링 엔진은 HTML과 동일한 해석 과정(바이트 -&gt; 문자 -&gt; 토큰 -&gt; 노드 -&gt; CSSOM)을 거쳐 CSS를 파싱하여 CSSOM을 생성한다. CSSOM은 CSS의 상속을 반영하여 생성된다. 위 예제에서 body 요소에 적용한 font-size 프로퍼티와 ul 요소에 적용한 list-style-type 프로퍼티는 모든 li 요소에 상속된다. 이러한 상속 관계가 반영되어 아래와 같이 CSSOM이 생성된다. 5. 렌더 트리 생성 렌더링 엔진은 서버로부터 응답된 HTML과 CSS를 파싱하여 각각 DOM과 CSSOM를 생성한다. 그리고 DOM과 CSSOM은 렌더링을 위해 렌더 트리(Render tree)로 결합된다. 렌더 트리는 렌더링을 위한 트리 구조의 자료 구조이다. 따라서 브라우저 화면에 렌더링되지 않는 노드(예를 들어 meta 태그, script 태그 등)와 CSS에 의해 비표시(예를 들어 display: none)되는 노드 들을 포함하지 않는다. 다시 말해 렌더 트리는 브라우저 화면에 렌더링되는 노드 들만으로 구성된다. 이후 완성된 렌더 트리는 각 HTML 요소의 레이아웃(위치와 크기)계산에 사용되며 브라우저 화면에 픽셀을 렌더링하는 페인팅(Painting)처리에 입력된다. 지금까지 살펴본 브라우저의 렌더링 과정은 반복해서 실행될 수 있다. 예를 들어 아래와 같은 경우, 반복해서 레이아웃 계산과 페인팅이 재차 실행된다. 자바스크립트에 의한 노드 추가 또는 삭제 브라우저 윈도우의 리사이징에 의한 Viewport 크기 변경 HTML 요소의 레이아웃(위치, 크기)에 변경을 발생시키는 width/height, margin, padding, border, display, position, top/right/bottom/left 등의 스타일 변경 레이아웃 계산과 페인팅이 다시 실행하는 리렌더링은 비용이 많이 드는, 즉 성능에 악영향을 주는 작업이다. 따라서 가급적 빈번한 리렌더링이 발생하지 않도록 주의가 필요하다. 6. 자바스크립트 파싱과 실행 HTML 문서를 파싱한 결과물로서 생성된 DOM은 HTML 문서의 구조와 정보 뿐만 아니라 HTML 요소와 스타일 등을 변경할 수 있는 프로그래밍 인터페이스로서 DOM API를 제공한다. CSS 파싱 과정과 마찬가지로 렌더링 엔진은 HTML을 한줄씩 순차적으로 파싱하며 DOM을 생성해 나가다가 자바스크립트 파일을 로드하는 script 태그나 자바스크립트 코드를 컨텐츠로 갖는 script 태그를 만나면 DOM 생성을 일시 중단한다. 그리고 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청하여 로드한 자바스크립트 코드나 script 태그 내의 자바스크립트 코드의 파싱을 위해 자바스크립트 엔진에 제어권을 넘긴다. 이후 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권을 넘겨 HTML 파싱이 중단된 지점부터 다시 HTML 파싱을 시작하여 DOM 생성을 재개한다. 자바스크립트 파싱과 실행은 브라우저의 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. 자바스크립트 엔진은 자바스크립트 코드를 CPU가 이해할 수 있는 저수준 언어(low-level language)로 변환하는 역할을 한다. 자바스크립트 엔진은 구글 크롬과 Node.js의 V8, 파이어폭스의 SpiderMonkey, 사파리의 JavaScriptCore 등 다양한 종류가 존재하며, 모든 자바스크립트 엔진은 ECMAScript 사양을 준수한다. 렌더링 엔진으로부터 제어권을 넘겨 받은 자바스크립트 엔진은 자바스크립트 코드를 파싱하기 시작한다. 렌더링 엔진이 HTML과 CSS를 파싱하여 DOM과 CSSOM을 생성하듯이 자바스크립트 엔진은 자바스크립트를 해석하여 AST(Abstract Syntax Tree, 추상적 구문 트리)를 생성한다. 7. 리플로우와 리페인트 만약 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 DOM API가 사용된 경우, DOM이나 CSSOM이 변경된다. 변경된 DOM과 CSSOM은 다시 렌더 트리로 결합되고 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링한다. 이를 리플로우(reflow), 리페인트(repaint)라 한다. 리플로우는 레이아웃 계산을 다시 하는 것을 말하며 노드 추가/삭제, 요소의 크기/위치 변경, 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우에 한하여 실행된다. 리페인트는 재결합된 렌더 트리를 기반으로 다시 페인트를 하는 것을 말한다. 따라서 리플로우와 리페인트가 반드시 순차적으로 동시에 실행되는 것은 아니다. 레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 실행된다. 8. 자바스크립트 파싱에 의한 HTML 파싱 중단 지금까지 살펴본 바와 같이 렌더링 엔진과 자바스크립트 엔진은 병렬적으로 파싱을 실행하지 않고 직렬적으로 파싱을 수행한다. 이처럼 브라우저는 동기(Synchronous)적으로, 즉 위에서 아래 방향으로 순차적으로 HTML, CSS, 자바스크립트를 파싱하고 실행한다. 이것은 script 태그의 위치에 따라 HTML 파싱이 블로킹되어 DOM 생성이 지연될 수 있다는 것을 의미한다. 따라서 script 태그의 위치는 중요한 의미를 갖는다. 아래 예제를 살펴보자. 아래 자바스크립트 코드의 동작에 대해 지금 당장 이해할 필요는 없다. 지금 주목할 것은 script 태그의 위치에 의해 블로킹이 발생하는 것이다. 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;script&gt; // DOM에서 id가 apple인 HTML 요소를 취득한다. // 아래 DOM API가 실행되는 시점에는 아직 apple 요소를 파싱하지 않았기 때문에 // DOM에는 apple 요소가 포함되어 있지 않다. // 따라서 아래 코드는 정상적으로 apple 요소를 선택하지 못한다. const $apple = document.getElementById('apple'); // apple 요소의 css color 프로퍼티 값을 변경한다. $apple.style.color = 'red'; // TypeError: Cannot read property 'style' of null &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li id=\"apple\"&gt;Apple&lt;/li&gt; &lt;li id=\"banana\"&gt;Banana&lt;/li&gt; &lt;li id=\"orange\"&gt;Orange&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 자바스크립트 코드 내에서 DOM API document.querySelector(‘#apple’)를 실행하는 시점에는 아직 DOM API가 참조하는 HTML 요소(#apple)가 파싱되어 DOM에 포함되지 않은 상태이므로 위 예제는 정상적으로 동작하지 않는다. 이러한 문제를 회피하기 위해 body 요소의 가장 아래에 자바스크립트를 위치시키는 것은 좋은 아이디어이다. 그 이유는 아래와 같다. DOM이 완성되지 않은 상태에서 자바스크립트가 DOM을 조작한다면 에러가 발생한다. 자바스크립트 스크립트 로딩/파싱/실행으로 인해 HTML 요소들의 렌더링에 지장 받는 일이 발생하지 않아 페이지 로딩 시간이 단축된다.위 예제의 자바스크립트를 body 요소의 가장 아래, 즉 닫는 body 태그 바로 위에 위치시켜 보자. 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"style.css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li id=\"apple\"&gt;Apple&lt;/li&gt; &lt;li id=\"banana\"&gt;Banana&lt;/li&gt; &lt;li id=\"orange\"&gt;Orange&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; // DOM에서 id가 apple인 HTML 요소를 취득한다. // 아래 코드가 실행되는 시점에는 apple 요소의 파싱이 완료되어 DOM에 포함되어 있다. const $apple = document.getElementById('apple'); // apple 요소의 css color 프로퍼티 값을 변경한다. $apple.style.color = 'red'; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 9. script 태그의 async / defer 어트리뷰트 앞에서 살펴본 자바스크립트 파싱에 의한 DOM 생성이 중단(blocking)되는 문제를 근본적으로 해결하기 위해 HTML5부터 script 태그에 async와 defer 어트리뷰트가 추가되었다. async와 defer 어트리뷰트는 src 어트리뷰트를 통해 외부 자바스크립트 파일을 로드하는 경우에만 사용한다. 즉, src 어트리뷰트가 없는 인라인 자바스크립트에는 사용할 수 없다. 12&lt;script async src=\"extern.js\"&gt;&lt;/script&gt;&lt;script defer src=\"extern.js\"&gt;&lt;/script&gt; async와 defer 어트리뷰트를 사용하면 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 하지만 자바스크립트의 실행 시점에 차이가 있다. async 어트리뷰트 HTML 파싱과 외부 자바크립트 파일의 로드가 비동기적으로 동시에 진행된다. 단, 자바스크립트의 파싱과 실행은 자바스크립트 로드가 완료된 직후 진행되며 이때 HTML 파싱이 중단된다. IE10 이상 버전에서 지원된다. defer 어트리뷰트 HTML 파싱과 외부 자바스크립트 파일의 로드가 비동기적으로 동시에 진행된다. 단, 자바스크립트의 파싱과 실행은 HTML 파싱이 완료된 직후, 즉 DOM 생성이 완료된 직후 진행된다. 따라서 DOM 생성이 완료된 이후(이때 DOMContentLoaded 이벤트가 발생한다.) 실행되어야 할 자바스크립트에 유용하다. IE10 이상 버전에서 지원된다. IE6 ~ 9 버전에서도 지원되지만 정상적으로 동작하지 않을 수 있다.","link":"/2020/04/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%A0%8C%EB%8D%94%EB%A7%81/"},{"title":"생성자 함수에 의한 객체 생성 | javaScript","text":"1. Object 생성자 함수new 연산자와 함께 Object 생성자 함수를 호출하면 빈 객체를 생성하여 반환한다. 빈 객체를 생성한 이후에는 프로퍼티나 메소드 추가 가능 1234567891011// 생성자 객체 생성const person = new object();// 프로퍼티, 메서드 동적 추가person.name = '이남권';person.sayHello = function() { console.log('Hi My name is' + this.name);};console.log(person) // {name: \"Lee\", sayHello: f}person.sayHello(); // Hi My name is 이남권 생성자(constructor)함수란 new 연산자와 함께 호출하여 객체(인스턴스)를 생성하는 함수를 말한다. 생성자 함수에 의해 생성된 객체를 인스턴스(instance)라 한다. 12345678910111213141516171819202122232425262728293031323334// String 생성자 함수에 의한 String 객체 생성const strObj = new string('이남권');console.log(typeof strObj); // objectconsole.log(strObj); // 이남권// Number 생성자 함수에 의한 Number 객체 생성const numObj = new Number(123);console.log(typeof numObj); // objectconsole.log(numObj); // Number {123}// Boolean 생성자 함수에 의한 Boolean 객체 생성const boolObj= new Boolean(true);console.log(typeof boolObj); // objectconsole.log(boolObj); // Boolean {true}// Function 생성자 함수에 의한 Function 객체(함수) 생성const func = new Function('x', 'return x * x');console.log(typeof func); // functionconsole.dir(func); // ƒ anonymous(x)// Array 생성자 함수에 의한 Array 객체(배열) 생성const arr = new Array(1, 2, 3);console.log(typeof arr); // objectconsole.log(arr); // [1, 2, 3]// RegExp 생성자 함수에 의한 RegExp 객체(정규 표현식) 생성const regExp = new RegExp(/ab+c/i);console.log(typeof regExp); // objectconsole.log(regExp); // /ab+c/i// Date 생성자 함수에 의한 Date 객체 생성const date = new Date();console.log(typeof date); // objectconsole.log(date); // Fri Feb 14 2020 17:17:59 GMT+0900 (대한민국 표준시) 2.생성자 함수 2.1. 객체 리터럴에 의한 객체 생성 방식의 문제점객체 리터럴에 의한 객체 생성 방식은 단 하나의 객체만을 생성한다. 따라서 동일한 프로퍼티를 갖는 객체를 여러 개 생성해야 하는 경우, 매번 같은 프로퍼티를 기술해야 하기 떄문에 비효율적이다. 1234567891011121314151617const circle1 = { radius: 5, getDiameter() { return 2 * this.radius; }};console.log(circle1.getDiameter()); // 10const circle2 = { radius: 10, getDiameter() { return 2 * this.radius; }};console.log(circle2.getDiameter()); // 20 위 예제처럼 객체가 한두개라면 넘어갈 수도 있겠지만 만약 수십개의 객체를 생성해야 한다면 문제가 크다. 2.2. 생성자 함수에 의한 객체 생성 방식의 장점생성자 함수에 의한 객체 생성 방식은 생성자 함수를 사용하여 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성할 수 있다. 123456789101112131415// 생성자 함수function Circle(radius) { // 생성자 함수 내부의 this는 생성자 함수가 생성할 인스턴스를 가리킨다. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}// 인스턴스의 생성const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성const circle2 = new Circle(10); // 반지름이 10인 Circle 객체를 생성console.log(circle1.getDiameter()); // 10console.log(circle2.getDiameter()); // 20 this this는 객체 자신의 프로퍼티나 메소드를 참조하기 위한 자기 참조 변수이다.this가 가리키는 값, 즉 this 바인딩은 함수 호출 방식에 따라 동적으로 결정된다. 함수 호출 방식 this가 가리키는 값 일반 함수로서 호출 전역 객체 메소드로서 호출 메소드를 호출한 객체 생성자 함수로서 호출 생성자 함수가 (미래에) 생성할 인스턴스 123456789101112131415// 함수는 다양한 방식으로 호출될 수 있다.function foo() { console.log(this);}// 일반적인 함수로서 호출// 전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global을 가리킨다.foo(); // window// 메소드로서 호출const obj = { foo }; // ES6 프로퍼티 축약 표현obj.foo(); // obj// 생성자 함수로서 호출const inst = new foo(); // inst this에 대해서는 나중에 자세히 살펴보자. 생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수이다.만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다. 123456789// new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다.// 즉, 일반적인 함수의 호출이다.const circle3 = Circle(15);// 일반 함수 Circle은 반환문이 없으므로 암묵적으로 undefined를 반환한다.console.log(circle3); // undefined// 일반 함수 Circle내의 this는 전역 객체를 가리킨다.console.log(radius); // 15 2.3. 내부 메소드 [[Call]]과 [[Construct]]함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. 생성자 함수로서 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성하는 것을 의미한다. 함수는 객체이므로 일반 객체(Ordinary object)와 동일하게 동작할 수 있다. 즉, 함수 객체는 일반 객체의 내부 슬롯과 내부 메소드(“15.2 내부 슬롯/메소드” 참고)를 모두 가지고 있다. 123456789101112// 함수는 객체이다.function foo() {}// 함수는 객체이므로 프로퍼티를 소유할 수 있다.foo.prop = 10;// 함수는 객체이므로 메소드를 소유할 수 있다.foo.method = function () { console.log(this.prop);};foo.method(); // 10 함수 객체는 함수로서 동작하기 위해 일반 객체의 내부 슬롯과 내부 메소드 이외에 아래와 같은 내부 슬롯과 내부 메소드를 추가적으로 가지고 있다.내부 메소드[[Call]]을 갖는 함수 객체를 Callable이라 하며, 내부 메소드인[[Construct]]를 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않는 함수 객체를 non-constructor라고 부른다. callable은 호출할 수 있는 객체, 즉 함수를 말하며, constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다. 생성자 함수로서 호출할 수 있다는 것은 new 연산자(또는 super 연산자)와 함께 호출하는 것을 의미한다. 함수가 일반적인 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 호출되고 new 연산자(또는 super 연산자)와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다. 1234567function foo() {}// 일반적인 함수로서 호출: [[Call]]이 호출된다.foo();// 생성자 함수로서 호출: [[Construct]]가 호출된다.new foo(); this에 대해서는 “22. this”에서 자세히 살펴보도록 하고 지금은 이 정도로만 정리하도록 하자. 생성자 함수는 이름 그대로 객체(인스턴스)를 생성하는 함수이다. 하지만 자바와 같은 클래스 기반 객체지향 언어의 생성자(constructor)와는 다르게 그 형식이 정해져 있는 것이 아니라 일반 함수와 동일한 방법으로 생성자 함수를 정의하고 new 연산자와 함께 호출하면 해당 함수는 생성자 함수로 동작한다. 만약 new 연산자와 함께 생성자 함수를 호출하지 않으면 생성자 함수가 아니라 일반 함수로 동작한다. 123456789// new 연산자와 함께 호출하지 않으면 생성자 함수로 동작하지 않는다.// 즉, 일반 함수로서 호출된다.const circle3 = Circle(15);// 일반 함수로서 호출된 Circle은 반환문이 없으므로 암묵적으로 undefined를 반환한다.console.log(circle3); // undefined// 일반 함수로서 호출된 Circle내의 this는 전역 객체를 가리킨다.console.log(radius); // 15 2.3. 생성자 함수의 인스턴스 생성 과정 먼저 생성자 함수의 함수 몸체에서 수행해야 하는 것이 무엇인지 생각해보자. 생성자 함수의 역할은 프로퍼티 구조가 동일한 인스턴스를 생성하기 위한 템플릿(클래스)으로서 동작하여 인스턴스를 생성하는 것과 생성된 인스턴스를 초기화(인스턴스 프로퍼티 추가 및 초기값 할당)하는 것이다. 생성자 함수가 인스턴스를 생성하는 것은 필수이고, 생성된 인스턴스를 초기화하는 것은 옵션이다. 아래 예제를 살펴보자. 1234567891011// 생성자 함수function Circle(radius) { // 인스턴스 초기화 this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}// 인스턴스 생성const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성 생성자 함수 내부의 코드를 살펴보면 this에 프로퍼티를 추가하고 필요에 따라 전달된 인수를 프로퍼티의 초기값으로서 할당하여 인스턴스를 초기화한다. 하지만 인스턴스를 생성하고 반환하는 코드는 보이지 않는다. 자바스크립트 엔진은 암묵적인 처리를 통해 인스턴스를 생성하고 반환한다. new 연산자와 함께 생성자 함수를 호출하면 자바스크립트 엔진은 아래와 같은 과정을 거쳐 암묵적으로 인스턴스를 생성하고 인스턴스를 초기화한 후, 인스턴스를 반환한다. 인스턴스 생성과 this 바인딩 암묵적으로 빈 객체가 생성된다. 이 빈 객체가 바로 (아직 완성되지는 않았지만) 생성자 함수가 생성한 인스턴스이다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩된다. 생성자 함수 내부의 this가 생성자 함수가 생성할 인스턴스를 가리키는 이유가 바로 이것이다. 이 처리는 함수 몸체의 코드가 한줄씩 실행되는 런타임 이전에 실행된다. 바인딩(binding)바인딩이란 식별자와 값을 연결하는 과정을 의미한다. 예를 들어 변수는 할당에 의해 값이 바인딩된다. 123456789function Circle(radius) { // 1. 암묵적으로 빈 객체가 생성되고 this에 바인딩된다. console.log(this); // Circle {} this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };} 인스턴스 초기화 생성자 함수에 기술되어 있는 코드가 한줄씩 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티나 메소드를 추가하고 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값을 할당한다. 이 처리는 개발자가 기술한다. 123456789function Circle(radius) { // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다. // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };} 인스턴스 반환 생성자 함수 내부의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 123456789101112131415function Circle(radius) { // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다. // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; }; // 3. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다}// 인스턴스 생성. Circle 생성자 함수는 암묵적으로 this를 반환한다.const circle = new Circle(1);console.log(circle); // Circle {radius: 1, getDiameter: ƒ} 만약 this가 아닌 다른 객체를 명시적으로 반환하면 this가 반환되지 못하고 return 문에 명시한 객체가 반환된다. 1234567891011121314151617function Circle(radius) { // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다. // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; }; // 3. 암묵적으로 this를 반환한다. // 명시적으로 객체를 반환하면 암묵적인 this 반환이 무시된다. return {};}// 인스턴스 생성. Circle 생성자 함수는 명시적으로 반환한 객체를 반환한다.const circle = new Circle(1);console.log(circle); // {} 하지만 명시적으로 원시값을 반환하면 원시 값 반환은 무시되고 암묵적으로 this가 반환된다. 1234567891011121314151617function Circle(radius) { // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다. // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.radius = radius; this.getDiameter = function () { return 2 * this.radius; }; // 3. 암묵적으로 this를 반환한다. // 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다. return 100;}// 인스턴스 생성. Circle 생성자 함수는 명시적으로 반환한 객체를 반환한다.const circle = new Circle(1);console.log(circle); // Circle {radius: 1, getDiameter: ƒ} 이처럼 생성자 함수 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 생성자 함수의 기본 동작을 훼손한다. 따라서 생성자 함수 내부에서 return 문을 반드시 생략해야 한다. 2.4. 내부 메소드 [[Call]]과 [[Construct]] 함수 선언문 또는 함수 표현식으로 정의한 함수는 일반적인 함수로서 호출할 수 있는 것은 물론 생성자 함수로서 호출할 수 있다. 생성자 함수로서 호출한다는 것은 new 연산자와 함께 호출하여 객체를 생성하는 것을 의미한다. 함수는 객체이므로 일반 객체(Ordinary object)와 동일하게 동작할 수 있다. 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메소드(“16.1. 내부 슬롯/메소드” 참고)를 모두 가지고 있기 때문이다. 123456789101112// 함수는 객체이다.function foo() {}// 함수는 객체이므로 프로퍼티를 소유할 수 있다.foo.prop = 10;// 함수는 객체이므로 메소드를 소유할 수 있다.foo.method = function () { console.log(this.prop);};foo.method(); // 10 함수 객체는 일반 객체가 가지고 있는 내부 슬롯과 내부 메소드은 물론, 함수로서 동작하기 위해 함수 객체만을 위한 [[Environment]], [[FormalParameters]] 등의 내부 슬롯과 [[Call]], [[Constructor]]와 같은 내부 메소드를 추가적으로 가지고 있다. 함수가 일반 함수로서 호출되면 함수 객체의 내부 메소드 [[Call]]가 호출되고 new 연산자와 함께 생성자 함수로서 호출되면 내부 메소드 [[Construct]]가 호출된다. 1234567function foo() {}// 일반적인 함수로서 호출: [[Call]]이 호출된다.foo();// 생성자 함수로서 호출: [[Construct]]가 호출된다.new foo(); 내부 메소드 [[Call]]을 갖는 함수 객체를 callable이라 하며, 함수 객체 만을 위한 내부 메소드 [[Construct]]를 갖는 함수 객체를 constructor, [[Construct]]를 갖지 않는 함수 객체를 non-constructor라고 부른다. callable은 호출할 수 있는 객체, 즉 함수를 말하며, constructor는 생성자 함수로서 호출할 수 있는 객체를 의미한다. 호출할 수 없는 객체는 함수 객체가 아니므로 함수로서 기능하는 객체, 즉 함수 객체는 반드시 callable이여야 한다. 따라서 모든 함수 객체는 내부 메소드 [[Call]]을 갖고 있으므로 호출할 수 있다. 하지만 모든 함수 객체가 [[Construct]]를 갖지는 않는다. 다시 말해, 함수 객체는 constructor일 수도 있고 non-constructor일 수 있다. 결론적으로 함수 객체는 callable이면서 constructor이거나 callable이면서 non-constructor이다. 즉, 모든 함수 객체는 호출할 수 있지만 모든 함수 객체를 생성자 함수로서 호출할 수 있는 것은 아니다. 모든 함수 객체는 callable이지만 모든 함수 객체가 constructor인 것은 아니다. 자바스크립트 엔진이 어떻게 constructor와 non-constructor를 구분하는지 살펴보도록 하자. 2.5. constructor와 non-constructor의 구분 자바스크립트 엔진이 함수 정의를 평가하여 함수 객체를 생성할 때, 함수 정의 방식에 따라 함수를 constructor와 non-constructor로 구분한다. constructor: 함수 선언문, 함수 표현식, 클래스(클래스도 함수다)non-constructor: 메소드(ES6 메소드 축약 표현), 화살표 함수이때 주의할 것은 ECMAScript 사양에서 메소드로 인정하는 범위가 일반적인 의미의 메소드보다 좁다는 것이다. 아래 예제를 살펴보자. 12345678910111213141516171819202122232425// 일반 함수 정의: 함수 선언문, 함수 표현식function foo() {}const bar = function () {};// 프로퍼티 x의 값으로 할당된 것은 일반 함수 정의에 의해 생성된 함수 객체이다.// 이는 메소드로 인정하지 않는다.const baz = { x: function () {}};// 일반 함수로 정의된 함수만이 constructor이다.new foo(); // OKnew bar(); // OKnew baz.x(); // OK// 화살표 함수 정의const arrow = () =&gt; {};new arrow(); // TypeError: arrow is not a constructor// 메소드 정의: ES6의 메소드 축약 표현만을 메소드로 인정한다.const obj = { x() {}};new obj.x(); // TypeError: obj.x is not a constructor 함수를 프로퍼티 값으로 사용하면 일반적으로 메소드로 통칭한다. 하지만 ECMAScript 사양에서 메소드란 ES6의 메소드 축약 표현(“10.9.1. 메소드 축약 표현” 참고)만을 의미한다. 다시 말해 함수가 어디에 할당되어 있는지에 따라 메소드인지를 판단하는 것이 아니라 함수 정의 방식에 따라 constructor와 non-constructor를 구분한다. 위 예제와 같이 일반 함수, 즉 함수 선언문과 함수 표현식으로 정의된 함수만이 constructor이고 ES6의 화살표 함수와 메소드 축약 표현으로 정의된 함수는 non-constructor이다. 함수를 일반 함수로서 호출하면 함수 객체의 내부 메소드 [[Call]]가 호출되고 new 연산자와 함께 생성자 함수로서 호출하면 내부 메소드 [[Construct]]가 호출된다. non-constructor인 함수 객체는 내부 메소드 [[Construct]]를 갖지 않는다. 따라서 non-constructor인 함수 객체를 생성자 함수로서 호출하면 에러가 발생한다. 123456789function foo() {}// 일반 함수로서 호출: [[Call]]이 호출된다.// 모든 함수 객체는 [[Call]]이 구현되어 있다.foo();// 생성자 함수로서 호출: [[Construct]]가 호출된다.// 이때 [[Construct]]를 갖지 않는다면 에러가 발생한다.new foo(); 주의할 것은 생성자 함수로서 호출될 것을 기대하고 정의하지 않은 일반 함수(callable이면서 constructor)에 new 연산자를 붙여 호출하면 생성자 함수처럼 동작할 수 있다는 것이다. 2.6. new 연산자 일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. new 연산자와 함께 함수를 호출하면 해당 함수는 생성자 함수로 동작한다. 다시 말해, 함수 객체의 내부 메소드 [[Call]]이 호출되는 것이 아니라 [[Construct]]가 호출된다. 단, new 연산자와 함께 호출하는 함수는 non-constructor가 아닌 constructor이여야 한다. 12345678910111213141516171819// 생성자 함수로서 정의하지 않은 일반 함수function add(x, y) { return x + y;}// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출let inst = new add();// 함수가 객체를 반환하지 않았으므로 반환문이 무시된다. 따라서 빈 객체가 생성되어 반환된다.console.log(inst); // {}// 객체를 반환하는 일반 함수function createUser(name, role) { return { name, role };}// 생성자 함수로서 정의하지 않은 일반 함수를 new 연산자와 함께 호출inst = new createUser('Lee', 'admin');// 함수가 생성한 객체를 반환한다.console.log(inst); // {name: \"Lee\", role: \"admin\"} 반대로 new 연산자 없이 생성자 함수를 호출하면 일반 함수로 호출된다. 다시 말해, 함수 객체의 내부 메소드 [[Construct]]가 호출되는 것이 아니라 [[Call]]이 호출된다. 123456789101112131415161718// 생성자 함수function Circle(radius) { this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}// new 연산자 없이 생성자 함수 호출하면 일반 함수로서 호출된다.const circle = Circle(5);console.log(circle); // undefined// 일반 함수 내부의 this는 전역 객체 window를 가리킨다.console.log(radius); // 5console.log(getDiameter()); // 10circle.getDiameter();// TypeError: Cannot read property 'getDiameter' of undefined Circle 함수를 new 연산자와 함께 생성자 함수로서 호출하면 함수 내부의 this는 Circle 생성자 함수가 생성할 인스턴스를 가리킨다. 하지만 Circle 함수를 일반적인 함수로서 호출하면 함수 내부의 this는 전역 객체 window를 가리킨다. 위 예제의 Circle 함수는 일반 함수로서 호출되었기 때문에 Circle 함수 내부의 this는 전역 객체 window를 가리킨다. 따라서 radius 프로퍼티와 getDiameter 메소드는 전역 객체의 프로퍼티와 메소드가 된다. 일반 함수와 생성자 함수에 특별한 형식적 차이는 없다. 따라서 생성자 함수는 일반적으로 첫문자를 대문자로 기술하는 파스칼 케이스로 명명하여 일반 함수와 구별할 수 있도록 노력한다. 2.7. new.target 생성자 함수가 new 연산자 없이 호출되는 것을 방지하기 위해 파스칼 케이스 컨벤션을 사용한다 하더라도 실수는 언제나 발생할 수 있다. 이러한 위험성을 회피하기 위해 ES6에서는 new.target을 지원한다. new.target은 this와 유사하게 모든 함수 내부에서 암묵적인 지역 변수와 같이 사용되며 메타 프로퍼티라고 부른다. IE는 new.target을 지원하지 않으므로 주의하기 바란다.함수 내부에서 new.target를 사용하면 new 연산자와 함께 함수가 호출되었는지 확인할 수 있다. 함수가 new 연산자와 함께 호출되면 함수 내부의 new.target은 함수 자신을 가리킨다. new 연산자 없이 호출된 함수 내부의 new.target은 undefined이다. 1234567891011121314151617// 생성자 함수function Circle(radius) { // 이 함수가 new 연산자와 함께 호출되지 않았다면 new.target은 undefined이다. if (!new.target) { // new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환한다. return new Circle(radius); } this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}// new 연산자 없이 생성자 함수를 호출하여도 new.target을 통해 생성자 함수로서 호출된다.const circle = Circle(5);console.log(circle.getDiameter()); 스코프 세이프 생성자(Scope-Safe Constructor) 패턴new.target은 ES6에서 도입된 최신 문법으로 IE에서는 지원하지 않는다. new.target을 사용할 수 없는 상황이라면 스코프 세이프 생성자(Scope-Safe Constructor) 패턴을 사용할 수 있다. 123456789101112131415161718192021// Scope-Safe Constructor Patternfunction Circle(radius) { // 생성자 함수가 new 연산자와 함께 호출되면 함수의 선두에서 빈 객체를 생성하고 // this에 바인딩한다. 이때 this와 Circle은 프로토타입에 의해 연결된다. // 이 함수가 new 연산자와 함께 호출되지 않았다면 이 시점의 this는 전역 객체 window를 가리킨다. // 즉, this와 Circle은 프로토타입에 의해 연결되지 않는다. if (!(this instanceof Circle)) { // new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다. return new Circle(radius); } this.radius = radius; this.getDiameter = function () { return 2 * this.radius; };}// new 연산자 없이 생성자 함수를 호출하여도 생성자 함수로서 호출된다.const circle = Circle(5);console.log(circle.getDiameter()); // 10 new 연산자와 함께 생성자 함수에 의해 생성된 객체(인스턴스)는 프로토타입에 의해 생성자 함수와 연결된다. 이를 이용해 new 연산자와 함께 호출되었는지를 확인할 수 있다. 프로토타입과 instanceof 연산자에 대해서는 “19. 프로토타입”에서 살펴볼 것이다. 대부분의 빌트인 생성자 함수(Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등)는 new 연산자와 함께 호출되었는지를 확인한 후 적절한 값을 반환한다. 예를 들어, Object 또는 Function 생성자 함수는 new 연산자 없이 호출해도 new 연산자와 함께 호출했을 때와 동일하게 동작한다. 123456789101112131415161718192021let obj = new Object();console.log(obj); // {}obj = Object();console.log(obj); // {}let f = new Function('x', 'return x ** x');console.log(f); // ƒ anonymous(x) { return x ** x }f = Function('x', 'return x ** x');console.log(f); // ƒ anonymous(x) { return x ** x }하지만 String, Number, Boolean 생성자 함수는 new 연산자와 함께 호출했을 때 String 객체를 생성하여 반환하지만 new 연산자 없이 호출하면 문자열, 숫자, 불리언 값을 반환한다. 이를 통해 데이터 타입을 변환(“9.3. 명시적 타입 변환” 참고)하기도 한다.let v = String(123);console.log(v, typeof v); // 123 stringv = Number('123');console.log(v, typeof v); // 123 numberv = Boolean('true');console.log(v, typeof v); // true boolean","link":"/2020/03/%EC%83%9D%EC%84%B1%EC%9E%90%ED%95%A8%EC%88%98/"},{"title":"스프레드문법 | javaScript","text":"ES에서 새롭게 도입된 스프레드 문법 …은 하나로 뭉쳐 있는 여러 값들의 집합을 펼쳐서(전개, 분산)개별적인 값들의 목록을 만든다. 스프레드 문법을 사용할 수 있는 대상은 Array, String, Map, set, DOM 컬렉션(NodeList, HTMLCollection), Arguments와 같이 for..of 문으로 순회할 수 있는 이터러블에 한정된다. 12345678910111213// ...[1, 2, 3]는 [1, 2, 3]을 개별 요소로 분리한다(→ 1, 2, 3)console.log(...[1, 2, 3]) // 1 2 3// 문자열은 이터러블이다.console.log(...'Hello'); // H e l l o// Map과 Set은 이터러블이다.console.log(...new Map([['a', '1'], ['b', '2']])); // [ 'a', '1' ] [ 'b', '2' ]console.log(...new Set([1, 2, 3])); // 1 2 3// 이터러블이 아닌 일반 객체는 스프레드 문법의 대상이 될 수 없다.console.log(...{ a: 1, b: 2 });// TypeError: Found non-callable @@iterator 1 2 3은 값이 아니라 값들의 목록이다. 즉, 스프레드 문법의 결과는 값이 아니다. 이는 스프레드 문법 …이 피연산자를 연산하여 값을 생성하는 연산자가 아님을 의미한다. 따라서 스프레드 문법의 결과는 변수에 할당할 수 없다. 1const list = ...arr; // SyntaxError: Unexpected token ... 스프레드 문법의 결과물은 단독으로 사용할 수 없고, 아래와 같이 쉼표로 구분한 값의 목록을 사용하는 문맥에서만 사용할 수 있다. 함수 호출문의 인수 목록 배열 리터럴의 요소 목록 객체 리터럴의 프로퍼티 목록 1. 함수 호출문의 인수 목록에서 사용하는 경우 요소값들의 집합인 배열을 펼쳐서 개별적인 값들의 목록으로 만든 후, 이를 함수의 인수 목록으로 전달해야 하는 경우가 있다. 아래의 예제를 살펴보자. 123456const arr = [1, 2, 3];// 배열 arr의 요소 중에서 최대값을 구하기 위해 Math.max를 사용한다.const maxValue = Math.max(arr);console.log(maxValue); // NaN Math.max 메소드는 매개변수 개수를 확정할 수 없는 가변 인자 함수이다. 아래와 같이 개수가 정해져 있지 않은 여러 개의 숫자를 인수로 전달받아 인수 중에서 최대값을 반환한다. 123Math.max(1, 2); // -&gt; 2Math.max(1, 2, 3); // -&gt; 3Math.max(1, 2, 3, 4); // -&gt; 4 만약 Math.max 메소드에 숫자가 아닌 배열을 인수로 전달하면 최대값을 구할 수 없으므로 NaN을 반환한다. 1Math.max([1, 2, 3]); // -&gt; NaN 이와 같은 문제를 해결하기 위해 배열을 펼쳐서 요소값들을 개별적인 값들의 목록으로 만든 후 Math.max 메소드의 인수로 전달해야 한다. 즉, [1, 2, 3]을 1, 2, 3으로 펼쳐서 Math.max 메소드의 인수로 전달해야 한다. 스프레드 문법이 제공되기 이전에는 배열을 펼쳐서 요소값의 목록을 함수의 인수로 전달하고 싶은 경우, Function.prototype.apply를 사용하였다. 1234567var arr = [1, 2, 3];// apply 함수의 2번째 인수(배열)는 apply 함수가 호출하는 함수의 인수 목록이다.// 따라서 배열이 펼쳐져서 인수로 전달되는 효과가 있다.var maxValue = Math.max.apply(null, arr);console.log(maxValue); // 3 스프레드 문법을 사용하면 보다 간결하고 가독성이 좋다. 123456const arr = [1, 2, 3];// 스프레드 문법을 사용하여 배열 arr을 1, 2, 3으로 펼쳐서 Math.max에 전달한다.const MaxValue = Math.max(...arr);console.log(MaxValue); // 3 스프레드 문법은 앞에서 살펴본 Rest 파라미터와 형태가 동일하여 혼동할 수 있으므로 주의가 필요하다. Rest 파라미터는 함수에 전달된 인수들의 목록을 배열로 전달받기 위해 매개변수 이름 앞에 …을 붙이는 것이다. 스프레드 문법은 여러 개의 값이 하나로 뭉쳐 있는 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만드는 것이다. 따라서 Rest 파라미터와 스프레드 문법은 서로 반대의 개념이다. 123456789// Rest 파라미터는 인수들의 목록을 배열로 전달받는다.function foo(param, ...rest) { console.log(param); // 1 console.log(rest); // [ 2, 3 ]}// 스프레드 문법은 배열과 같은 이터러블을 펼쳐서 개별적인 값들의 목록을 만든다.// [1, 2, 3] -&gt; 1, 2, 3foo(...[1, 2, 3]); 2. 배열 리터럴 내부에서 사용하는 경우 스프레드 문법을 배열 리터럴에서 사용하면 보다 간결하고 가독성이 좋게 표현할 수 있다.ES5에서 사용하던 방식과 비교하여 살펴보도록 하자. 2.1 concat ES5에서 기존의 배열 요소들을 새로운 배열의 일부로 만들고 싶은 경우, 배열 리터럴 만으로 해결할 수 없고 concat 메소드를 사용해야 한다. 123// ES5var arr = [1, 2].concat([3, 4]);console.log(arr); // [1, 2, 3, 4] 스프레드 문법을 사용하면 별도의 메소드를 사용하지 않고 배열 리터럴 만으로 기존의 배열 요소들을 새로운 배열의 일부로 만들 수 있다. 123// ES6const arr = [...[1, 2], ...[3, 4]];console.log(arr); // [1, 2, 3, 4] 2.2 pushES5에서 기존의 배열에 다른 배열의 요소들을 push하려면 아래와 같은 방법을 사용한다. 1234567// ES5var arr1 = [1, 2];var arr2 = [3, 4];Array.prototype.push.apply(arr1, arr2);console.log(arr1); // [1, 2, 3, 4] 스프레드 문법을 사용하면 아래와 같이 보다 간편하게 표현할 수 있다. 12345678// ES6const arr1 = [1, 2];const arr2 = [3, 4];// arr1.push(3, 4)와 같다.arr1.push( ...arr2 );console.log(arr1); // [1, 2, 3, 4] 원본 배열을 직접 수정하는 push 메소드를 사용하는 것보다 스프레드 문법을 사용하는 것이 바람직하다. 1234const arr1 = [1, 2];const arr2 = [3, 4];console.log([...arr1, ...arr2]); 2.3. splice ES5에서 기존의 배열에 다른 배열의 요소들을 삽입하려면 splice 메소드를 사용한다. 1234567891011// ES5var arr1 = [1, 4];var arr2 = [2, 3];// apply 메소드의 2번째 인수는 배열이다. 이것은 인수 목록으로 splice 메소드에 전달된다.// [1, 0].concat(arr2) → [1, 0, 2, 3]// arr1.splice(1, 0, 2, 3) → arr1[1]부터 0개의 요소를 제거하고// 그자리(arr1[1])에 새로운 요소(2, 3)를 삽입한다.Array.prototype.splice.apply(arr1, [1, 0].concat(arr2));console.log(arr1); // [1, 2, 3, 4] 스프레드 문법을 사용하면 아래와 같이 보다 간편하게 표현할 수 있다. 1234567// ES6const arr1 = [1, 4];const arr2 = [2, 3];arr1.splice(1, 0, ...arr2);console.log(arr1); // [1, 2, 3, 4] 2.4. 배열 복사 ES5에서 기존의 배열을 복사하기 위해서는 slice 메소드를 사용한다. 123456// ES5var origin = [1, 2];var copy = origin.slice();console.log(copy); // [1, 2]console.log(copy === origin); // false 스프레드 문법을 사용하면 보다 간편하게 배열을 복사할 수 있다. 123456// ES6const origin = [1, 2];const copy = [...origin];console.log(copy); // [1, 2]console.log(copy === origin); // false 이때 원본 배열의 각 요소를 얕은 복사(shallow copy)하여 새로운 복사본을 생성한다. 이는 slice 메소드도 마찬가지다. 2.5. 유사 배열 객체를 배열로 변환 유사 배열 객체를 배열로 변환하려면 slice 메소드를 apply 함수로 호출하는 것이 일반적이다. 1234567891011// ES5function sum() { // 유사 배열 객체인 arguments를 배열로 변환 var args = Array.prototype.slice.apply(arguments); return args.reduce(function (pre, cur) { return pre + cur; }, 0);}console.log(sum(1, 2, 3)); // 6 스프레드 문법을 사용하면 보다 간편하게 유사 배열 객체를 배열로 변환할 수 있다. 유사 배열 객체인 arguments 객체는 이터러블이다. 따라서 스프레드 문법의 대상이 될 수 있다. 123456789// ES6function sum() { // 유사 배열 객체인 arguments를 배열로 변환 const args = [...arguments]; return args.reduce((pre, cur) =&gt; pre + cur, 0);}console.log(sum(1, 2, 3)); // 6 3. 객체 리터럴 내부에서 사용하는 경우 객체 리터럴의 프로퍼티 목록에서 스프레드 문법을 사용할 수 있는 스프레드 프로퍼티는 Rest 프로퍼티와 함께 2020년 3월 현재 TC39 프로세스의 stage 4(Finished) 단계에 제안되어 있다.(https://github.com/tc39/proposal-object-rest-spread) 스프레드 문법의 대상은 이터러블이어야 하지만 스프레드 프로퍼티 제안은 일반 객체를 대상으로도 스프레드 문법의 사용을 허용한다. 12345678910// 스프레드 프로퍼티// 객체 복사(얕은 복사)const obj = { x: 1, y: 2 };const copy = { ...obj };console.log(copy); // { x: 1, y: 2 }console.log(obj === copy); // false// 객체 병합const merged = { x: 1, y: 2, ...{ a: 3, b: 4 } };console.log(merged); // { x: 1, y: 2, a: 3, b: 4 } 스프레드 프로퍼티가 제안되기 이전에는 ES6에서 도입된 Object.assign 메소드를 사용하여 여러 개의 객체를 병합하거나 특정 프로퍼티를 변경 또는 추가하였다. 123456789101112// 객체의 병합// 프로퍼티가 중복되는 경우, 뒤에 위치한 프로퍼티가 우선권을 갖는다.const merged = Object.assign({}, { x: 1, y: 2 }, { y: 10, z: 3 });console.log(merged); // { x: 1, y: 10, z: 3 }// 특정 프로퍼티 변경const changed = Object.assign({}, { x: 1, y: 2 }, { y: 100 });console.log(changed); // { x: 1, y: 100 }// 프로퍼티 추가const added = Object.assign({}, { x: 1, y: 2 }, { z: 0 });console.log(added); // { x: 1, y: 2, z: 0 } 스프레드 프로퍼티는 Object.assign 메소드를 대체할 수 있는 간편한 문법이다. 1234567891011121314// 객체의 병합// 프로퍼티가 중복되는 경우, 뒤에 위치한 프로퍼티가 우선권을 갖는다.const merged = { ...{ x: 1, y: 2 }, ...{ y: 10, z: 3 } };console.log(merged); // { x: 1, y: 10, z: 3 }// 특정 프로퍼티 변경const changed = { ...{ x: 1, y: 2 }, y: 100 };// changed = { ...{ x: 1, y: 2 }, ...{ y: 100 } }console.log(changed); // { x: 1, y: 100 }// 프로퍼티 추가const added = { ...{ x: 1, y: 2 }, z: 0 };// added = { ...{ x: 1, y: 2 }, ...{ z: 0 } }console.log(added); // { x: 1, y: 2, z: 0 }","link":"/2020/03/%EC%8A%A4%ED%94%84%EB%A0%88%EB%93%9C/"},{"title":"실행 컨텍스트 | javaScript","text":"실행 컨텍스트(Execution Context)는 식별자, 스코프, 호이스팅, 클로저 등의 동작 원리를 담고 있는 자바스크립트의 핵심 개념이다.실행 컨텍스트를 바르게 이해하면 자바스크립트가 스코프를 기반으로 식별자와 식별자에 바인딩된 값(식별자 바인딩)을 관리하는 방식과 호이스팅이 발생하는 이유, 그리고 클로저의 동작 방식에 대해 이해할 수 있다. 1. 소스 코드의 타입 소스 코드의 타입 설명 전역 코드(Global code) 전역에 존재하는 소스 코드를 말한다. 전역에 정의된 함수, 클래스등의 내부 코드는 포함되지 않는다. 함수 코드(Function code) 함수 내부에 존재하는 소스 코드를 말한다.함수 내부에 중첩된 함수,클래스 등의 내부코드는 포함되지 않는다. eval 코드(Eval code) 빌트인 전역 함수인 eval 함수에 인수로 전달되어 실행되는 소스 코드를 말한다. 모듈 코드(Module code) 모듈 내부에 존재하는 소스코드를 말한다. 모듈 내부의 함수, 클래스등의 내부 코드는 포함되지 않는다. 소스 코드(실행 가능한 코드, executable code)를 4가지 타입으로 구분하는 이유는 소스 코드의 타입에 따라 실행 컨텍스트를 생성하는 과정과 관리 내용이 다르기 때문이다. 전역 코드: 2. 소스 코드의 평가와 실행 소스 코드 평가 과정에서는 실행 컨텍스트를 생성하고 변수, 함수 등의 선언문 만을 먼저 실행하여 생성된 변수나 함수를 식별자를 키로 실행 컨텍스트가 관리하는 스코프(렉시컬 환경의 환경 레코드)에 등록한다. 소스 코드의 평가 과정이 끝나면 비로소 선언문을 제외한 소스 코드가 순차적으로 실행되기 시작한다. 이때 소스 코드 실행에 필요한 정보, 즉 변수나 함수의 참조를 실행 컨텍스트가 관리하는 스코프에서 취득한다. 그리고 변수 값의 변경과 같은 소스 코드의 실행 결과는 다시 실행 컨텍스트가 관리하는 스코프에 등록된다. 12var x;x = 1; 자바스크립트는 위 예제를 2개의 과정으로 나누어 처리한다. 먼저 소스 코드 평가 과정에서 변수 선언문 var x;을 먼저 실행한다. 이때 생성된 변수 x는 실행 컨텍스트가 관리하는 스코프에 등록된다. 소스 코드 평가 과정이 끝나면 비로소 소스 코드 실행 과정이 시작된다. 변수 선언문 var x;는 소스 코드 평가 과정에서 이미 실행이 완료되었다. 따라서 소스 코드 실행 과정에서는 변수 할당문 x = 1;만 실행된다. 이때 변수 x에 값을 할당하려면 변수 x가 선언된 변수인지 확인해야 한다. 이를 위해 실행 컨텍스트가 관리하는 스코프에 변수 x가 등록되어 있는지 확인한다. 만약 변수 x가 등록되어 있다면 변수 x는 선언된 변수, 즉 소스 코드 평가 과정에서 선언문이 실행되어 등록된 변수이다. 변수 x가 선언된 변수라면 값을 할당하고 할당 결과를 실행 컨텍스트에 등록하여 관리한다. 3. 실행 컨텍스트의 역할 아래 예제는 전역 코드와 함수 코드로 구성되어 있다. 자바스크립트 엔진이 아래 예제를 어떻게 평가하고 실행할지 생각해보자. 12345678910111213141516171819// 전역 변수 선언const x = 1;const y = 2;// 함수 정의function foo(a) { // 지역 변수 선언 const x = 10; const y = 20; // 메소드 호출 console.log(a + x + y); // 130}// 함수 호출foo(100);// 메소드 호출console.log(x + y); // 3 1. 전역 코드 평가 먼저 전역 코드를 실행하기에 앞서 전역 코드 평가 과정을 거치며 전역 코드 실행을 위한 준비를 한다. 소스 코드 평가 과정에서는 선언문 만을 먼저 실행한다. 따라서 전역 코드의 변수 선언문과 함수 선언문이 먼저 실행되고 그 결과 생성된 전역 변수와 전역 함수가 실행 컨텍스트가 관리하는 전역 스코프에 등록된다. 또한 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 객체의 전역 객체의 프로퍼티와 메소드가 된다. 2. 전역 코드 실행 전역 코드의 평가가 끝나면 전역 코드가 순차적으로 실행되기 시작한다. 이때 전역 변수에 값이 할당되고 함수가 호출된다. 함수가 호출되면 순차적으로 실행되던 전역 코드의 실행을 일시 중단하고 코드 실행 순서를 변경하여 함수 내부로 진입한다. 3. 함수 코드 평가 코드 실행 순서가 변경되어 함수 내부로 진입하면 함수 내부의 문들을 실행하기에 앞서 함수 코드 평가 과정을 거치며 함수 코드 실행을 위한 준비를 한다. 이때 매개 변수와 지역 변수 선언문이 먼저 실행되고 그 결과 생성된 매개 변수와 지역 변수가 실행 컨텍스트가 관리하는 지역 스코프에 등록된다. 또한 함수 내부에서 지역 변수처럼 사용할 수 있는 arguments 객체 도 생성되어 지역 스코프에 등록된다. 4. 함수 코드 실행 함수 코드의 평가가 끝나면 함수 코드가 순차적으로 실행되기 시작한다. 이때 매개 변수와 지역 변수에 값이 할당되고 console.log 메소드가 호출된다. console.log 메소드를 호출하기 위해 먼저 식별자 console을 스코프 체인을 통해 검색한다. 이를 위해 함수 코드의 지역 스코프는 상위 스코프인 전역 스코프와 연결되어야 한다. 하지만 식별자 console은 스코프 체인에 등록되어 있지 않고 전역 객체에 프로퍼티로 존재한다. 이는 전역 객체의 프로퍼티가 마치 전역 변수처럼 전역 스코프에서 검색 가능해야 한다는 것을 의미한다. 다음은 log 프로퍼티를 console 객체의 프로토타입 체인을 통해 검색한다. 그후 console.log 메소드의 인수로 전달된 표현식 a + x + y가 평가된다. 식별자 a, x, y는 스코프 체인을 통해 검색한다. console.log 메소드의 실행이 종료되면 함수 코드의 실행이 종료되고 함수 호출 이전으로 되돌아가 전역 코드 실행을 계속한다. 이처럼 코드가 실행되려면 스코프를 구분하여 식별자와 바인딩된 값을 관리할 수 있어야 한다. 그리고 중첩 관계에 의해 스코프 체인을 형성하여 식별자를 검색할 수 있어야 하고, 전역 객체의 프로퍼티도 전역 변수처럼 검색할 수 있어야 한다. 또한 함수 호출이 종료하면 함수 호출 이전으로 되돌아가기 위해 현재 실행 중인 코드와 이전에 실행하던 코드를 구분하여 관리해야 한다.이처럼 코드가 실행되려면 아래와 같이 스코프, 식별자, 코드 실행 순서 등의 관리가 필요하다. 선언에 의해 생성된 모든 식별자(변수, 함수, 클래스 등)를 스코프를 구분하여 등록하고 상태 변화(식별자에 바인딩된 값의 변화)를 지속적으로 관리할 수 있어야 한다. 스코프는 중첩 관계에 의해 스코프 체인을 형성해야 한다. 즉, 스코프 체인을 통해 상위 스코프로 이동하며 식별자를 검색할 수 있어야 한다. 현재 실행 중인 코드의 실행 순서를 변경(예를 들어 함수 호출에 의한 실행 순서 변경)할 수 있어야 하며 다시 되돌아갈 수도 있어야 한다. 실행 컨텍스트(Execution context)는 소스 코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 좀 더 구체적으로 말해, 실행 컨텍스트는 식별자(변수, 함수, 클래스 등의 이름)를 등록하고 관리하는 스코프와 코드 실행 순서 관리를 구현한 내부 매커니즘으로 모든 코드는 실행 컨텍스트를 통해 실행되고 관리된다. 식별자와 스코프는 실행 컨텍스트의 렉시컬 환경으로 관리하고 코드 실행 순서는 실행 컨텍스트 스택으로 관리한다. 먼저 실행 컨텍스트 스택에 대해 살펴보도록 하자. 4. 실행 컨텍스트 스택 아래 예제를 살펴보자. 12345678910111213const x = 1;function foo () { const y = 2; function bar () { const z = 3; console.log(x + y + z); } bar();}foo(); // 6 위 예제는 소스 코드의 타입으로 분류할 때 전역 코드와 함수 코드로 이루어져 있다. 자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성한다. 그리고 함수가 호출되면 함수 코드를 평가하여 함수 실행 컨텍스트를 생성한다. 이때 생성된 실행 컨텍스트는 스택 자료 구조로 관리된다. 실행 컨텍스트 스택을 콜 스택(call stack)이라고 부르기도 한다.위 코드를 실행하면 코드가 실행되는 시간의 흐름에 따라 실행 컨텍스트 스택에는 아래와 같이 실행 컨텍스트가 추가(push)되고 제거(pop)된다. 1.전역 코드의 평가와 실행 자바스크립트 엔진은 먼저 전역 코드를 평가하여 전역 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시한다. 이때 전역 변수 x와 전역 함수 foo는 전역 실행 컨텍스트에 등록된다. 이후, 전역 코드가 실행되기 시작하여 전역 변수 x에 값이 할당되고 전역 함수 foo가 호출된다. 2.foo 함수 코드의 평가와 실행 전역 함수 foo가 호출되면 전역 코드의 실행은 일시 중단되고 코드의 제어권(control)이 foo 함수 내부로 이동한다. 자바스크립트 엔진은 foo 함수 내부의 함수 코드를 평가하여 foo 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시한다. 이때 foo 함수의 지역 변수 y와 중첩 함수 bar가 foo 함수 실행 컨텍스트에 등록된다. 이후, foo 함수 코드가 실행되기 시작하여 지역 변수 y에 값이 할당되고 중첩 함수 bar가 호출된다. 3.bar 함수 코드의 평가와 실행 중첩 함수 bar가 호출되면 함수 foo 코드의 실행은 일시 중단되고 코드의 제어권이 bar 함수 내부로 이동한다. 자바스크립트 엔진은 bar 함수 내부의 함수 코드를 평가하여 bar 함수 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시한다. 이때 bar 함수의 지역 변수 z가 bar 함수 실행 컨텍스트에 등록된다. 이후, bar 함수 코드가 실행되기 시작하여 지역 변수 z에 값이 할당되고 console.log 메소드를 호출(console.log 메소드도 함수이므로 호출되면 실행 컨텍스트를 생성하고 실행 컨텍스트 스택에 푸시한다. 이는 그림에서 생략하였다)한 이후, 함수 bar는 종료된다. 4.foo 함수 코드로 복귀 함수 bar가 종료되면 코드의 제어권은 다시 함수 foo로 이동한다. 이때 자바스크립트 엔진은 bar 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 팝하여 제거한다. 그리고 함수 foo는 더 이상 실행할 코드가 없으므로 종료된다. 5. 전역 코드로 복귀 함수 foo가 종료되면 코드의 제어권은 다시 전역 코드로 이동한다. 이때 자바스크립트 엔진은 foo 함수 실행 컨텍스트를 실행 컨텍스트 스택에서 팝하여 제거한다. 그리고 더 이상 실행할 전역 코드가 남아 있지 않으므로 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 팝되어 실행 컨텍스트 스택에는 아무것도 남아있지 않게 된다. 이처럼 실행 컨텍스트 스택은 코드의 실행 순서를 관리한다. 소스 코드가 평가되면 실행 컨텍스트가 생성되고 실행 컨텍스트 스택의 최상위에 쌓인다. 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트는 언제나 현재 실행 중인 코드의 실행 컨텍스트이다. 따라서 실행 컨텍스트 스택의 최상위에 존재하는 실행 컨텍스트를 실행 중인 실행 컨텍스트(running execution context)라 부른다. 5. 동기식 처리 모델과 비동기식 처리 모델 자바스크립트 엔진은 단 하나의 실행 컨텍스트 스택을 갖는다. 즉, 자바스크립트 애플리케이션은 여러 개의 실행 컨텍스트 스택에서 실행할 수 없다. 이는 동시에 두가지 이상의 태스크를 실행할 수 없다는 것을 의미한다. 실행 컨텍스트 스택의 최상위 스택만이 현재 실행 중인 실행 컨텍스트이며 나머지 실행 컨텍스트는 모두 대기중인 실행 컨텍스트이기 때문이다. 이는 자바스크립트가 싱글 스레드(single thread)로 동작한다는 것을 의미한다. 실행 컨텍스트 스택의 최상위 스택(실행 중인 실행 컨텍스트)을 제외한 모든 실행 컨텍스트는 모두 실행 대기 중인 태스크들이다. 이들은 현재 실행 중인 실행 컨텍스트가 팝되어 실행 컨텍스트 스택에서 제거될 때까지 실행을 대기한다. 이처럼 하나의 처리가 종료되어야 다음 처리를 실행할 수 있는 것을 동기식 처리 모델(Synchronous processing model)이라고 한다. 동기식 처리 모델은 직렬적으로 태스크(task)를 수행한다. 즉, 태스크는 순차적으로 실행되며 어떤 작업이 수행 중이면 다음 작업은 대기하게 된다. 예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 작업을 수행할 때, 서버에 데이터를 요청하고 데이터가 응답될 때까지 이후 태스크들은 블로킹(blocking, 작업 중단)된다. 다행히도 자바스크립트는 비동기식 처리 모델을 지원한다. 비동기식 처리 모델(Asynchronous processing model 또는 Non-Blocking processing model)은 병렬적으로 태스크를 수행한다. 즉, 태스크가 종료되지 않은 상태라 하더라도 대기하지 않고 다음 태스크를 실행한다. 예를 들어 서버에서 데이터를 가져와서 화면에 표시하는 태스크를 수행할 때, 서버에 데이터를 요청한 이후 서버로부터 데이터가 응답될 때까지 대기하지 않고(Non-Blocking) 즉시 다음 태스크를 수행한다. 이후 서버로부터 데이터가 응답되면 이벤트가 발생하고 이벤트 핸들러가 응답된 데이터를 가지고 수행할 태스크를 계속해 수행한다. 자바스크립트의 Timer 함수(setTimeout, setInterval), Ajax 요청은 비동기식 처리 모델로 동작한다. 비동기식 처리 모델은 자바스크립트에 동시성(concurrency)을 부여하여 싱글 스레드의 약점을 보완해 준다. 하지만 비동기식으로 동작하는 코드는 순차적으로 실행되지 않아 가독성이 좋지 않고 콜백 헬을 유발하며 에러 처리가 어렵다는 약점이 있다. 6. 렉시컬 환경 렉시컬 환경(Lexical Environment)은 식별자와 식별자에 바인딩된 값 그리고 상위 스코프에 대한 참조를 기록하는 환경으로 실행 컨텍스트를 구성하는 컴포넌트이다. 실행 컨텍스트 스택이 코드의 실행 순서를 관리한다면 렉시컬 환경은 스코프와 식별자를 관리한다. 렉시컬 환경은 객체 형태의 스코프(전역, 함수, 블록 스코프)를 생성하여 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다. 즉, 렉시컬 환경은 스코프를 구분하여 식별자를 등록하고 관리하는 저장소 역할을 하는 렉시컬 스코프의 실체이다. 실행 컨텍스트는 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트로 구성된다. 생성 초기의 실행 컨텍스트와 렉시컬 환경을 그림으로 표현하면 아래와 같다. 생성 초기에 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트는 하나의 동일한 렉시컬 환경을 참조한다. 이후, 몇가지 상황을 만나면 VariableEnvironment 컴포넌트를 위한 새로운 렉시컬 환경을 생성하여 생성하고 이때부터 VariableEnvironment 컴포넌트와 LexicalEnvironment 컴포넌트는 내용이 달라지는 경우도 있다. 환경 레코드(Environment Record): 스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소이다. 환경 레코드는 소스 코드의 타입에 따라 내용에 차이가 있다. 외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference): 외부 렉시컬 환경에 대한 참조는 상위 스코프를 가리킨다. 이때 상위 스코프란 외부 렉시컬 환경, 즉 해당 실행 컨텍스트를 생성한 소스 코드를 포함하는 상위 코드의 렉시컬 환경을 말한다. 외부 렉시컬 환경에 대한 참조를 통해 단방향 링크드 리스트인 스코프 체인을 구현한다. 7. 실행 컨텍스트의 생성과 식별자 검색 과정 아래 예제를 통해 어떻게 실행 컨텍스트가 생성되고 코드 실행 결과가 관리되는지 그리고 어떻게 실행 컨텍스트를 통해 식별자를 검색하는지 살펴보도록 하자. 123456789101112131415var x = 1;const y = 2;function foo (a) { var x = 3; const y = 4; function bar (b) { const z = 5; console.log(a + b + x + y + z);} bar(10);}foo(20); // 42 7.1. 전역 객체 생성 전역 객체(“21.4 전역 객체” 참고)는 전역 코드가 평가되기 이전에 생성된다. 이때 전역 객체에는 전역 프로퍼티와 전역 함수, 표준 빌트인 객체가 추가되며 동작 환경(클라이언트 사이드 또는 서버 사이드)에 따라 클라이언트 사이드 Web API 또는 특정 환경을 위한 호스트 객체(“21.1 자바스크립트 객체의 분류” 참고)를 포함한다. 전역 객체도 Object.prototype을 상속받는다. 즉, 전역 객체도 프로토타입 체인의 일원이다. 1234// Object.prototype.toStringwindow.toString(); // -&gt; \"[object Window]\"window.__proto__.__proto__.__proto__.__proto__ === Object.prototype; // -&gt; true 7.2. 전역 코드 평가 12345671. 전역 실행 컨텍스트 생성2. 전역 렉시컬 환경 생성 2.1. 전역 환경 레코드 생성 2.1.1. 객체 환경 레코드 생성 2.1.2. 선언적 환경 레코드 생성 2.2. 외부 렉시컬 환경에 대한 참조 할당 2.3. this 바인딩 위 과정을 거쳐 생성된 전역 실행 컨텍스트와 렉시컬 환경은 아래와 같다. 생성 과정에 대해 자세히 순서대로 살펴보자 1. 전역 실행 컨텍스트 생성 먼저 전역 실행 컨텍스트를 생성하여 실행 컨텍스트 스택에 푸시한다. 이때 전역 실행 컨텍스트는 실행 컨텍스트 스택의 최상위, 즉 실행 중인 실행 컨텍스트(running execution context)가 된다. 2. 전역 렉시컬 환경 생성 전역 렉시컬 환경(Global Lexical Environment)을 생성하고 전역 실행 컨텍스트의 LexicalEnvironment 컴포넌트와 VariableEnvironment 컴포넌트에 바인딩한다. “23.6. 렉시컬 환경”에서 살펴보았듯이 렉시컬 환경은 2개의 컴포넌트, 즉 환경 레코드(Environment Record), 외부 렉시컬 환경에 대한 참조(OuterLexicalEnvironmentReference)로 구성된다. 2.1. 전역 환경 레코드 생성 전역 렉시컬 환경을 구성하는 컴포넌트인 전역 환경 레코드(Global Environment Record)는 전역 변수를 관리하는 전역 스코프 그리고 전역 객체의 표준 빌트인 객체, 전역 빌트인 프로퍼티 및 메소드를 제공한다. 모든 전역 변수가 전역 객체의 프로퍼티가 되는 ES6 이전에는 전역 객체가 전역 환경 레코드의 역할을 수행했다. 하지만 “15.2.4. 전역 객체와 let”에서 살펴본 바와 같이 ES6의 let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재하게 된다. 이처럼 기존의 var 키워드로 선언한 전역 변수와 ES6의 let, const 키워드로 선언한 전역 변수를 구분하여 관리하기 위해 전역 스코프 역할을 하는 전역 환경 레코드는 객체 환경 레코드(Object Environment Record)와 선언적 환경 레코드(Declarative Environment Record)로 구성되어 있다.(그림 23-11 참고) 객체 환경 레코드는 기존의 전역 객체가 관리하던 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수 그리고 표준 빌트인 객체, 전역 빌트인 프로퍼티 및 메소드를 관리하고, 선언적 환경 레코드는 let, const 키워드로 선언한 전역 변수를 관리한다. 즉, 전역 환경 레코드의 객체 환경 레코드와 선언적 환경 레코드는 서로 협력하여 전역 스코프와 전역 객체(전역 변수의 전역 객체 프로퍼티화)를 관리한다. 2.1.1. 객체 환경 레코드 생성 전역 환경 레코드를 구성하는 컴포넌트인 객체 환경 레코드는 BindingObject라고 부르는 객체와 연결된다.(그림 23-11 참고) BindingObject는 “23.7.1 전역 객체 생성”에서 생성된 전역 객체이다. 전역 코드 평가 과정에서 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의된 전역 함수는 전역 환경 레코드의 객체 환경 레코드에 연결된 BindingObject를 통해 전역 객체의 프로퍼티와 메소드가 된다. 그리고 이때 등록된 식별자를 전역 환경 레코드의 객체 환경 레코드에서 검색하면 전역 객체의 프로퍼티를 검색하여 반환한다. 이것이 var 키워드로 선언된 전역 변수와 함수 선언문으로 정의된 전역 함수가 전역 객체의 프로퍼티와 메소드가 되고 전역 객체의 식별자(window) 없이 전역 객체의 프로퍼티를 참조(예를 들어 window.alert을 alert으로 참조)할 수 있는 메커니즘이다. 위 예제의 전역 변수 x와 전역 함수 foo는 객체 환경 레코드를 통해 객체 환경 레코드의 BindingObject에 바인딩되어 있는 전역 객체의 프로퍼티와 메소드가 된다. 12345var x = 1;const y = 2;function foo (a) {... 변수 x는 var 키워드로 선언한 변수이다. 따라서 “선언 단계”와 “초기화 단계”가 동시에 진행된다. (“4.3. 변수 선언” 참고) 다시 말해, 전역 코드 평가 시점에 객체 환경 레코드에 바인딩된 BindingObject에 변수 식별자를 등록한 다음, 암묵적으로 undefined를 바인딩한다. 따라서 var 키워드로 선언한 변수는 코드 실행 단계(현 시점은 코드 실행 단계가 아니라 코드 평가 단계이다.)에서 변수 선언문 이전에도 참조할 수 있다. 단, 변수 선언문 이전에 참조한 변수의 값은 언제나 undefined이다. var 키워드로 선언한 변수에 할당한 함수 표현식도 이와 동일하게 동작한다. 이것이 변수 호이스팅이 발생하는 원인이다. 함수 선언문으로 정의한 함수가 평가되면 함수 이름과 동일한 이름의 식별자를 객체 환경 레코드에 바인딩된 BindingObject에 등록하고 생성된 함수 객체를 즉시 할당한다. 이것이 변수 호이스팅과 함수 호이스팅의 차이이다. 즉, 함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 2.1.2. 선언적 환경 레코드 생성 var 키워드로 선언한 전역 변수와 함수 선언문으로 정의한 전역 함수 이외의 선언, 즉 let, const 키워드로 선언한 전역 변수(let, const 키워드로 선언한 변수에 할당한 함수 표현식 포함)는 선언적 환경 레코드에 등록되고 관리된다. “15.2.4. 전역 객체와 let”에서 ES6의 let, const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 되지 않고 개념적인 블록 내에 존재하게 된다고 했다. 여기서 개념적인 블록이 바로 전역 환경 레코드의 선언적 환경 레코드이다. 따라서 위 예제의 전역 변수 y는 let, const 키워드로 선언한 변수이므로 전역 객체의 프로퍼티가 되지 않고 window.y와 같이 전역 객체의 프로퍼티로서 참조할 수도 없다. 또한 const 키워드로 선언한 변수는 “선언 단계”와 “초기화 단계”가 분리되어 진행한다. 따라서 초기화 단계, 즉 변수 할당문이 실행이 되기 이전까지 일시적 사각지대(Temporal Dead Zone; TDZ)에 빠지게 된다. (“15.2.3. 변수 호이스팅” 참고) let, const 키워드로 선언한 변수도 변수 호이스팅이 발생하는 것은 변함이 없다. 단, let, const 키워드로 선언한 변수는 변수 할당문이 실행되기 이전까지 일시적 사각지대에 빠지기 때문에 참조할 수 없다. 2.2. 외부 렉시컬 환경에 대한 참조 할당 외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)는 현재 평가 중인 코드를 포함하는 외부 코드의 렉시컬 환경, 즉 상위 스코프를 가리킨다. 이를 통해 단방향 링크드 리스트인 스코프 체인을 구현한다. 현재 평가 중인 코드는 전역 코드이다. 전역 코드를 포함하는 코드는 없으므로 전역 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에는 null이 할당된다. 이는 전역 렉시컬 환경이 스코프 체인의 최상위에 존재함을 의미한다. 외부 렉시컬 환경에 대한 참조를 통해 스코프 체인을 구현하는 메커니즘에 대해서는 함수 코드 평가에서 좀 더 자세히 살펴보도록 하자. 2.3. this 바인딩 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다. 일반적으로 전역 코드에서 this는 전역 객체를 가리키므로 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에는 전역 객체가 바인딩된다. 전역 코드에서 this를 참조하면 전역 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 바인딩되어 있는 객체가 반환된다. 참고로 전역 환경 레코드를 구성하는 객체 환경 레코드와 선언적 환경 레코드에는 this 바인딩이 없다. this 바인딩은 전역 환경 레코드와 함수 환경 레코드에만 존재한다. 함수 환경 레코드에 대해서는 “23.7.4. foo 함수 코드 평가”에서 살펴보도록 하자. 7.3. 전역 코드 실행 이제 전역 코드가 순차적으로 실행되기 시작한다. 변수 할당문이 실행되어 전역 변수 x, y에 값이 할당된다. 그리고 함수 foo가 호출된다. 변수 할당문 또는 함수 호출문을 실행하려면 먼저 변수 또는 함수 이름이 선언된 식별자인지 확인해야 한다. 선언되지 않는 식별자는 참조할 수 없으므로 할당이나 호출도 할 수 없기 때문이다. 또한 식별자는 스코프가 다르면 같은 이름을 갖을 수 있다. 즉, 동일한 이름의 식별자가 다른 스코프가 여러 개 존재할 수도 있다. 따라서 식별자가 선언된 식별자인지, 선언된 식별자라면 어느 스코프의 식별자를 참조하면 되는지 결정할 필요가 있다. 이를 식별자 결정(identifier resolution)이라 한다. 식별자 결정을 위해 식별자를 검색할 때는 실행 중인 실행 컨텍스트에서 식별자를 검색하기 시작한다. 선언된 식별자는 실행 컨텍스트의 렉시컬 환경의 환경 레코드에 등록되어 있다. 현재 실행 중인 실행 컨텍스트는 전역 실행 컨텍스트이므로 전역 렉시컬 환경에서 식별자 x, y, foo를 검색하기 시작한다. 만약 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경, 즉 상위 스코프로 이동하여 식별자를 검색한다. 이것이 바로 스코프 체인의 동작 원리이다. 하지만 전역 렉시컬 환경은 스코프 체인의 종점이므로 전역 렉시컬 환경에서 검색할 수 없는 식별자는 참조 에러(ReferenceError)를 발생시킨다. 식별자 결정에 실패하였기 때문이다. 이처럼 실행 컨텍스트는 소스 코드를 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역이다. 7.4. foo 함수 코드 평가 예제 코드를 다시 한번 살펴보자. 현재 전역 코드 평가를 통해 전역 실행 컨텍스트가 생성되었고 전역 코드를 실행하고 있다. 현재 진행 상황은 foo 함수를 호출하기 직전이다. 123456789101112131415var x = 1;const y = 2;function foo (a) { var x = 3; const y = 4; function bar (b) { const z = 5; console.log(a + b + x + y + z);} bar(10);}foo(20); // 42 foo 함수가 호출되면 전역 코드의 실행을 일시 중단하고 foo 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드를 평가하기 시작한다. 함수 코드 평가는 아래 순서로 진행된다. 123451. 함수 실행 컨텍스트 생성2. 함수 렉시컬 환경 생성 2.1. 함수 환경 레코드 생성 2.2. 외부 렉시컬 환경에 대한 참조 할당 2.3. this 바인딩 위 과정을 거쳐 생성된 foo 함수 실행 컨텍스트와 렉시컬 환경은 아래와 같다. 세부적인 생성 과정에 대해 순서대로 살펴보자. 1. 함수 실행 컨텍스트 생성 먼저 foo 함수 실행 컨텍스트를 생성한다. 생성된 함수 실행 컨텍스트는 함수 렉시컬 환경이 완성된 다음 실행 컨텍스트 스택에 푸시된다. 이때 foo 함수 실행 컨텍스트는 실행 컨텍스트 스택의 최상위, 즉 실행 중인 실행 컨텍스트(running execution context)가 된다. 2. 함수 렉시컬 환경 생성 foo 함수 렉시컬 환경(Function Lexical Environment)을 생성하고 foo 함수 실행 컨텍스트에 바인딩한다. “23.6. 렉시컬 환경”에서 살펴보았듯이 렉시컬 환경은 2개의 컴포넌트, 즉 환경 레코드, 외부 렉시컬 환경에 대한 참조로 구성된다. 2.1. 함수 환경 레코드 생성 함수 렉시컬 환경을 구성하는 컴포넌트 중 하나인 함수 환경 레코드(Function Environment Record)는 매개 변수, arguments 객체, 함수 내에서 선언한 지역 변수와 함수 정의를 등록하고 관리한다. 2.2. 외부 렉시컬 환경에 대한 참조 할당 외부 렉시컬 환경에 대한 참조에는 foo 함수 정의가 평가된 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다. foo 함수는 전역 코드에 정의된 전역 함수이다. 따라서 foo 함수 정의는 전역 코드 평가 시점에 평가된다. 이 시점의 실행 중인 실행 컨텍스트는 전역 실행 컨텍스트이다. 따라서 외부 렉시컬 환경에 대한 참조에는 전역 렉시컬 환경의 참조가 할당된다. “13.7. 렉시컬 스코프”에서 자바스크립트는 함수를 어디서 호출했는지가 아니라 어디에 정의했는지에 따라 상위 스코프를 결정한다고 했다. 그리고 함수 객체는 자신이 정의된 스코프, 즉 상위 스코프를 기억한다고 했다. 자바스크립트 엔진은 함수 정의를 평가하여 함수 객체를 생성할 때, 현재 실행 중인 실행 컨텍스트의 렉시컬 환경, 즉 함수의 상위 스코프를 함수 객체의 내부 슬롯 [[Environment]]에 저장한다. 함수 렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 할당되는 것은 바로 함수의 상위 스코프를 가리키는 함수 객체의 내부 슬롯 [[Environment]]에 저장된 렉시컬 환경의 참조이다. 즉, 함수 객체의 내부 슬롯 [[Environment]]이 바로 렉시컬 스코프를 구현하는 메커니즘이다. 함수 객체의 내부 슬롯 [[Environment]]와 렉시컬 스코프는 클로저를 이해할 수 있는 중요한 단서이다. 이에 대해서는 “24. 클로저”에서 자세히 살펴보도록 하자. 2.3. this 바인딩 함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 this가 바인딩된다. [[ThisValue]] 내부 슬롯에 바인딩될 객체는 “22. this”에서 살펴본 바와 같이 함수의 호출 방식에 따라 결정된다. foo 함수는 일반 함수로 호출되었므로 this는 전역 객체를 가리킨다. 따라서 함수 환경 레코드의 [[ThisValue]] 내부 슬롯에는 전역 객체가 바인딩된다. foo 함수 내부에서 this를 참조하면 함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 바인딩되어 있는 객체가 반환된다. 7.5. foo 함수 코드 실행 이제 foo 함수 코드가 순차적으로 실행되기 시작한다. 매개 변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 x, y에 값이 할당된다. 그리고 함수 bar가 호출된다. 이때 식별자 결정을 위해 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색하기 시작한다. 현재 실행 중인 실행 컨텍스트는 foo 함수 실행 컨텍스트이므로 foo 함수 렉시컬 환경에서 식별자 x, y를 검색하기 시작한다. 만약 실행 중인 실행 컨텍스트의 렉시컬 환경에서 식별자를 검색할 수 없으면 외부 렉시컬 환경에 대한 참조가 가리키는 렉시컬 환경으로 이동하여 식별자를 검색한다. 다행히 모든 식별자는 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 모두 검색할 수 있다. 검색된 식별자에 값을 바인딩한다. 7.6. bar 함수 코드 평가 예제 코드를 다시 한번 살펴보자. 현재 foo 함수 코드 평가를 통해 foo 함수 실행 컨텍스트가 생성되었고 foo 함수 코드를 실행하고 있다. 현재 진행 상황은 bar 함수를 호출하기 직전이다. 123456789101112131415var x = 1;const y = 2;function foo (a) { var x = 3; const y = 4; function bar (b) { const z = 5; console.log(a + b + x + y + z); } bar(10);}foo(20); // 42 bar 함수가 호출되면 함수 내부로 코드의 제어권이 이동한다. 그리고 함수 코드를 평가하기 시작한다. 실행 컨텍스트와 렉시컬 환경의 생성 과정은 foo 함수 코드 평가와 동일하다. 생성된 bar 함수 실행 컨텍스트와 렉시컬 환경은 아래와 같다. 7.7. bar 함수 코드 실행 이제 bar 함수 코드가 순차적으로 실행되기 시작한다. 매개 변수에 인수가 할당되고, 변수 할당문이 실행되어 지역 변수 z에 값이 할당된다. 그리고 console.log(a + b + x + y + z); 가 실행된다. 이 코드는 아래의 순서로 실행된다. 1. 식별자 console 검색 먼저 console 식별자를 스코프 체인에서 검색한다. 스코프 체인은 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작하여 외부 렉시컬 환경에 대한 참조로 이어지는 렉시컬 환경의 연속이다. 따라서 식별자를 검색할 때는 언제나 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 검색하기 시작한다. 실행 중인 실행 컨텍스트는 bar 함수 실행 컨텍스트이다. 따라서 bar 함수 실행 컨텍스트의 bar 함수 렉시컬 환경(bar Lexical Environment)에서 console 식별자 검색을 시작한다. 이곳에는 console 식별자가 없으므로 스코프 체인 상의 상위 스코프, 즉 외부 렉시컬 환경에 대한 참조가 가리키는 foo 함수 렉시컬 환경(foo Lexical Environment)으로 이동하여 console 식별자를 검색한다. 이곳에도 console 식별자가 없으므로 스코프 체인 상의 상위 스코프, 즉 외부 렉시컬 환경에 대한 참조가 가리키는 전역 렉시컬 환경(Global Lexical Environment)으로 이동하여 console 식별자를 검색한다. 전역 렉시컬 환경은 객체 환경 레코드와 선언적 환경 레코드로 구성되어 있다. console 식별자는 객체 환경 레코드의 BinginObject, 즉 전역 객체에서 찾을 수 있다. 2. log 메소드 검색 이제 console 식별자에 바인딩된 객체, 즉 console 객체에서 log 메소드를 검색한다. 이때 console 객체의 프로토타입 체인을 통해 메소드를 검색한다. log 메소드는 상속된 프로퍼티가 아니라 console 객체가 직접 소유하는 프로퍼티이다. 3. 표현식 a + b + x + y + z의 평가 이제 console.log 메소드에 전달할 인수, 즉 표현식 a + b + x + y + z를 평가하기 위해 식별자 a, b, x, y, z 검색한다. 식별자는 스코프 체인, 즉 현재 실행 중인 실행 컨텍스트의 렉시컬 환경에서 시작하여 외부 렉시컬 환경에 대한 참조로 이어지는 렉시컬 환경의 연속에서 검색한다. 식별자 a는 foo 함수 렉시컬 환경에서, 식별자 b는 bar 함수 렉시컬 환경에서, 식별자 x와 y는 foo 함수 렉시컬 환경에서, 식별자 z는 bar 함수 렉시컬 환경에서 검색된다. 4. console.log 메소드 호출 표현식 a + b + x + y + z 가 평가되어 생성한 값 42(20 + 10 + 3 + 4 + 5)를 console.log 메소드에 전달하여 호출한다. 7.8. bar 함수 코드 실행 종료 console.log 메소드가 호출되고 종료하면 더 이상 실행할 코드가 없으므로 bar 함수 코드의 실행이 종료된다. 이때 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 팝되어 제거되고 foo 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다. 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 제거되었다고 해서 bar 함수 렉시컬 환경까지 즉시 소멸하는 것은 아니다. 렉시컬 환경은 실행 컨텍스트에 의해 참조되기는 하지만 독립적인 객체이다. 객체를 포함한 모든 값은 누군가에 의해 참조되지 않을 때 비로소 가비지 컬렉터에 의해 해제되어 소멸한다. bar 함수 실행 컨텍스트가 소멸되었다 하더라도 만약 bar 함수 렉시컬 환경을 누군가 참조하고 있다면 bar 함수 렉시컬 환경은 소멸하지 않는다. 7.9. foo 함수 코드 실행 종료 bar 함수가 종료하면 더 이상 실행할 코드가 없으므로 foo 함수 코드의 실행이 종료된다. 이때 실행 컨텍스트 스택에서 foo 함수 실행 컨텍스트가 팝되어 제거되고 전역 실행 컨텍스트가 실행 중인 실행 컨텍스트가 된다. 7.10. 전역 코드 실행 종료 foo 함수가 종료하면 더 이상 실행할 전역 코드가 없으므로 전역 코드의 실행이 종료되고 전역 실행 컨텍스트도 실행 컨텍스트 스택에서 팝되어 실행 컨텍스트 스택에는 아무것도 남아있지 않게 된다. 8. 실행 컨텍스트와 블록 레벨 스코프 “15. let, const 키워드와 블록 레벨 스코프”에서 살펴본 바와 같이 var 키워드로 선언한 변수는 오로지 함수의 코드 블록 만을 지역 스코프로 인정하는 함수 레벨 스코프를 따른다. 하지만 let 키워드로 선언한 변수는 모든 코드 블록(함수, if 문, for 문, while 문, try/catch 문 등) 을 지역 스코프로 인정하는 블록 레벨 스코프(Block-level scope)를 따른다. 아래 예제를 살펴보자. 12345678let x = 1;if (true) { let x = 10; console.log(x); // 10}console.log(x); // 1 if 문의 코드 블록 내에서 let 키워드로 변수가 선언되었다. 따라서 if 문이 실행되면 if 문의 블록 레벨 스코프를 생성해야 한다. 이를 위해 if 문을 위한 선언적 환경 레코드를 갖는 렉시컬 환경을 새롭게 생성하여 기존의 전역 렉시컬 환경을 교체한다. 이때 새롭게 생성된 if 문을 위한 렉시컬 환경의 외부 렉시컬 환경에 대한 참조는 교체된 이전의 전역 렉시컬 환경을 가리킨다. (ES6 Spec: Block Evaluation 참고) if 문 실행이 종료되면 if 문이 실행되기 이전의 렉시컬 환경으로 되돌린다. 이는 if 문 뿐만이 아니라 모든 블록문에 적용된다. for 문의 경우, 초기문에 let 키워드를 사용한 for 문은 반복될 때마다 새로운 렉시컬 환경을 생성한다. 만약 for 문 내에서 정의된 함수가 있다면 이 함수의 상위 스코프는 for 문이 생성한 렉시컬 환경이다. 이때 함수의 상위 스코프는 for 문이 반복될 때 마다 식별자(초기화 변수 및 for 문 내 지역 변수 등)의 값을 유지해야 한다. 이를 위해 for 문이 반복될 때마다 독립적인 렉시컬 환경을 생성하여 식별자의 값을 유지한다. 이에 대해서는 “24. 클로저”에서 자세히 살펴보도록 하자.","link":"/2020/03/%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"},{"title":"자료구조와 알고리즘 | With javaScript","text":"자료구조와 알고리즘 1.1 선형 검색 문제for를 사용하여 구현하시오 12345678910111213141516 function linearSearch(array, target) { for (var i = 0; i &lt;= array.length; i += 1) { if ( array[i] === target) { return array[i] - 1; } } return -1; }console.log(linearSearch([1, 2, 3, 4, 5, 6], 1));console.log(linearSearch([1, 2, 3, 4, 5, 6], 3));console.log(linearSearch([1, 2, 3, 4, 5, 6], 5));console.log(linearSearch([1, 2, 3, 4, 5, 6], 6));console.log(linearSearch([1, 2, 3, 4, 5, 6], -1));console.log(linearSearch([1, 2, 3, 4, 5, 6], 0)); console.log(linearSearch([1, 2, 3, 4, 5, 6], 7)); 1.2 이진 검색 이진 검색은 선형 검색과는 달리 정렬된 배열에서만 동작 선형 검색은 배열의 모든 요소를 하나씩 확인해야하지만 이진검색은 중간값과 검색 대상 값을 비교하여 검색 범위를 매번 반으로 줄여나간다. 예를 들어 선형검색은 480,000개를 하나씩 찾아 나가지만 이진 검색은 18번만에 찾아낸다. 시간 복잡도: O(log n) 이진 검색을 통해 주어진 배열(array)에 주어진 값(target)이 요소로 존재하는지 확인하여 존재하는 경우 해당 인덱스를 반환하고 존재하지 않는 경우 -1을 반환하는 함수를 구현하라. 단, 아래의 빌트인 함수 이외에는 어떤 빌트인 함수도 사용하지 않아야 하며, while 문을 사용하여 구현하여야 한다. 힌트: Math.floor 12345678910111213141516171819202122232425262728console.log(binarySearch([1,2,3,4,5,6,7,8,9,10], 3));function binarySearch(arr, target) { let start = 0; let end = arr.length - 1; // 인덱스 때문에 -1 하는 것. console.log(start); console.log(end); while (start &lt;= end) { // 무한루프 인지해야함 console.log(start); console.log(end); let mid = Math.floor((start + end) / 2); // 중앙값 만들기 위해 내림차수 floor메소드 /2 console.log(mid); let array = arr[mid]; // 시작값 + 끝값 /2 한 걸 array 변수에 할당. 단지 그냥 깔끔하게 쓰려고한거임 console.log(array); if (array === target) { // dataArray[mid]값 === target값 같으면 바로 배열 리턴하기 return array; } else if (array &gt; target) { end = mid - 1; console.log(end); } else { start = mid + 1; console.log(start); } } return -1;} 2. 정렬 2.1 버블 정렬(buble sort) 버블 정렬은 가장 간단하지만 가장 느린 정렬 알고리즘이다. 버블 정렬은 배열을 순회하면서 요소가 다른 요소보다 큰 경우 두 요소를 교환한다. 시간 복잡도: O(n2) 버블 정렬을 통해 주어진 배열(array)을 정렬하는 함수를 구현하라. 단, 어떠한 빌트인 함수도 사용하지 않고 for 문을 사용하여 구현하여야 한다. 12345678910111213141516171819const bubbleSort = function(array) { const length = array.length; let i, j, change; for (i = 0; i &lt; length - 1; i++) { // 순차적으로 비교하기 위한 반복문 console.log(i) for (j = 0; j &lt; length - 1 - i; j++) { // 끝까지 돌았을 때 다시 처음부터 비교하기 위한 반복문 console.log(j) console.log(i) if (array[j] &gt; array[j + 1]) { // 두 수를 비교하여 앞 수가 뒷 수보다 크면 change = array[j]; // 두 수를 서로 바꿔준다 array[j] = array[j + 1]; array[j + 1] = change; } } } return array;};console.log(bubbleSort([5,1,7,4,6,3,2,8])); 느낀점array를 다른 변수에 참조하면 원본의 array가 변경되여 값을 바꿔치기 할 수 있다.array[1] = 5; 이런 식으로 배열 인덱스의 값을 바꾸는 걸 새로 알았다.(물론 배열 학습 전임);중첩 for문 안에 첫 번째 회전이 끝나면 array[j + 1]은 array[j]로 변함 j가 1이거나 array[j + 1]은 같으니까.. (j가 0부터 시작했다는 가정하에.)시간복잡도 O(n2)라 성능이 별로 좋지 않다.","link":"/2020/03/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98(%EC%88%9C%EC%B0%A8%EA%B2%80%EC%83%89)/"},{"title":"제어문을 이용한 문제풀기 | With javaScript","text":"문제1 변수 x가 10보다 크고 20보다 작을 때 변수 x를 출력하는 조건식을 완성하라 12345var x = 15; if(x &gt; 10 &amp;&amp; x &lt; 20) { console.log(x); } 문제2 for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 출력하시오. 123for(let i = 0; i &lt; 10; i+=2) { console.log(i);} 문제3 for문을 사용하여 0부터 10미만의 정수 중에서 짝수만을 작은 수부터 문자열로 출력하시오. 123for(let i = 0; i &lt; 10; i+=2) { console.log(String(i));} 문제4 for문을 사용하여 0부터 10미만의 정수 중에서 홀수만을 큰수부터 출력하시오. 123for(let i = 9; i &gt; 0; i-=2) { console.log(i);} 문제5 while문을 사용하여 0 부터 10 미만의 정수 중에서 짝수만을 작은 수부터 출력하시오. 123456var count = 0;while (count &lt; 10) { count+=2; console.log(count);} 문제6 while문을 사용하여 0 부터 10 미만의 정수 중에서 홀수만을 큰수부터 출력하시오. 1234567var count = 9;do { console.log(count); count-=2;} while (count &gt; 0); 문제7 for 문을 사용하여 0부터 10미만의 정수의 합을 출력하시오. 123456var count = 0;for(let i = 0; i &lt; 10; i++) { count = count + i;}console.log(count); 문제8 1부터 20 미만의 정수 중에서 2 또는 3의 배수가 아닌 수의 총합을 구하시오. 12345678var count = 0;for(var i = 0; i &lt; 20; i++) { if(!(i % 2 == 0) &amp;&amp; !(i % 3 == 0)) { count += i; }}console.log(count); 문제9 1부터 20 미만의 정수 중에서 2 또는 3의 배수인 수의 총합을 구하시오. 12345678var count = 0;for(var i = 0; i &lt; 20; i++) { if((i % 2 == 0) || (i % 3 == 0)) { count += i; }}console.log(count); 문제10 두 개의 주사위를 던졌을 때, 눈의 합이 6이 되는 모든 경우의 수를 출력하시오. 1234567for (let i = 0; i &lt; 6; i++) { for (let j = 0; j &lt; 6; j++) { if (i + j === 6) { console.log(`${i}, ${j}`) } }} 문제1111. 삼각형 출력하기 - pattern 1다음을 참고하여 *(별)로 높이가 5인(var line = 5) 삼각형을 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 123456789var star = '';for ( var i = 0; i &lt; 5; i++) { for ( var j = 0; j &lt;= i; j++) { star += '*'; } star += '\\n';}console.log(star); 문제1212. 삼각형 출력하기 - pattern 2다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 1234567891011var star = '';for (var i = 1; i &lt;= 5; i++) { for (var j = 1; j &lt; i; j++) { star += ' '; } for (var j = 5; j &gt;= i; j--) { star += '*'; } console.log(star); star = '';} 문제1313. 삼각형 출력하기 - pattern 3다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 12345678910var star = '';for (var i = 5; i &gt; 0; i--) { for (var j = 0; j &lt; i; j++) { star += '*'; } star += '\\n';}console.log(star); 문제1414. 삼각형 출력하기 - pattern 4다음을 참고하여 *(별)로 트리를 문자열로 완성하라. 개행문자(‘\\n’)를 사용하여 개행한다. 완성된 문자열의 마지막은 개행문자(‘\\n’)로 끝나도 관계없다. 12345678910var star = '';for (var i = 1; i &lt;= 5; i++) { for (var j = 1; j &lt;= 5 - i; j++) { star += ' '; } for (var j = 1; j &lt;= i; j++) { star += '*'; } console.log(star); star = ''; 문제15 정삼각형 출력하기 12345678910var star = '';for (var i = 1; i &lt;= 5; i++) { for (var j = 5; j &gt; i; j--) { star += ' '; } for (var j = 1; j &lt;= i * 2 - 1; j++) { star += '*'; } console.log(star); star = ''; 문제16 역정삼각형 출력하기 1234567891011var star = '';for (var i = 1; i &lt;= 10; i += 2) { for (var j = 1; j &lt; i / 2; j++) { star += ' '; } for (var j = 10 - i; j &gt; 0; j--) { star += '*'; } console.log(star); star = '';}","link":"/2020/03/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98(%EC%A0%9C%EC%96%B4%EB%AC%B8)/"},{"title":"클래스 | javaScript","text":"1. 클래스 클래스는 생성자 함수와 매우 유사하게 동작하지만 아래와 같이 몇가지 차이가 있다. 클래스는 new 연산자를 사용하지 않고 호출하면 에러가 발생한다. 클래스는 상속을 지원하는 extends와 super 키워드를 제공한다. 클래스는 호이스팅이 발생하지 않는 것처럼 동작한다. 클래스 내의 모든 코드에는 암묵적으로 strict 모드가 지정되어 실행되며 strict 모드를 해지할 수 없다. 클래스의 constructor, 프로토타입 메소드, 정적 메소드는 모두 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다. 다시말해, 열거되지 않는다. 2. 클래스 정의클래스는 class 키워드를 사용하여 정의한다. 클래스 이름은 생성자 함수와 마찬가지로 파스칼 케이스를 사용한다. 12// 클래스 선언문class Person {} 함수와 마찬가지로 표현식으로 클래스를 정의할 수도 있다. 12345// 익명 클래스 표현식const Person = class {};// 기명 클래스 표현식const Person = class MyClass {}; 클래스가 값으로 사용할 수 있는 일급 객체라는 것은 클래스가 일급 객체라는 특징을 갖는다. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다. 변수나 자료 구조(객체, 배열등)에 저장할수 있다. 함수의 매개 변수에게 전달할수 있다. 함수의 반환값으로 사용할 수 있다. 클래스 몸체에는 0개 이상의 메소드만을 정의할 수 있다. 클래스 몸체에서 정의할 수 있는 메소드는 constructor(생성자), 프로토타입 메소드, 정적 메소드 3가지가 있다. 12345678910111213141516171819202122232425262728// 클래스 선언문class Person { // 생성자 constructor(name) { // 인스턴스 생성 및 초기화 this.name = name; // name 프로퍼티 public하다. } // 프로토타입 메소드 sayHi() { console.log(`Hi! My name is ${this.name}`); } // 정적 메소드 static sayHello() { console.log('Hello!'); }}// 인스턴스 생성const me = new Person('Lee');// 인스턴스의 프로퍼티 참조console.log(me.name); // Lee// 프로토타입 메소드 호출me.sayHi(); // Hi! My name is Lee// 정적 메소드 호출Person.sayHello(); // Hello! 3. 클래스 호이스팅클래스는 클래스 정의 이전에 참조할 수 없다. 4. 인스턴스 생성클래스는 함수로 평가된다. 123class Person {}console.log(typeof Person); // function 클래스는 생성자 함수이며 new 연산자와 함께 호출되어 인스턴스를 생성한다. 123456class Person {}// 인스턴스 생성const me = new Person();console.log(me); // Person {} 클래스는 인스턴스를 생성하는 것이 유일한 존재 이유이므로 반드시 new 연산자와 함께 호출하여야 한다. 12345class Person {}// new 연산자 없이 호출하면 타입 에러가 발생한다.const me = Person();// TypeError: Class constructor Foo cannot be invoked without 'new' 5. 메소드 클래스 몸체에는 0개 이상의 메소드 만을 선언할 수 있다.클래스 몸체에서 정의할 수 있는 메소드는 constructor(생성자), 프로토타입 메소드, 정적메소드 3가지가 있다. 5.1 constructorconstructor는 인스턴스를 생성하고 초기화하기 위한 특수한 메소드이다. constructor는 이름을 변경할 수 없다. 1234567class Person { // 생성자 constructor(name) { // 인스턴스 생성 및 초기화 this.name = name; }} constructor 내부의 this는 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스를 가리킨다. constructor는 메소드로 해석되는 것이 아니라 클래스가 평가되어 생성한 함수 객체 코드의 일부가 된다. constructor는 클래스 내에 최대 한 개만 존재할 수 있다. 만약 클래스가 2개 이상의 constructor를 포함하면 문법 에러 (SyntaxError)가 발생한다. 12345class Person { constructor() {} constructor() {}}// SyntaxError: A class may only have one constructor constructor는 생략할 수 있다. 1class Person {} constructor를 생략하면 클래스에 아래와 같이 디폴트 constructor가 암묵적으로 정의된다. 인스턴스를 생성할 때, 클래스 외부에서 인스턴스 프로퍼티의 초기값을 전달하려면 아래와 같이 constructor에 매개변수를 선언하고 인스턴스를 생성할 때 초기값을 전달한다. 이때 초기값은 constructor의 매개변수에게 전달된다. 1234567891011class Person { constructor(name, address) { // 인스턴스 초기화 this.name = name; this.address = address; }}// 초기값을 전달한다. 초기값은 constructor에 전달된다.const me = new Person('Lee', 'Seoul');console.log(me); // Person {name: \"Lee\", address: \"Seoul\"} 명시적으로 원시값을 반환하면 원시값 반환은 무시되고 암묵적으로 this가 반환된다. 1234567891011class Person { constructor(name) { this.name = name; // 명시적으로 원시 값을 반환하면 원시 타입의 반환은 무시되고 암묵적으로 this가 반환된다. return 100; }}const me = new Person('Lee');console.log(me); // Person { name: \"Lee\" } 이처럼 constructor 내부에서 명시적으로 this가 아닌 다른 값을 반환하는 것은 클래스의 기본 동작을 훼손한다. 따라서 constructor 내부에서 return 문을 반드시 생략해야 한다. 5.2. 프로토타입 메소드 클래스 몸체에서 프로토타입 메소드를 생성하기 위해서는 prototype 프로퍼티에 메소드를 추가하지 않아도 기본적으로 프로토타입 메소드가 된다. 123456789101112131415class Person { // 생성자 constructor(name) { // 인스턴스 생성 및 초기화 this.name = name; } // 프로토타입 메소드 sayHi() { console.log(`Hi! My name is ${this.name}`); }}const me = new Person('Lee');me.sayHi(); // Hi! My name is Lee 생성자 함수와 마찬가지로 클래스가 생성한 인스턴스는 프로토타입 체인의 일원이 된다. 12345678910// me 객체의 프로토타입은 Person.prototype이다.console.log(Object.getPrototypeOf(me) === Person.prototype); // trueconsole.log(me instanceof Person); // true// Person.prototype의 프로토타입은 Object.prototype이다.console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype); // trueconsole.log(me instanceof Object); // true// me 객체의 constructor는 Person 클래스이다.console.log(me.constructor === Person); // true 위 예제의 Person 클래스는 아래와 같이 프로토타입 체인을 생성한다. 결국 클래스는 생성자 함수와 같이 인스턴스를 생성하는 생성자 함수라고 볼 수 있다. 5.3. 정적 메소드 정적(static) 메소드는 인스턴스를 생성하지 않아도 호출할 수 있는 메소드를 말한다. 생성자 함수의 경우, 정적 메소드를 생성하기 위해서는 아래와 같이 명시적으로 생성자 함수에 메소드를 추가해야 한다. 123456789101112// 생성자 함수function Person(name) { this.name = name;}// 정적 메소드Person.sayHi = function () { console.log('Hi!');};// 정적 메소드 호출Person.sayHi(); // Hi! 클래스에서는 메소드에 static 키워드를 붙이면 정적 메소드(클래스 메소드)가 된다. 123456789101112class Person { // 생성자 constructor(name) { // 인스턴스 생성 및 초기화 this.name = name; } // 정적 메소드 static sayHi() { console.log('Hi!'); }} 위 예제의 Person 클래스는 아래와 같이 프로토타입 체인을 생성한다. 정적 메소드는 클래스 자신의 메소드가 된다. 따라서 정적 메소드는 클래스 정의 이후 인스턴스를 생성하지 않아도 호출할 수 있다. 12// 정적 메소드는 인스턴스 없이도 호출할 수 있다.Person.sayHi(); // Hi 5.4. 정적 메소드와 프로토타입 메소드의 차이 정적 메소드와 프로토타입 메소드는 자신이 속해 있는 프로토타입 체인이 다르다. 정적 메소드는 클래스로 호출하고 프로토타입 메소드는 인스턴스로 호출한다. 정적 메소드는 인스턴스 프로퍼티를 참조할 수 없지만 프로토타입 메소드는 인스턴스 프로퍼티를 참조할 수 있다. 1234567891011class Square { // 정적 메소드 static area(width, height) { return width * height; }}console.log(Square.area(10, 10)); // 100const square = new Square();square.area(); // TypeError: square.area is not a function 5.5 클래스에서 정의한 메소드의 특징 클래스에서 정의한 메소드는 아래와 같은 특징을 갖는다. function 키워드를 생략한 메소드 축약 표현을 사용한다. 객체 리터럴과는 다르게 클래스에 메소드를 정의할 때는 콤마가 필요 없다. 암묵적으로 strict 모드로 실행된다. (“20. strict mode” 참고) for…in 문이나 Object.keys 메소드 등으로 열거할 수 없다. 즉, 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이다. (“16. 프로퍼티 어트리뷰트” 참고) 내부 메소드 [[Construct]]를 갖지 않는 non-constructor이다. 따라서 new 연산자와 함께 호출할 수 없다. (“17.2.5. constructor와 non-constructor의 구분” 참고) 6. 클래스의 인스턴스 생성 과정클래스는 new 연산자 없이 호출할 수 없다. 인스턴스 생성과 this 바인딩 new 연산자와 함께 클래스를 호출하면 constructor의 내부 코드가 실행되기에 앞서 암묵적으로 빈 객체가 생성된다. 이 빈 객체가 바로 (아직 완성되지는 않았지만) 클래스가 생성한 인스턴스이다. 이때 클래스가 생성한 인스턴스의 프로토타입으로 클래스의 prototype 프로퍼티가 가리키는 객체가 설정된다. 그리고 암묵적으로 생성된 빈 객체, 즉 인스턴스는 this에 바인딩된다. 따라서 constructor 내부의 this는 클래스가 생성한 인스턴스를 가리킨다. 인스턴스 초기화 constructor의 내부 코드가 실행되어 this에 바인딩되어 있는 인스턴스를 초기화한다. 즉, this에 바인딩되어 있는 인스턴스에 프로퍼티를 추가하고 constructor가 인수로 전달받은 초기값으로 인스턴스의 프로퍼티 값을 초기화한다. 만약 constructor가 생략되었다면 이 과정도 생략된다. 프로토타입 / 정적 메소드 추가 클래스 몸체에 정의한 프로토타입 메소드가 존재하면 클래스의 prototype 프로퍼티가 가리키는 프로토타입에 추가한다. 클래스 몸체에 정의한 정적 메소드가 존재하면 클래스에 추가한다. 인스턴스 반환 클래스의 모든 처리가 끝나면 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. 1234567891011121314151617181920212223class Person { // 생성자 constructor(name) { // 1. 암묵적으로 인스턴스가 생성되고 this에 바인딩된다.console.log(this); // Person {} console.log(Object.getPrototypeOf(this) === Person.prototype); // true // 2. this에 바인딩되어 있는 인스턴스를 초기화한다. this.name = name; // 4. 완성된 인스턴스가 바인딩된 this가 암묵적으로 반환된다. } // 3. 프로토타입 메소드는 클래스의 prototype에 메소드로 추가된다. sayHi() { console.log(`Hi! My name is ${this.name}`); } // 3. 정적 메소드는 클래스에 메소드로 추가된다. static sayHello() { console.log('Hello!'); }} 7. 프로퍼티 7.1. 인스턴스 프로퍼티인스턴스 프로퍼티는 constructor 내부에서 정의 해야 한다. 123456789class Person { constructor(name) { // 인스턴스 프로퍼티 this.name = name; }}const me = new Person('Lee');console.log(me); // Person {name: \"Lee\"} 8. 상속에 의한 클래스 확장 8.1. 클래스 상속과 생성자 함수 상속 상속에 의한 클래스 확장은 기존의 클래스를 상속받아 새로운 클래스를 확장(extends)하여 정의하는 것이다. 클래스와 생성자 함수는 인스턴스를 생성할 수 있는 함수라는 점에서 매우 유사하다. 하지만 클래스는 상속을 통해 기존의 클래스를 확장할 수 있는 문법이 기본적으로 제공되지만 생성자 함수는 그렇지 않다. 예를 들어 동물을 추상화한 Animal 클래스와 새와 사자를 추상화한 Bird, Lion 클래스를 정의한다고 생각해보자. 새와 사자는 동물에 속하므로 동물의 속성을 갖는다. 하지만 새와 사자는 자신만의 고유한 속성도 갖는다. 이때 Animal 클래스는 동물의 속성을 표현하고 Bird, Lion 클래스는 상속을 통해 동물 클래스의 속성을 그대로 사용하고 자신만의 고유한 속성만을 추가하여 확장할 수 있다. Bird 클래스와 Lion 클래스는 상속을 통해 Animal 클래스의 속성을 그대로 사용하고 자신만의 고유한 속성을 추가하여 확장하였다. 이처럼 상속에 의한 클래스 확장은 코드 재사용 관점에서 매우 유용하다. 상속을 통해 Animal 클래스를 확장한 Bird 클래스를 구현해 보자. 123456789101112131415161718192021222324class Animal { constructor(age, weight) { this.age = age; this.weight = weight; } eat() { return 'eat'; } move() { return 'move'; }}class Bird extends Animal { fly() { return 'fly'; }}const bird = new Bird(1, 5);console.log(bird); // Bird {age: 1, weight: 5}console.log(bird instanceof Bird); // trueconsole.log(bird instanceof Animal); // trueconsole.log(bird.eat()); // eatconsole.log(bird.move()); // moveconsole.log(bird.fly()); // fly 상속에 의해 확장된 클래스 Bird에 의해 생성된 인스턴스의 프로토타입 체인은 아래와 같다. 클래스는 상속을 통해 다른 클래스를 확장할 수 있는 문법인 extends 키워드가 기본적으로 제공된다. extends 키워드를 사용한 클래스 확장은 간편하고 직관적이다. 하지만 생성자 함수는 클래와 같이 상속을 통해 다른 생성자 함수를 확장할 수 있는 문법이 제공되지 않는다. 8.2. extends 키워드상속을 통해 클래스를 확장하려면 extends 키워드를 사용하여 상속받을 클래스를 정의한다. 12345// 수퍼(파생/부모) 클래스Class Base {}// 서브(파생/자식) 클래스class Derived extends Base {} 상속을 통해 확장된 클래스를 서브 클래스(sub class)라 부르고, 서브 클래스에게 상속된 클래스를 수퍼 클래스(super class)라 부른다. 서브 클래스를 파생 클래스(derived class) 또는 자식 클래스(child class), 수퍼 클래스를 베이스 클래스(base class) 또는 부모 클래스(parent class)라고 부르기도 한다. extends 키워드의 역할은 수퍼 클래스와 서브 클래스 간의 상속 관계를 설정하는 것이다. 클래스도 프로토타입을 통해 상속 관계를 구현한다. 수퍼 클래스와 서브 클래스는 인스턴스의 프로토타입 체인 뿐만이 아니라, 클래스 간의 프로토타입 체인도 생성한다. 이를 통해 프로토타입 메소드, 정적 메소드 모두 상속이 가능하다. 8.3. 동적 상속 extends 키워드는 생성자 함수를 상속받아 클래스를 확장할 수도 있다. 단, extends 키워드 앞에는 반드시 클래스가 와야 한다. 12345678910// 생성자 함수function Base(a) { this.a = a;}// 생성자 함수를 상속받는 서브 클래스class Derived extends Base {}const derived = new Derived(1);console.log(derived); // Derived {a: 1} extends 키워드 다음에는 클래스뿐만이 아니라 [[Construct]] 내부 메소드를 갖는 함수 객체를 반환하는 모든 표현식을 사용할 수 있다. 이를 통해 동적으로 상속받을 대상을 결정할 수 있다. 1234567891011121314function Base1() {}class Base2 {}let condition = true;// 조건에 따라 동적으로 상속 대상을 결정하는 서브 클래스class Derived extends (condition ? Base1 : Base2) {}const derived = new Derived();console.log(derived); // Derived {}console.log(derived instanceof Base1); // trueconsole.log(derived instanceof Base2); // false 8.4. 서브 클래스의 constructor 클래스에 constructor를 생략하면 클래스에 아래와 같이 디폴트 constructor가 암묵적으로 정의된다. 1constructor() {} 서브 클래스에 constructor를 생략하면 클래스에 아래와 같이 디폴트 constructor가 암묵적으로 정의된다. args는 new 연산자와 함께 클래스를 호출할 때 전달한 인수의 리스트이다. super()는 수퍼 클래스의 constructor(super-constructor)를 호출하여 인스턴스를 생성한다. 1constructor(...args) { super(...args); } 위 예제는 아래와 같이 암묵적으로 디폴트 constructor가 정의된다. 123456789101112// 수퍼 클래스class Base { constructor() {}}// 서브 클래스class Derived extends Base { constructor() { super(); }}const derived = new Derived();console.log(derived); // Derived {} 위 예제와 같이 수퍼 클래스와 서브 클래스 모두 constructor를 생략하면 빈 객체가 생성된다.프로퍼티를 소유하는 인스턴스를 생성하려면 constructor 내부에서 인스턴스에 프로퍼티를 추가해야 한다. 8.5. super 키워드 super 키워드는 함수처럼 호출할 수도 있고 this와 같이 식별자처럼 참조할 수 있는 특수한 키워드이다. super는 아래와 같이 동작한다. super를 호출하면 수퍼 클래스의 constructor(super-constructor)를 호출한다. super를 참조하면 수퍼 클래스의 메소드를 호출할 수 있다.","link":"/2020/03/%ED%81%B4%EB%9E%98%EC%8A%A4/"},{"title":"클로저 | javaScript","text":"1. 클로저와 렉시컬 환경 12345678910111213const x = 1;// ①function outer() { const x = 10; const inner = function () { console.log(x); }; // ② return inner;}// 함수 outer를 호출하면 중첩 함수 inner를 반환한다.// 그리고 함수 outer의 실행 컨텍스트는 실행 컨텍스트 스택에서 pop된다.const innerFunc = outer(); // ③innerFunc(); // ④ 10 함수 outer를 호출하면 함수 outer는 중첩 함수 inner를 반환하고 생명 주기를 마감한다. 또한 outer의 지역 변수 x또한 생명 주기를 마감한다. 따라서 함수 outer의 지역 변수 x는 더 이상 유효하지 않게 되어 변수 x에 접근할 수 있는 방법은 달리 없어 보인다. innerFunc()은 10을 반환한다. 이미 생명 주기가 종료되어 실행 컨텍스트 스택에서 제거된 함수 outer의 지역 변수 x가 다시 부활이라도 한 듯이 동작하고 있다. 이처럼 자신을 포함하고 있는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 외부 함수 밖에서 중첩 함수를 호출하더라도 외부 함수의 지역 변수에 접근할 수 있는데 이러한 함수를 클로저라고 부른다. 클로저는 함수와 그 함수가 선언된 렉시컬 환경과의 조합이다.outer 함수의 실행 컨텍스트는 실행 컨텍스트 스택에서 제거되지만 outer 함수의 렉시컬환경까지 소멸하는 것은 아니다. outer 함수의 렉시컬 환경은 inner()함수의 [[Environmnent]]내부 슬롯에 의해 참조되고 있고 inner함수는 전역 변수 innerFunc에 의해 참조되고 있으므로 가비지 컬렉션의 대상이 되지 않기 떄문이다. 가비지 컬렉터는 누군가가 참조되고 있는 메모리 공간을 함부로 해제하지 않는다. 자바스크립트의 모든 함수는 상위 스코프를 기억하므로 이론적으로 모든 함수는 클로저이다. 하지만 일반적으로 모든 함수를 클로저라고 하지는 않는다. 아래 예제를 브라우저에서 디버깅 모드로 실행해보자. 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; function foo() { const x = 1; const y = 2; // 일반적으로 클로저라고 하지 않는다. function bar() { const z = 3; // 상위 스코프의 식별자를 참조하지 않다. console.log(z); } return bar; } const bar = foo(); bar(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 예제의 중첩 함수 bar는 상위 스코프의 어떤 식별자도 참조하지 않는다. 이처럼 상위 스코프의 어떤 식별자도 참조하지 않는 경우, 대부분의 모던 브라우저는 최적화를 통해 아래와 같이 상위 스코프를 기억하지 않는다. 참조하지도 않는 식별자를 기억하는 것은 메모리 낭비이기 떄문이다. 따라서 bar 함수는 클로저라고 할 수 없다. 또 다른 예제를 브라우저에서 디버깅 모드로 실행해보자. 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; function foo() { const x = 1; // 일반적으로 클로저라고 하지 않는다. // bar 함수는 클로저였지만 곧바로 소멸한다. function bar() { // 상위 스코프의 식별자를 참조한다. console.log(x); } bar(); } foo(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 예제의 중첩 함수 bar는 상위 스코프의 식별자를 참조하고 있으므로 클로저이다. 하지만 외부 함수로부터 외부로 반환되지 않는다. 즉, 외부 함수와 생명주기가 같다. 이러한 경우, 중첩 함수 bar는 클로저였지만 외부함수와 더불어 소멸되기 떄문에 호출 위치에 상관없이 상위 스코프를 기억하고 참조할 수 있다는 클로저의 본질에 부합하지 않는다. 따라서 중첩 함수 inner는 일반적으로 클로저라고 하지 않는다. 또 다른 예제를 브라우저에서 디버깅모드로 실행해보자 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;script&gt; function foo() { const x = 1; const y = 2; // 클로저 function bar() { // 상위 스코프의 식별자 x만을 참조한다. console.log(x); } return bar; } const bar = foo(); bar(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 예제의 중첩 함수 bar는 상위 스코프의 식별자를 참조하고 있으므로 클로저이다. 그리고 외부 함수로부터 외부로 반환되어 외부 함수보다 더 오래 살아 남는다. 이처럼 자신을 포함하고 있는 외부 함수보다 중첩 함수가 더 오래 유지되는 경우, 외부 함수 밖에서 중첩 함수가 호출되더라도 외부 함수의 식별자에 접근할 수 있는 함수를 일반적으로 클로저(closure)라고 부른다. 클로저에 의해 참조되는 상위 스코프의 변수를 자유 변수라고 부른다. 클로저란 “함수가 자유 변수에 대해 닫혀있다”라는 의미이다. 이론적으로 클로저는 상위 스코프를 기억해야 하므로 불필요한 메모리의 점유를 걱정할 수도 있겠다. 하지만 모던 자바스크립트 엔진은 최적화가 잘 되어 있어서 클로저가 참조하고 있지 않는 식별자는 기억하지 않는다. 즉, 상위 스코프의 식별자 중에서 기억해야 할 식별자만 기억한다. 기억해야 할 식별자를 기억하는 것은 낭비라고 볼 수 없다. 따라서 클로저의 메모리 낭비는 걱정하지 않아도 된다. 클로저를 적극적으로 사용하자! 하지만 난 잘 못쓴다. 2. 클로저의 활용 클로저는 상태를 안전하게 유지하기 위해 사용한다. 즉, 상태가 의도치 않게 변경되지 않도록 안전하게 은닉한다. 그리고 이전 상태를 기억하다가 상태가 변경되면 최신 상태를 유지한다. 버튼이 클릭될 떄마다 클릭한 횟수를 누적하여 화면에 표시되는 카운터를 만들어보자. 이 예제의 클릭된 횟수(변수 num)가 바로 유지 해야할 상태이다. 12345678910111213141516&lt;button class=\"increase\"&gt;+&lt;/button&gt;&lt;span class=\"counter\"&gt;0&lt;/span&gt;&lt;script&gt; // 카운트 상태를 유지하기 위한 전역 변수 let num = 0; const $counter = document.querySelector('.counter'); // 버튼이 클릭되면 전역 변수 num을 1 증가 시킨다. const increase = function () { $counter.textContent = ++num; // 상태 변화 }; document.querySelector('.increase').onclick = increase;&lt;/script&gt; 위 코드는 잘 동작하지만 오류를 발생시킬 가능성을 내포하고 있는 좋지 않은 코드다. 처음으로 버튼 클릭 이벤트가 발생하여 이벤트 핸들러 increase가 처음 호출되기 직전에 전역 변수 num의 값은 반드시 0이여야 한다. 그리고 다음 버튼 클릭 이벤트가 발생하여 이벤트 핸들러 increase가 호출되기 전까지 전역 변수 num의 값은 변경되지 말고 이전의 카운트 상태를 유지해야 한다. 다시 말해 전역 변수 num의 값, 즉 카운트 상태는 반드시 이벤트 핸들러 increase만이 변경할 수 있어야 한다. 하지만 전역 변수 num은 언제든지 누구나 접근할 수 있고 변경할 수 있다. 이는 의도치 않게 상태가 변경될 수 있다는 것을 의미한다. 만약 누군가에 의해 의도치 않게 전역 변수 num의 값, 즉 카운트 상태가 변경되면 이는 오류로 이어진다. 따라서 카운트 상태를 유지하기 위한 변수 num은 이벤트 핸들러 increase만이 참조/변경할 수 있도록 하는 것이 바람직하다. 전역 변수 num을 이벤트 핸들러 increase의 지역 변수로 바꾸어 의도치 않은 상태 변경을 방지해보자. 1234567891011121314&lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); // 버튼이 클릭되면 지역 변수 num을 1 증가 시킨다. const increase = function () { let num = 0; $counter.textContent = ++num; // 상태 변경 }; document.querySelector('.increase').onclick = increase; &lt;/script&gt; 카운트 상태를 유지하기 위한 전역 변수 num을 이벤트 핸들러 increase의 지역 변수로 변경하여 의도치 않은 상태 변경은 방지했다. 이제 변수 num의 상태는 이벤트 핸들러 increase만이 변경할 수 있다. 하지만 이벤트 핸들러 increase가 호출될 때마다 지역 변수 num은 다시 선언되고 0으로 초기화되기 때문에 출력 결과는 언제나 1이다. 다시 말해 변경된 이전 상태를 기억하지 못한다. 이전 상태를 유지할 수 있도록 클로저를 사용해보자. 123456789101112131415161718&lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); // 버튼이 클릭되면 자유 변수 num을 1 증가 시킨다. const increase = (function () { // 카운트 상태를 유지하기 위한 자유 변수 let num = 0; return function () { $counter.textContent = ++num; // 상태 변경 }; }()); document.querySelector('.increase').onclick = increase; &lt;/script&gt; 스크립트가 실행되면 즉시 실행 함수(immediately-invoked function expression)가 호출되고 즉시 실행 함수가 반환한 함수가 변수 increase에 할당된다. 변수 increase에 할당된 함수는 자신이 정의된 위치에 의해 결정된 상위 스코프, 즉 즉시 실행 함수의 렉시컬 환경(Lexical environment)을 기억하는 클로저다. 즉시 실행 함수는 호출된 이후 소멸되지만 즉시 실행 함수가 반환한 클로저는 변수 increase에 할당되어 increase 버튼을 클릭할 때마다 호출된다. 이때 즉시 실행 함수가 반환한 클로저는 자신이 정의된 위치에 의해 결정된 상위 스코프, 즉 즉시 실행 함수의 렉시컬 환경을 기억하고 있다. 따라서 즉시 실행 함수가 반환한 클로저는 카운트 상태를 유지하기 위한 자유 변수 num을 언제나 어디서 호출하든지 참조하고 변경할 수 있다. 즉, 상태를 유지할 수 있다. 이처럼 상태를 안전하게 유지해야 하는 상황에 클로저는 매우 유용하다. 즉시 실행 함수는 한번만 실행되므로 increase가 호출될 때마다 변수 counter가 재차 초기화될 일은 없을 것이다. 또한 변수 counter는 외부에서 직접 접근할 수 없는 은닉된 private 변수이므로 전역 변수를 사용했을 때와 같이 의도되지 않은 변경을 걱정할 필요도 없기 때문에 보다 안정적인 프로그래밍이 가능하다. 현재 increase 버튼만을 대응하는 위 예제를 decrease 버튼에도 대응할 수 있도록 좀 더 발전시켜보자. 12345678910111213141516171819202122232425262728&lt;span class=\"counter\"&gt;0&lt;/span&gt;&lt;button class=\"decrease\"&gt;-&lt;/button&gt;&lt;script&gt; const $counter = document.querySelector('.counter'); const counter = (function () { // 카운트 상태를 유지하기 위한 자유 변수 let num = 0; // 클로저를 메소드로 갖는 객체를 반환한다. // 객체 리터럴은 스코프를 만들지 않는다. // 따라서 아래 메소드들의 상위 스코프는 즉시 실행 함수의 스코프이다. return { // num: 0, // 프로퍼티는 public이므로 정보 은닉이 되지 않는다. increase() { $counter.textContent = ++num; // 상태 변경 }, decrease() { if (num &lt;= 0) return; $counter.textContent = --num; // 상태 변경 } }; }()); document.querySelector('.increase').onclick = counter.increase; document.querySelector('.decrease').onclick = counter.decrease;&lt;/script&gt; 위 예제에서 즉시 실행 함수가 반환하는 객체 리터럴은 함수 실행 단계에서 평가되어 객체가 된다. 이때 객체의 메소드인 함수도 함수 객체로 생성된다. 객체 리터럴의 중괄호는 코드 블록이 아니므로 별도의 스코프를 생성하지 않는다. 따라서 위 예제의 increase, decrease 메소드의 상위 스코프는 increase, decrease 메소드가 평가되는 시점에 실행 중인 실행 컨텍스트인 즉시 실행 함수 실행 컨텍스트의 렉시컬 환경이다. 다시 말해, increase, decrease 메소드의 상위 스코프는 즉시 실행 함수의 스코프이다. 따라서 increase, decrease 메소드가 언제 어디서 호출되던지 상관없이 increase, decrease 함수는 즉시 실행 함수의 스코프의 식별자를 참조할 수 있다. 위 예제를 생성자 함수로 표현하면 아래와 같다. 12345678910111213141516171819202122232425262728293031323334353637&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt; &lt;button class=\"increase\"&gt;+&lt;/button&gt; &lt;span class=\"counter\"&gt;0&lt;/span&gt; &lt;button class=\"decrease\"&gt;-&lt;/button&gt; &lt;script&gt; const $counter = document.querySelector('.counter'); const Counter = (function () { // ① 카운트 상태를 유지하기 위한 자유 변수 let num = 0; function Counter() { // this.num = 0; // ② 프로퍼티는 public이므로 정보 은닉이 되지 않는다. } Counter.prototype.increase = function () { $counter.textContent = ++num; }; Counter.prototype.decrease = function () { if (num &lt;= 0) return; $counter.textContent = --num; }; return Counter; }()); const counter = new Counter(); document.querySelector('.increase').onclick = counter.increase; document.querySelector('.decrease').onclick = counter.decrease; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 위 예제의 num(①)은 생성자 함수 Counter가 생성할 인스턴스의 프로퍼티가 아니라 즉시 실행 함수 내에서 선언된 변수다. 만약 num이 생성자 함수 Counter가 생성할 인스턴스의 프로퍼티라면(②) 인스턴스를 통해 외부에서 접근이 가능한 public 프로퍼티가 된다. 하지만 즉시 실행 함수 내에서 선언된 변수 num은 인스턴스를 통해 접근할 수 없으며 즉시 실행 함수 외부에서도 접근할 수 없는 은닉된 변수이다. 생성자 함수 Counter는 increase, decrease 메소드를 프로토타입을 통해 상속받는 인스턴스를 생성한다. 이 메소드들은 모두 자신의 함수 정의가 평가되어 함수 객체가 될 때, 실행 중인 실행 컨텍스트, 즉 즉시 실행 함수 실행 컨텍스트의 렉시컬 환경을 기억하는 클로저이다. 따라서 프로토타입을 통해 상속되는 프로토타입 메소드일지라도 즉시 실행 함수의 자유 변수 num을 참조할 수 있다. 다시 말해, 변수 num의 값은 increase, decrease 메소드만이 변경할 수 있다. 이러한 클로저의 특징을 사용해 클래스 기반 언어의 private 키워드를 흉내낼 수 있다. 변수 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있다. 상태 변경이나 가변(mutable) 데이터를 피하고 불변성(Immutability)을 지향하는 함수형 프로그래밍에서 부수 효과(Side effect)를 최대한 억제하여 오류를 피하고 프로그램의 안정성을 높이기 위해 클로저는 적극적으로 사용된다.","link":"/2020/03/%ED%81%B4%EB%A1%9C%EC%A0%80/"},{"title":"표준빌트인 객체 | javaScript","text":"1.자바스크립트 객체의 분류 - 표준 빌트인 객체 표준 빌트인 객체(standard built-in objects / native objects / global objects)는 ECMAScript 사양에 정의된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공한다. 표준 빌트인 객체는 ECMAScript 사양에 정의된 객체이므로 자바스크립트 실행 환경(브라우저 또는 Node.js 환경)과 관계없이 언제나 사용할 수 있다. 표준 빌트인 객체는 전역 객체의 프로퍼티로서 제공된다. 따라서 별도의 선언없이 전역 변수처럼 언제나 참조할 수 있다. 호스트 객체호스트 객체(host objects)는 ECMAScript 사양에 정의되어 있지 않지만 자바스크립트 실행 환경(브라우저 환경 또는 Node.js 환경. “3.1 자바스크립트 실행 환경” 참고)에서 추가적으로 제공하는 객체를 말한다.브라우저 환경에서는 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공하고 Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공한다. 사용자 정의 객체사용자 정의 객체(user-defined objects)는 표준 빌트인 객체와 호스트 객체처럼 기본 제공되는 객체가 아닌 사용자가 직접 정의한 객체를 말한다. 2.표준 빌트인 객체 자바스크립트는 40여개의 표준 빌트인 객체를 제공한다. Math, Reflect, JSON을 제외한 표준 빌트인 개체는 모두 인스턴스를 생성할 수 있는 생성자 함수 객체이다. 생성자 함수 객체인 표준 빌트인 객체는 프로토타입 메소드와 정적 메소드를 제공하고 생성자 함수 객체가 아닌 표준 빌트인 객체는 정적 메소드만을 제공한다. 예를 들어 표준 빌트인 객체인 String, Number, Boolean, Function, Array, Date는 생성자 함수로 호출하여 인스턴스를 생성할 수 있다. 생성자 함수인 표준 빌트인 객체가 생성한 인스턴스의 프로토타입은 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체이다. 예를 들어 표준 빌트인 객체인 String을 생성자 함수로서 호출하여 생성한 String 인스턴스의 프로토타입은 String.prototype이다. 123456// String 생성자 함수에 의한 String 객체 생성const strObj = new String('Lee');console.log(typeof strObj); // objectconsole.log(strObj); // String {\"Lee\"}console.log(Object.getPrototypeOf(strObj) === String.prototype); // true 표준 빌트인 객체의 prototype 프로퍼티에 바인딩된 객체는 다양한 기능의 메소드를 제공한다 예를 들어서 Number.prototype이 제공하는 다양한 메소드를 사용가능. 또한 인스턴스 없이도 호출 가능한 정적 메소드도 제공한다. 12345678// Number 생성자 함수에 의한 Number 객체 생성const numObj = new Number(1.5);console.log(typeof numObj); // objectconsole.log(numObj); // Number {1.5}// toFixed는 프로토타입 메소드이다.// 소숫점자리를 반올림하여 문자열로 반환한다.console.log(numObj.toFixed()); // 2 표준 빌트인 객체인 Number는 인스턴스 없이 정적으로 호출할 수 있는 정적 메소드도 제공한다. 123// isInteger는 정적 메소드이다.// 정수(Integer)인지 검사하여 그 결과를 Boolean으로 반환한다.console.log(Number.isInteger(0.5)); // false 3.원시값과 래퍼 객체 원시값은 객체가 아니므로 프로퍼티나 메소드를 가질 수 없음에도 불구하고 원시값인 문자열이 마치 객체처럼 동작한다. 12345const str = 'hello';// 원시 타입인 문자열이 프로퍼티와 메소드를 갖고 있다.console.log(str.length); // 5console.log(str.toUpperCase()); // HELLO 표준 빌트인 객체가 제공하는 프로토타입 메소드를 사용하려면 반드시 인스턴스를 생성하고 인스턴스로 프로토타입 메소드를 호출해야 한다. 그런데 위 예제를 살펴보면 원시값으로 표준 빌트인 객체의 프로토타입 메소드를 호출하면 정상적으로 동작한다. 이는 원시값인 문자열, 숫자, 불리언 값의 경우, 마치 객체처럼 이들 원시값에 대해 마침표 표기법(또는 대괄호 표기법)으로 접근하면 자바스크립트 엔진이 일시적으로 원시값을 연관된 객체로 변환해 주기 때문이다. 즉, 원시값을 객체처럼 사용하면 자바스크립트 엔진은 암묵적으로 연관된 객체를 생성하고 생성된 객체로 프로퍼티에 접근하거나 메소드를 호출하고 다시 원시값으로 되돌린다. 이처럼 문자열, 숫자, 불리언 값에 대해 객체처럼 접근하면 생성되는 임시 객체를 레퍼 객체라 한다. 예를 들어, 문자열에 대해 마침표 표기법으로 접근하면 그 순간 레퍼 객체인 String 생성자 함수의 인스턴스가 생성되고 문자열은 레퍼 객체의 [[StringData]] 내부 슬롯에 할당된다. 12345678const str = 'hi';// 원시 타입인 문자열이 레퍼 객체인 String 인스턴스로 변환된다.console.log(str.length); // 2console.log(str.toUpperCase()); // HI// 레퍼 객체로 프로퍼티 접근이나 메소드 호출한 후, 다시 원시값으로 되돌린다.console.log(typeof str); // string 이때 문자열 레퍼 객체인 String, Number, Boolean, Symbol 생성자 함수의 인스턴스는 String.prototype의 메소드를 상속받아 사용할 수 있다. 그 후, 레퍼 객체의 처리가 종료하면 레퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 되돌리고 레퍼 객체는 가비지 컬렉션의 대상이 된다. 123456789101112131415const str = 'hello';// 래퍼 객체에 프로퍼티 추가str.name = 'Lee';// 이 시점에 str은 위 코드의 래퍼 객체가 아닌 새로운 래퍼 객체를 가리킨다.console.log(str.name); // undefinedconst num = 1.5;// 원시 타입인 숫자가 레퍼 객체인 String 객체로 변환된다.console.log(num.toFixed()); // 2// 레퍼 객체로 프로퍼티 접근이나 메소드 호출한 후, 다시 원시값으로 되돌린다.console.log(typeof num); // number 이처럼 문자열, 숫자, 불리언, 심볼은 암묵적으로 생성되는 레퍼 객체에 의해 마치 객체처럼 사용할 수 있으며 표준 빌트인 객체인 String, Number, Boolean, Symbol의 프로토타입 메소드 또는 프로퍼티를 참조할 수 있다. 따라서 String, Number, Boolean 생성자 함수를 new 연산자와 함께 호출하여 문자열, 숫자, 불리언 인스턴스를 생성할 필요가 없으며 권장하지도 않는다. Symbol은 생성자 함수가 아니므로 이 논의에서는 제외하도록 한다. 즉, 문자열, 숫자, 불리언, 심볼 이외의 원시값은 레퍼 객체를 생성하지 않는다. 원시값 null과 undefined의 래퍼 객체가 없다. 따라서 null과 undefined 값을 객체처럼 사용하면 에러가 발생한다. 4.전역 객체 전역 객체는 코드가 실행되기 이전 단계에 자바스크립트 엔진에 의해 어떤 객체보다도 먼저 생성되는 특수한 객체이며 어떤 객체에도 속하지 않은 최상위 객체이다. 전역 객체는 자바스크립트 환경에 따라 지칭하는 이름이 제각각이다. 브라우저 환경에서는 window(또는 self, this, frames)가 전역 객체를 가리키지만 Node.js 환경에서는 global이 전역 객체를 가리킨다. globalThis 2019년 12월 현재, 전역 객체를 가리키는 식별자를 globalThis로 통일하는 제안이 stage 4에 올라와 있다. globalThis는 크롬 71, 파이어폭스 65, 사파리 12.1, Edge 79, Node.js 12.0.0 이상에 이미 구현되어 있다.전역 객체는 표준 빌트인 객체와 환경에 따른 호스트 객체 그리고 var 키워드로 선언한 전역 변수와 전역 함수를 프로퍼티로 갖는다. 즉, 전역 객체는 계층적 구조 상 어떤 객체에도 속하지 않은 모든 빌트인 객체의 최상위 객체이다.전역 객체가 최상위 객체라는 것은 프로토타입 상속 관계 상에서 최상위 객체라는 의미가 아니고 객체의 계층적 구조 상 표준 빌트인 객체와 호스트 객체를 프로퍼티로 소유한다는 것을 말한다. 전역 객체의 특징은 아래와 같다. 전역 객체는 개발자가 의도적으로 생성할 수 없다. 즉, 전역 객체를 생성할 수 있는 생성자 함수가 제공되지 않는다. 전역 객체의 프로퍼티를 참조할 때 window(또는 global)를 생략할 수 있다. 123456// 문자열 'F'를 16진수로 해석하여 10진수로 변환하여 반환한다.console.log(window.parseInt('F', 16)); // 15// window.parseInt는 parseInt으로 호출할 수 있다.console.log(parseInt('F', 16)); // 15console.log(window.parseInt === parseInt); // true 전역 객체는 Object, String, Number, Boolean, Function, Array, RegExp, Date, Math, Promise와 같은 모든 표준 빌트인 객체를 프로퍼티로 가지고 있다. 자바스크립트 실행 환경(브라우저 환경 또는 Node.js 환경. “3.1 자바스크립트 실행 환경” 참고)에 따라 추가적으로 프로퍼티와 메소드를 갖는다. 브라우저 환경에서는 DOM, BOM, Canvas, XMLHttpRequest, fetch, requestAnimationFrame, SVG, Web Storage, Web Component, Web worker와 같은 클라이언트 사이드 Web API를 호스트 객체로 제공하고 Node.js 환경에서는 Node.js 고유의 API를 호스트 객체로 제공한다. var 키워드로 선언한 전역 변수와 선언하지 않은 변수에 값을 할당한 암묵적 전역(“20.4.3. 암묵적 전역” 참고) 그리고 전역 함수는 전역 객체의 프로퍼티가 된다. 1234567891011// var 키워드로 선언한 전역 변수var foo = 1;console.log(window.foo); // 1// 암묵적 전역. bar는 전역 변수가 아니라 전역 객체의 프로퍼티이다.bar = 2;console.log(window.bar); // 2// 전역 함수function baz() { return 3; }console.log(window.baz()); // 3 let이나 const 키워드로 선언한 전역 변수는 전역 객체의 프로퍼티가 아니다. 즉, window.foo와 같이 접근할 수 없다. let이나 const 키워드로 선언한 전역 변수는 보이지 않는 개념적인 블록(전역 렉시컬 환경의 선언적 환경 레코드, “22. 실행 컨텍스트”에서 살펴볼 것이다.) 내에 존재하게 된다. 12let foo = 123;console.log(window.foo); // undefined 브라우저 환경의 모든 자바스크립트 코드는 하나의 전역 객체 window를 공유한다. 여러 개의 script 태그를 통해 자바스크립트 코드를 분리하여도 하나의 전역 객체 window를 공유하는 것은 변함이 없다. 이는 분리되어 있는 자바스크립트 코드가 하나의 전역을 공유한다는 의미이다. 전역 객체는 몇가지 프로퍼티와 메소드를 가지고 있다. 전역 객체의 프로퍼티와 메소드는 전역 객체를 가리키는 식별자, 즉 window나 global을 생략하여 참조/호출할 수 있으므로 전역 변수와 전역 함수처럼 사용할 수 있다. 4.1 빌트인 전역 프로퍼티 빌트인 전역 프로퍼티(Built-in global property)는 전역 객체의 프로퍼티를 의미한다. 주로 애플리케이션 전역에서 사용하는 값을 제공한다. 4.1.1 Infinity Infinity 프로퍼티는 양/음의 무한대를 나타내는 숫자값 Infinity를 갖는다. 123456789// 전역 프로퍼티는 window를 생략하고 참조할 수 있다.console.log(window.Infinity === Infinity); // true// 양의 무한대console.log(3/0); // Infinity// 음의 무한대console.log(-3/0); // -Infinity// Infinity는 숫자 타입인 값이다.console.log(typeof Infinity); // number 4.1.2 NaN NaN 프로퍼티는 숫자가 아님(Not-a-Number)을 나타내는 숫자값 NaN을 갖는다. NaN 프로퍼티는 Number.NaN 프로퍼티와 같다. 12345console.log(window.NaN); // NaNconsole.log(Number('xyz')); // NaNconsole.log(1 * 'string'); // NaNconsole.log(typeof NaN); // number 4.1.3 undefinedundefined 프로퍼티는 원시 타입 undefined를 값으로 갖는다. 12345console.log(window.undefined); // undefinedvar foo;console.log(foo); // undefinedconsole.log(typeof undefined); // undefined 4.2 빌트인 전역 함수 빌트인 전역 함수(Built-in global function)는 애플리케이션 전역에서 호출할 수 있는 빌트인 함수로서 전역 객체의 메소드이다. 4.2.1 eval문자열 형태로 매개변수에 전달된 코드를 런타임에 동적으로 평가하고 실행하여 결과값을 반환한다. 전달된 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행 후 마지막 결과값을 반환한다. 123456/** * 주어진 코드를 런타임 평가하고 실행하여 결과값을 반환한다. * @param {string} code - 코드를 나타내는 문자열 * @returns {*} 문자열 코드를 평가/실행한 결과값 */eval(code) 1234567891011121314// 표현식인 문console.log(eval('1 + 2;')); // 3// 표현식이 아닌 문console.log(eval('var x = 5;')); // undefined// 변수 x가 선언되었다.console.log(x); // 5// 객체 리터럴은 반드시 괄호로 둘러싼다.var o = eval('({ a: 1 })');console.log(o); // {a: 1}// 함수 리터럴은 반드시 괄호로 둘러싼다.var f = eval('(function() { return 1; })');console.log(f()); // 1 전달된 문자열 코드가 여러 개의 문으로 이루어져 있다면 모든 문을 실행 후 마지막 결과값을 반환한다. 1console.log(eval('1 + 2; 3 + 4;')); // 7 eval 함수는 런타임에 자신이 호출된 기존의 스코프를 동적으로 수정한다. 아래 예제를 살펴보자. 123456789101112var x = 1;function foo() { // eval 함수는 런타임에 foo 함수의 스코프를 동적으로 수정한다. eval('var x = 2;'); console.log(x); // 2}foo();// eval 함수는 자신이 호출된 스코프 외부에 영향을 주지 않는다.console.log(x); // 1 위 예제의 eval 함수는 새로운 변수를 선언하면서 foo 함수의 스코프에 선언된 변수를 동적으로 추가한다. eval 함수가 호출되는 시점에는 이미 foo 함수의 스코프가 존재한다. eval 함수는 기존의 스코프를 동적으로 수정하는 것이다. 그리고 eval 함수에 전달된 코드는 이미 그 위치에 존재하던 코드처럼 동작한다. 즉, eval 함수가 호출된 foo 함수의 스코프에서 실행된다. eval 함수는 런타임에 기존의 스코프를 동적으로 수정할 수 있다. 다시 말해 eval 함수는 렉시컬 스코프를 동적으로 수정할 수 있다. 하지만 성능적인 면에서 손해를 감수해야 한다. eval 함수를 통해 사용자로부터 입력 받은 콘텐츠(untrusted data)를 실행하는 것은 보안에 매우 취약하다. 또한 자바스크립트 엔진에 의해 최적화가 수행되지 않으므로 일반적인 코드 실행에 비해 처리 속도가 느리다. 따라서 eval 함수의 사용은 가급적 금지되어야 한다 4.2.2. isFinite 매개 변수에 전달된 값이 정상적인 유한수인지 검사하여 그 결과를 불리언 타입으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다. 123456789console.log(isFinite(Infinity)); // falseconsole.log(isFinite(NaN)); // falseconsole.log(isFinite('Hello')); // falseconsole.log(isFinite('2005/12/12')); // falseconsole.log(isFinite(0)); // trueconsole.log(isFinite(2e64)); // trueconsole.log(isFinite('10')); // true: '10' → 10console.log(isFinite(null)); // true: null → 0 4.2.3. isNaN 매개변수에 전달된 값이 NaN인지 검사하여 그 결과를 불리런 타입으로 반환한다. 매개변수에 전달된 값이 숫자가 아닌 경우, 숫자로 타입을 변환한 후 검사를 수행한다. 123456789101112131415161718192021222324// 숫자console.log(isNaN(NaN)); // trueconsole.log(isNaN(10)); // false// 문자열console.log(isNaN('blabla')); // true: 'blabla' → NaNconsole.log(isNaN('10')); // false: '10' → 10console.log(isNaN('10.12')); // false: '10.12' → 10.12console.log(isNaN('')); // false: '' → 0console.log(isNaN(' ')); // false: ' ' → 0// 불리언console.log(isNaN(true)); // false: true → 1console.log(isNaN(null)); // false: null → 0// undefinedconsole.log(isNaN(undefined)); // true: undefined → NaN// 객체console.log(isNaN({})); // true: {} → NaN// dateconsole.log(isNaN(new Date())); // false: new Date() → Numberconsole.log(isNaN(new Date().toString())); // true: String → NaN 4.2.4. parseFloat 매개변수에 전달된 문자열을 부동소수점 숫자(floating point number)로 변환하여 반환한다. 123456789console.log(parseFloat('3.14')); // 3.14console.log(parseFloat('10.00')); // 10// 공백으로 구분된 문자열은 첫번째 문자열만 변환한다.console.log(parseFloat('34 45 66')); // 34console.log(parseFloat('40 years')); // 40// 첫번째 문자열을 숫자로 변환할 수 없다면 NaN을 반환한다.console.log(parseFloat('He was 40')); // NaN// 전후 공백은 무시된다.console.log(parseFloat(' 60 ')); // 60 4.2.5. parseInt 매개변수에 전달된 문자열을 정수형 숫자(Integer)로 해석(parsing)하여 반환한다. 반환값은 언제나 10진수이다. 12345678// 주어진 문자열을 10진수 정수로 해석하여 반환한다.console.log(parseInt('10')); // 10console.log(parseInt('10.123')); // 10주어진 변환 대상 값이 문자열이 아니면 문자열로 변환한 후 정수형 숫자로 해석하여 반환한다.console.log(parseInt(10)); // 10console.log(parseInt(10.123)); // 10 2번째 매개변수에는 진법을 나타내는 기수(2 ~ 36)를 지정할 수 있다. 기수를 지정하면 첫번째 매개변수에 전달된 문자열을 해당 기수의 숫자로 해석하여 반환한다. 이때 반환값은 언제나 10진수이다. 기수를 생략하면 첫번째 매개변수에 전달된 문자열을 10진수로 해석하여 반환한다. 12345678// '10'을 10진수로 해석하고 10진수 정수로 그 결과를 반환한다console.log(parseInt('10')); // 10// '10'을 2진수로 해석하고 10진수 정수로 그 결과를 반환한다console.log(parseInt('10', 2)); // 2// '10'을 8진수로 해석하고 10진수 정수로 그 결과를 반환한다console.log(parseInt('10', 8)); // 8// '10'을 16진수로 해석하고 10진수 정수로 그 결과를 반환한다console.log(parseInt('10', 16)); // 16 기수를 지정하여 10진수 숫자를 해당 기수의 문자열로 변환하여 반환하고 싶을 때는 Number.prototype.toString 메소드를 사용한다. 1234567891011const x = 15;// 15을 2진수로 변환하여 그 결과를 문자열로 반환한다.console.log(x.toString(2)); // '1111'// 15을 8진수로 변환하여 그 결과를 문자열로 반환한다.console.log(x.toString(8)); // '17'// 15을 16진수로 변환하여 그 결과를 문자열로 반환한다.console.log(x.toString(16)); // 'f'// 숫자값을 문자열로 변환한다.console.log(x.toString()); // '15' 4.2.6. encodeURI / decodeURI encodeURI 함수는 매개변수로 전달된 URI(Uniform Resource Identifier)를 인코딩한다. URI는 인터넷에 있는 자원을 나타내는 유일한 주소를 말한다. 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다. 1234567// 완전한 URIconst uri = 'http://example.com?name=이웅모&amp;job=programmer&amp;teacher';// encodeURI 함수는 완전한 URI를 전달받아 인코딩하여 이스케이프 처리한다.const enc = encodeURI(uri);console.log(enc);// http://example.com?name=%EC%9D%B4%EC%9B%85%EB%AA%A8&amp;job=programmer&amp;teacher decodeURI 함수는 매개변수로 전달된 인코딩된 URI을 전달받아 이스케이프 처리되기 이전으로 디코딩한다. 1234567891011const uri = 'http://example.com?name=이웅모&amp;job=programmer&amp;teacher';// encodeURI 함수는 완전한 URI를 전달받아 인코딩하여 이스케이프 처리한다.const enc = encodeURI(uri);console.log(enc);// http://example.com?name=%EC%9D%B4%EC%9B%85%EB%AA%A8&amp;job=programmer&amp;teacher// decodeURI 함수는 인코딩된 완전한 URI를 전달받아 이스케이프 처리되기 이전으로 디코딩한다.const dec = decodeURI(enc);console.log(dec);// http://example.com?name=이웅모&amp;job=programmer&amp;teacher 4.2.7. encodeURIComponent / decodeURIComponent encodeURIComponent 함수은 매개변수로 전달된 URI(Uniform Resource Identifier) 구성 요소(component)를 인코딩한다. 여기서 인코딩이란 URI의 문자들을 이스케이프 처리하는 것을 의미한다. 단, 알파벳, 0~9의 숫자, - _ . ! ~ * ‘ ( ) 문자는 이스케이프 처리에서 제외된다. decodeURIComponent 함수는 매개변수로 전달된 URI 구성 요소를 디코딩한다. 12345678910111213141516171819202122// URI의 쿼리 파라미터const uriComp = 'name=이웅모&amp;job=programmer&amp;teacher';// encodeURIComponent 함수는 매개변수로 전달된 문자열을 URI의 구성요소인 쿼리 파라미터의 일부 간주한다.// 따라서 쿼리 파라미터 구분자로 사용되는 =, ?, &amp;를 인코딩한다.let enc = encodeURIComponent(uriComp);console.log(enc);// name%3D%EC%9D%B4%EC%9B%85%EB%AA%A8%26job%3Dprogrammer%26teacherlet dec = decodeURIComponent(enc);console.log(dec);// 이웅모&amp;job=programmer&amp;teacher// encodeURI 함수는 매개변수로 전달된 문자열을 완전한 URI로 간주한다.// 따라서 쿼리 파라미터 구분자로 사용되는 =, ?, &amp;를 인코딩하지 않는다.enc = encodeURI(uriComp);console.log(enc);// name=%EC%9D%B4%EC%9B%85%EB%AA%A8&amp;job=programmer&amp;teacherdec = decodeURI(enc);console.log(dec);// name=이웅모&amp;job=programmer&amp;teacher 4.3. 암묵적 전역 12345678910var x = 10; // 전역 변수function foo () { y = 20; // 선언하지 않은 식별자에 값을 할당 // 식별자를 선언하지 않아서 암묵적 전역상태로 변환}foo();// 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.console.log(x + y); // 30 선언하지 않은 식별자에 값을 할당하면 전역 객체의 프로퍼티가 되기 때문이다. 자바스크립트 엔진은 y = 20 을 window.y = 20 으로 해석하여 전역 객체에 프로퍼티를 동적 생성한다. 결국 y는 전역 객체의 프로퍼티가 되어 마치 전역 변수처럼 동작한다. 이러한 현상을 암묵적 전역(implicit global)이라 한다. 하지만 y는 변수 선언없이 단지 전역 객체의 프로퍼티로 추가되었을 뿐이다. 따라서 y는 변수가 아니다. 따라서 변수가 아닌 y는 변수 호이스팅이 발생하지 않는다. 1234567891011121314// 전역 변수 x는 호이스팅이 발생한다.console.log(x); // undefined// 전역 변수가 아니라 단지 전역 객체의 프로퍼티인 y는 호이스팅이 발생하지 않는다.console.log(y); // ReferenceError: y is not definedvar x = 10; // 전역 변수function foo () { y = 20; // 선언하지 않은 식별자에 값을 할당}foo();// 선언하지 않은 식별자 y를 전역에서 참조할 수 있다.console.log(x + y); // 30 또한 변수가 아니라 단지 프로퍼티인 y는 delete 연산자로 삭제할 수 있다. 전역 변수는 프로퍼티이지만 delete 연산자로 삭제할 수 없다. 123456789101112131415161718var x = 10; // 전역 변수function foo () { // 선언하지 않은 변수 y = 20; console.log(x + y);}foo(); // 30console.log(window.x); // 10console.log(window.y); // 20delete x; // 전역 변수는 삭제되지 않는다.delete y; // 프로퍼티는 삭제된다.console.log(window.x); // 10console.log(window.y); // undefined","link":"/2020/03/%ED%91%9C%EC%A4%80%EB%B9%8C%ED%8A%B8%EC%9D%B8%EA%B0%9D%EC%B2%B4/"},{"title":"함수와 일급 객체 | javaScript","text":"1. 일급 객체 아래와 같은 조건을 만족하는 객체를 일급 객체(first-class object)라 한다. 무명의 리터럴로 생성할 수 있다. 즉, 런타임에 생성이 가능하다. 변수나 자료구조(객체, 배열 등)에 저장할 수 있다. 함수의 매개 변수에게 전달할 수 있다. 함수의 결괏값으로 반환할 수 있다. 자바스크립트의 함수는 아래 예제와 같이 위의 조건을 모두 만족하므로 일급 객체이다. 123456789101112131415161718192021222324252627282930313233341. 함수는 무명의 리터럴로 생성할 수 있다.2. 함수는 변수에 저장할 수 있다.// 런타임(할당 단계)에 함수 리터럴이 평가되어 함수 객체가 생성되고 변수에 할당된다.const increase = function (num) { return ++num};const decrease = function (num) { return --num;};// 2. 함수는 객체에 저장할 수 있다.const predicates = { increase, decrease };// 3. 함수의 매개 변수에게 전달할 수 있다.// 4. 함수의 반환값으로 사용할 수 있다.function makeCounter(predicate) { let num = 0; return function () { num = predicate(num); return num; };}// 3. 함수는 매개 변수에게 함수를 전달할 수 있다.const increaser = makeCounter(predicates.increase);console.log(increaser()); // 1console.log(increaser()); // 2// 3. 함수는 매개 변수에게 함수를 전달할 수 있다.const decreaser = makeCounter(predicates.decrease);console.log(decreaser()); // -1console.log(decreaser()); // -2 함수가 일급 객체라는 것은 함수를 객체와 동일하게 사용할 수 있다는 의미다. 객체는 값이므로 함수는 값과 동일하게 취급할 수 있다. 따라서 함수는 값을 사용할 수 있는 곳(변수 할당문, 객체의 프로퍼티, 배열의 요소, 함수 호출의 인수, 함수 반환문)이라면 어디서든지 리터럴로 정의할 수 있으며 런타임(runtime)에 함수 객체로 평가된다. 함수 객체는 몇 가지 고유한 프로퍼티를 갖는 것을 제외하면 일반 객체와 동일하다. 따라서 함수 객체는 일반 객체와 같이 함수의 매개 변수에 전달할 수 있으며 함수의 결과값으로 반환할 수도 있다. 이는 함수형 프로그래밍을 가능케하는 자바스크립트의 장점 중에 하나이다. 함수형 프로그래밍 함수형 프로그래밍은 순수 함수(Pure function)와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과(side-effect)를 최소화하여 불변성(Immutability)을 지향하는 프로그래밍 패러다임이다. 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하며, 변수 사용을 억제하거나 생명주기를 최소화하여 상태 변경을 피해 오류를 최소화하는 것을 목표로 한다. 조건문이나 반복문은 로직의 흐름을 이해하기 어렵게 하여 가독성을 해치고, 변수의 값은 누군가에 의해 언제든지 변경될 수 있어 오류 발생의 근본적 원인이 될 수 있기 때문이다. 함수형 프로그래밍 패러다임에서 매개 변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수를 고차 함수(Higher-Order Function, HOF)라 한다. 고차 함수에 대해서는 “배열”에서 자세히 살펴볼 것이다.함수는 객체이지만 일반 객체와 차이가 있다. 일반 객체는 호출을 못하지만 함수객체는 호출이 가능하다. 2. 함수 객체의 프로퍼티함수는 객체이다. 따라서 함수도 프로퍼티를 가질 수 있다. 브라우저 콘솔에서 console.dir 메소드를 사용하여 함수 객체의 내부를 들여다 보자. 12345function square(number) { return number * number;}console.dir(square); 일반 객체에는 없는 arguments, caller, length, name, prototype 프로퍼티가 함수 객체에는 존재한다. 이 프로퍼티 들의 프로퍼티 어트리뷰트를 object,getOwnpropertyDescriptor 메소드로 확인해 보면 아래와 같다. 1234567891011121314151617181920212223242526272829303132function square(number) { return number * numer;}// arguments는 square 함수 객체의 데이터 프로퍼티이다.Object.getOwnpropertyDescriptor(square, 'arguments');// {value: null, writable: false, enumerable: false, configurable: false}// caller는 square 함수 객체의 데이터 프로퍼티이다.Object.getOwnpropertyDescriptor(square, 'caller');// {value: null, writable: flase, enumarable: false, configurable: false}// length는 square 함수 객체의 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(square, 'length');// {value: 1, writable: false, enumerable: false, configurable: true}// name은 square 함수 객체의 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(square, 'name');// {value: \"square\", writable: false, enumerable: false, configurable: true}// prototype은 square 함수 객체의 데이터 프로퍼티이다.Object.getOwnPropertyDescriptor(square, 'prototype');// {value: {…}, writable: true, enumerable: false, configurable: false}// __proto__는 square 함수 객체의 프로퍼티가 아니다.Object.getOwnPropertyDescriptor(square, '__proto__');// undefined// __proto__는 Object.prototype 객체의 접근자 프로퍼티이다.// square 함수 객체는 Object.prototype 객체로부터 __proto__ 접근자 프로퍼티를 상속받는다.Object.getOwnPropertyDescriptor(Object.prototype, '__proto__');// {get: ƒ, set: ƒ, enumerable: false, configurable: true} arguments, caller, length, name, prototype 프로퍼티는 모두 함수 객체의 데이터 프로퍼티이다.하지만 proto는 접근자 프로퍼티이며 함수 객체의 프로퍼티가 아닌 Object.prototype 객체의 프로퍼티를 상속받은 것을 알 수 있다. 2.1. arguments 프로퍼티함수 객체의 arguments 프로퍼티 값은 arguments 객체이다. arguments 객체는 함수 호출 시 전달된 인수(arguemnt)들의 정보를 담고 있는 순회 가능한(iterable)유사 배열 객체이며 함수 내부에서 지역 변수처럼 사용된다. 즉, 함수 외부에서는 사용할 수 없다. 자바스크립트는 함수 호출 시 함수 정의에 따라 인수를 전달하지 않아도 에러가 발생하지 않는다. 123456789function multiply(x, y) { console.log(arguments); return x * y;}console.log(multiply()); // NaNconsole.log(multiply(1)); // NaNconsole.log(multiply(1, 2)); // 2console.log(multiply(1, 2, 3)); // 2 함수를 정의할 떄 선언한 매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 즉, 함수가 호출되면 함수 몸체 내에서 암묵적으로 매개변수가 선언되고 undefined로 초기화된 이후 인수가 할당된다. 선언된 매개변수의 개수보다 인수를 적게 전달했을 경우 인수가 전달되지 않은 매개변수는 undefined로 초기화된 상태를 유지한다.매개변수의 개수보다 인수를 더 많이 전달한 경우(multiply(1, 2, 3)) 초과된 인수는 무시된다. 그렇다고 초과된 인수가 그냥 버려지는 것은 아니다.모든 인수는 암묵적으로 arguments 객체의 프로퍼티로 보관된다. arguments 객체는 인수를 프로퍼티 값으로 소유하며 프로퍼티 키는 인수의 순서를 나타낸다. arguments객체의 callee 프로퍼티는 호출되어 arguments 객체를 생성한 함수, 즉 함수 자신을 가리키고 arguments 객체의 length 프로퍼티는 인수의 개수를 가리킨다. 선언된 매개변수의 개수와 함수 호출 시에 전달하는 인수의 개수를 확인하지 않은 자바스크립트의 특성때문에 런타임 시에 호출된 함수의 인자 개수를 확인하고 이에 따라 함수의 동작을 달리 정의할 필요가 있을 수 있다. 이때 유용하게 사용되는 것이 arguments 객체이다. arguments 객체는 매개변수 개수를 확정할 수 없는 가변 인자 함수를 구현할 때 유용하게 사용된다. 1234567891011121314function sum() { let res = 0; // arguments 객체는 length 프로퍼티가 있는 유사 배열 객체이므로 for 문으로 순회할 수 있다. for (let i = 0; i &lt; arguments.length; i++) { res += arguments[i]; } return res;}console.log(sum()); // 0console.log(sum(1, 2)); // 3console.log(sum(1, 2, 3)); // 6 arguments 객체는 배열의 형태로 인자 정보를 담고 있지만 실제 배열이 아닌 유사배열객체(array-like object)이다. 유사배열객체란 length 프로퍼티를 가진 객체로 for 문으로 순회할 수 있는 객체를 말한다. 유사 배열 객체는 배열이 아니므로 메소드를 사용할 경우 에러가 발생하게 된다.따라서 배열 메소드를 사용하려면 Function.prototype.call, Function.prototype.apply를 사용해 간접 호출해야 하는 번거로움이 있다. 간접 호출과 배열에 대해 아직 살펴보지 않았으므로 지금은 참고로만 알아둡시다~ 123456789function sum() { const array = Array.prototype.slice.call(arguments); return array.reduce(function(pre, cur) { return pre + cur; }, 0);}console.log(sum(1, 2)); // 3console.log(sum(1, 2, 3, 4, 5)); // 15 이러한 번거로움을 해결하기 위해 ES6에서는 Rest 파라미터를 도입했다. 1234567// ES6 Rest parameterfunction sum(...args) { return args.reduce((pre, cur) =&gt; pre + cur, 0);}console.log(sum(1, 2)); // 3console.log(sum(1, 2, 3, 4, 5)); // 15 2.2. length 프로퍼티함수 객체의 length 프로퍼티는 함수 정의 시 선언한 매개변수의 개수를 가리킨다. 12345678910111213function foo() { console.log(foo.length); // 0}function bar(x) { return x;}console.log(bar.length); // 1function baz(x, y, z) { return x * y * z;}console.log(baz.length); // 3 arguments 객체의 length 프로퍼티와 함수 객체의 length 프로퍼티의 값은 다를 수 있으므로 주의하여야 한다.arguments 객체의 length 프로퍼티는 인자(argument)의 개수를 가리키고, 함수 객체의 length 프로퍼티는 매개변수(parameter)의 개수를 가리킨다. 2.3. name 프로퍼티함수 객체의 name 프로퍼티는 함수 이름을 나타낸다.name 프로퍼티는 ES5와 ES6에서 동작을 달리 하므로 주의하기 바란다. 익명 함수 표현식의 경우, ES5에서 name 프로퍼티는 빈 문자열을 값으로 갖는다. 하지만 ES6에서는 함수 객체를 가리키는 변수 이름을 값으로 갖는다. 12345678910111213// 기명 함수 표현식var namedFunc = function foo () {};console.log(namedFunc.name); // foo// 익명 함수 표현식var anoymusFunc = function() {};// ES5: name 프로퍼티는 빈 문자열을 값으로 갖는다.// ES6: name 프로퍼티는 함수 객체를 가리키는 변수 이름을 값으로 갖는다.console.log(anonymousFunc.name); // anonymousFunc// 함수 선언문(Function declaration)function bar() {}console.log(bar.name); // bar 2.5. proto 접근자 프로퍼티모든 객체는[[prototype]]이라는 내부 슬롯을 갖는다. [[prototype]]내부 슬롯은 객체 지향 프로그래밍의 상속을 구현하는 프로토타입 객체를 가리킨다. proto프로퍼티는 [[Prototype]]내부 슬롯이 가리키는 프로토타입 객체에 접근하기 위해 사용하는 접근자 프로퍼티이다. 내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다. 123456789const obj = { a: 1 };// 객체 리터럴 방식으로 생성한 객체의 프로토타입 객체는 Object.prototype이다.console.log(obj.__proto__ === Object.prototype); // true// 객체 리터럴 방식으로 생성한 객체는 프로토타입 객체인 Object.prototype의 프로퍼티를 상속받는다.// hasOwnProperty 메소드는 Object.prototype의 메소드이다.console.log(obj.hasOwnProperty('a')); // trueconsole.log(obj.hasOwnProperty('__proto__')); // false 2.6. prototype 프로퍼티prototype 프로퍼티는 함수 객체만이 소유하는 프로퍼티이다. 일반 객체에는 prototype 프로퍼티가 없다. 12345// 함수 객체는 prototype 프로퍼티를 소유한다.console.log((function() {}).hasOwnproperty('prototype')); // true// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.console.log(({}).hasOwnProperty('prototype')); // false prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로 사용될 때, 생성자 함수가 생성할 인스턴스의 프로토타입 객체를 가리킨다.","link":"/2020/03/%ED%95%A8%EC%88%98%EC%99%80%20%EC%9D%BC%EA%B8%89%20%EA%B0%9D%EC%B2%B4/"},{"title":"프로토타입 | javaScript","text":"자바스크립트는 명령형, 함수형, 프로토타입 기반 객체지향 프로그래밍을 지원하는 멀티 패러다임 프로그래밍 언어다. 자바스크립트는 객체 기반의 프로그래밍 언어이며 자바스크립트를 이루고 있는 거의 “모든 것”이 객체이다. 객체지향 프로그래밍에 대해 간단히 살펴보자. 1.객체지향 프로그래밍객체지향 프로그래밍(OOP)은 객체(object)들의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임을 말한다. 프로퍼티의 속성을 통해 여러 개의 값을 하나의 단위로 구성한 복합적인 자료구조를 객체라 하며 객체지향 프로그래밍은 독립적인 객체의 집합으로 프로그램을 표현하려는 프로그래밍 패러다임이다. 객체지향 프로그래밍은 객체의 상태를 나타내는 데이터와 상태 데이터를 조작할 수 있는 동작을 하나의 논리적인 단위로 묶은 복합적인 자료구조라고 할 수 있다.객체의 상태 데이터를 프로퍼티, 동작을 메소드라 부른다. 각각의 객체는 고유의 기능을 갖는 독립적인 부품으로 볼 수 있지만 자신의 고유한 기능을 수행하면서 다른 객체와 관계성을 갖을 수 있다. 다른 객체와 메세지를 주고 받거나 데이터를 처리할 수도 있다. 또는 다른 객체의 상태 데이터나 동작을 상속받아 사용하기도 한다. 2.상속과 프로토타입상속은 어떤 객체의 프로퍼티와 메소드를 다른 객체가 상속받아 그대로 사용할 수 있는 것을 말한다.자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거한다. 생성자 함수에 의해 생성된 모든 인스턴스가 동일한 메소드를 중복 소유하는 것은 메모리를 불필요하게 낭비한다. 또한 인스턴스를 생성할 때마다 메소드를 생성하므로 퍼포먼스에도 악영향을 준다. 자바스크립트는 프로토타입을 기반으로 상속을 구현한다. 12345678910111213141516171819202122// 생성자 함수function Circle(radius) { this.radius = radius;}// Circle 생성자 함수가 생성한 모든 인스턴스가 공유할 수 있도록 getArea 메소드를 프로토타입에 추가한다.// 프로토타입은 Circle 생성자 함수의 prototype 프로퍼티에 바인딩되어 있다.Circle.prototype.getArea = function () { return Math.PI * Math.pow(this.radius, 2);};// 인스턴스 생성const circle1 = new Circle(1);const circle2 = new Circle(2);// Circle 생성자 함수가 생성한 모든 인스턴스는 부모 객체의 역할을 하는// 프로토타입 Circle.prototype로부터 getArea 메소드를 상속받는다.// 즉, Circle 생성자 함수가 생성하는 모든 인스턴스는 하나의 getArea 메소드를 공유한다.console.log(circle1.getArea === circle2.getArea); // trueconsole.log(circle1.getArea()); // 3.141592653589793console.log(circle2.getArea()); // 12.566370614359172 Circle 생성자 함수가 생성한 모든 인스턴스는 자신의 프로토타입 즉, 상위 객체 역할을 하는 Circle.prototype의 모든 프로퍼티와 메소드를 상속 받는다. getArea 메소드는 단 하나만 생성되어 프로토타입인 Circle.prototype의 메소드로 할당되어 있다. 따라서 Circle 생성자 함수가 생성하는 모든 인스턴스는 getArea 메소드를 상속받아 사용할 수 있다. 즉, 자신의 상태를 나타내는 radius 프로퍼티만을 개별적으로 소유하고 내용이 동일한 메소드는 상속을 통해 공유하여 사용하는 것이다. 이처럼 상속은 코드의 재사용과 퍼포먼스 그리고 메모리면에서 매우 유용하다. 3.프로토타입 객체프로포타입 객체란 객체지향 프로그래밍의 핵심인 객체간 상속을 구현하기 위해 사용된다. 프로토타입은 어떤 객체의 상위 객체의 역할을 하는 객체로서 다른 객체에 공유 프로퍼티를 제공한다. 프로토타입을 상속받은 하위 객체는 상위 객체의 프로퍼티를 자신의 프로퍼티처럼 자유롭게 사용할 수 있다. 모든 객체는 [[Prototype]]이라는 내부 슬롯을 가지며 이 내부 슬롯의 값은 프로토타입의 참조이다. [[Prototype]]에 저장되는 프로토타입은 객체 생성 방식에 의해 결정된다. 즉, 객체가 생성될 때 객체 생성 방식에 따라 프로토타입이 결정되고 [[Prototype]]에 저장된다. 예를 들어, 객체 리터럴에 의해 생성된 객체의 프로토타입은 Object.prototype이고 생성자 함수에 의해 생성된 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 모든 객체는 하나의 프로토타입을 갖는다. 모든 프로토타입은 생성자 함수와 연결되어 있다. 즉, 객체와 프로토타입과 생성자 함수는 서로 연결되어 있다. [[Prototype]] 내부 슬롯에는 직접 접근할 수 없지만, 위 그림처럼 객체는 proto 접근자 프로퍼티를 통해 자신의 프로토타입에 간접적으로 접근할 수 있다.프로토타입은 자신의 constructor 프로퍼티를 통해 생성자 함수에 접근할 수 있고, 생성자 함수는 자신의 prototype 프로퍼티를 통해 프로토타입에 접근할 수 있다. 3.1. proto 접근자 프로퍼티**모든 객체는 proto 접근자 프로퍼티를 통해 자신의 프로토타입에 접근 할 수 있다. 1const person = { name: 'Lee' }; 모든 객체는 프로토타입을 가리키는 [[Prototype]] 내부 슬롯에 접근하기 위해 proto 접근자 프로퍼티를 사용할 수 있다. proto 는 접근자 프로퍼티이다. 내부 슬롯은 프로퍼티가 아니다. 따라서 내부 슬롯에는 직접 접근할 수 없고 간접적인 접근 방법을 제공하는 경우에 한하여 접근할 수 있다. Object.prototype의 프로퍼티인 proto 접근자 프로퍼티는 getter/setter 함수라고 부르는 접근자 함수를 통해 [[Prototype]] 내부 슬롯의 값, 즉 프로토타입을 취득하거나 할당한다. proto 접근자 프로퍼티를 통해 프로토타입에 접근하면 내부적으로 proto 접근자 프로퍼티의 getter 함수인 get proto가 호출된다. proto 접근자 프로퍼티를 통해 새로운 프로토타입을 할당하면 proto 접근자 프로퍼티의 setter 함수인 set proto가 호출된다. 123456789const obj = {};const parent = { x: 1 };// getter 함수인 get __proto__가 호출되어 obj 객체의 프로토타입을 취득obj.__proto__;// setter함수인 set __proto__가 호출되어 obj 객체의 프로토타입을 교체obj.__proto__ = parent;console.log(obj.x); // 1 proto접근자 프로퍼티는 상속을 통해 사용된다. proto 접근자 프로퍼티는 객체가 직접 소유하는 프로퍼티가 아니라 Object.prototype의 프로퍼티이다. 모든 객체는 상속을 통해 Object.prototype.proto 접근자 프로퍼티를 사용할 수 있다. 1234567891011const person = { name: 'Lee' };// person 객체는 __proto__ 프로퍼티를 소유하지 않는다.console.log(person.hasOwnProperty('__proto__')); // false// __proto__ 프로퍼티는 모든 객체의 프로토타입 객체인 Object.prototype의 접근자 프로퍼티이다.console.log(Object.getOwnPropertyDescriptor(Object.prototype, '__proto__'));// {get: ƒ, set: ƒ, enumerable: false, configurable: true}// 모든 객체는 Object.prototype의 접근자 프로퍼티 __proto__를 상속받아 사용할 수 있다.console.log({}.__proto__ === Object.prototype); // true proto접근자 프로퍼티는 상속을 통해 사용된다. [[Prototype]] 내부 슬롯의 값, 즉 프로토타입에 접근하기 위해 접근자 프로퍼티를 사용하는 이유는 상호 참조에 의해 프로토타입 체인이 생성되는 것을 방지하기 위함이다. 아래 예제를 살펴보자. 1234567const parent = {};const child = {};// child의 프로토타입을 parent로 지정child.__proto__ = parent;// parent의 프로토타입을 child로 설정parent.__proto__ = child; // TypeError: Cyclic __proto__ value 위 예제는 parent 객체를 child 객체의 프로토타입으로 지정한 후, child 객체를 parent 객체의 프로토타입으로 지정하였다. 이러한 코드가 에러없이 정상적으로 처리되면 서로가 자신의 프로토타입이 되는 비정상적인 프로토타입 체인이 만들어 지기 때문에 proto 접근자 프로퍼티는 에러를 발생시킨다. 프로토타입 체인은 단방향 링크드 리스트로 구현되어야 한다. 즉, 프로퍼티 검색 방향이 한쪽 방향으로만 흘러가야 한다. 하지만 위 그림과 같이 순환 참조(circular reference)적인 프로토타입 체인이 만들어지면 프로토타입 체인 종점이 존재하지 않기 때문에 프로토타입 체인에서 프로퍼티를 검색할 때 무한 루프에 빠진다. proto 접근자 프로퍼티를 코드 내에서 직접 사용하는 것은 비추천이다. 코드 내에서 proto를 직접 사용하는 것은 추천하지 않는다. 모든 객체가 proto 접근자 프로퍼티를 사용할 수 있는 것은 아니기 때문이다. 1234567// obj는 프로토타입 체인의 종점이다. 따라서 Object.__proto__를 상속받을 수 없다.const obj = Object.create(null);// obj는 Object.__proto__를 상속받을 수 없다.console.log(obj.__proto__); // undefined// 따라서 Object.getPrototypeOf 메소드를 사용하는 편이 좋다.console.log(Object.getPrototypeOf(obj)); // null 따라서 proto 접근자 프로퍼티 대신 프로토타입의 참조를 취득할 경우는 Object.getPrototypeOf 메소드를, 프로토타입을 교체하는 경우는 Object.setPrototypeOf 메소드를 사용하는 것을 권장한다. 123456789const obj = {};const parent = { x: 1 };// obj 객체의 프로토타입을 취득Object.getPrototypeOf(obj); // obj.__proto__;// obj 객체의 프로토타입을 교체Object.setPrototypeOf(obj, parent); // obj.__proto__ = parent;console.log(obj.x); // 1 Object.getPrototypeOf 메소드는 ES5에서 도입된 메소드이며 IE9 이상을 지원한다. Object.setPrototypeOf 메소드는 ES6에서 도입된 메소드이며 IE11 이상을 지원한다. 3.2. 함수 객체의 prototype 프로퍼티함수 객체는 proto 접근자 프로퍼티 이외에 prototype 프로퍼티도 소유한다. 함수 객체의 prototype 프로퍼티는 생성자 함수가 생성할 인스턴스의 프로토타입을 가리킨다. 12345// 함수 객체는 prototype 프로퍼티를 소유한다.console.log((function () {}).hasOwnProperty('prototype')); // true// 일반 객체는 prototype 프로퍼티를 소유하지 않는다.console.log({}.hasOwnProperty('prototype')); // false prototype 프로퍼티는 함수가 객체를 생성하는 생성자 함수로서 사용될 때, 생성자 함수가 생성할 객체(인스턴스)의 프로토타입을 가리킨다. 생성자 함수로서 호출할 수 없는 함수, 즉 함수의 종류가 Arrow, Method인 함수(“16.2.4 constructor와 non-constructor의 구분” 참고)인 non-constructor는 프로토타입이 생성되지 않으며 prototype 프로퍼티도 소유하지 않는다. 123456789101112131415161718192021// 화살표 함수는 non-constructor이다.const Person = name =&gt; { this.name = name;};// non-constructor는 프로토타입이 생성되지 않는다.console.log(Person.prototype); // undefined// non-constructor는 prototype 프로퍼티도 소유하지 않는다.console.log(Person.hasOwnProperty('prototype')); // false// ES6의 메소드 축약 표현으로 정의한 메소드는 non-constructor이다.const obj = { foo() {}};// non-constructor는 프로토타입이 생성되지 않는다.console.log(obj.foo.prototype); // undefined// non-constructor는 prototype 프로퍼티도 소유하지 않는다.console.log(obj.foo.hasOwnProperty('prototype')); // false 생성자 함수가 아닌 일반 함수도 prototype 프로퍼티를 소유하지만 객체를 생성하지 않는 일반 함수의 prototype 프로퍼티는 아무런 의미가 없다. 123456789101112// 생성자 함수function Person(name) { this.name = name;}const me = new Person('Lee');// Person.prototype: Person 생성자 함수는 prototype 프로퍼티를 통해// 자신이 생성할 인스턴스(이 경우에는 me)의 프로토타입을 할당// me.__proto__: 객체 me의 __proto__ 접근자 프로퍼티를 통해 자신의 프로토타입에 접근// 결국 Person.prototype와 me.__proto__는 결국 동일한 프로토타입을 가리킨다.console.log(Person.prototype === me.__proto__); // true 3.3. 프로토타입의 constructor 프로퍼티와 생성자 함수모든 프로토타입은 constructor 프로퍼티를 갖는다. 이 constructor 프로퍼티는 prototype 프로퍼티로 자신을 참조하고 있는 생성자 함수를 가리킨다. 이 연결은 생성자 함수가 생성될 때, 즉 함수 객체가 생성될 때 이루어진다. 아래 예제를 살펴보자. me 객체는 프로토타입의 contructor 프로퍼티를 통해 생성자 함수와 연결된다. me 객체에는 constructor 프로퍼티가 없지만 me 객체의 프로토타입인 Person.prototye에 constructor 프로퍼티가 있다. me 객체는 프로토타입인 Person.prototye에 constructor 프로퍼티를 상속받아 사용할 수 있다. 4. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입위에서 살펴본 바와 같이, 생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다. 이때 생성자 함수는 인스턴스를 생성한 생성자 함수이다. 123456789101112// obj 객체를 생성한 생성자 함수는 Object이다.const obj = new Object();// add 함수 객체를 생성한 생성자 함수는 Function이다.const add = new Function('a', 'b', 'return a + b');// 생성자 함수function Person(name) { this.name = name;}// me 객체를 생성한 생성자 함수는 Person이다.const me = new Person('Lee'); 프로토타입은 생성자 함수와 더불어 생성되며 prototype, constructor 프로퍼터에 의해 연결되어 있기 때문이다. 다시 말해, 프로토타입과 생성자 함수는 단독으로 존재할 수 없고 언제나 쌍(pair)으로 존재하기 때문이다. 리터럴 표기법(객체 리터럴, 함수 리터럴, 배열 리터럴, 정규 표현식 리터럴 등)에 의해 생성된 객체는 생성자 함수에 의해 생성된 객체는 아니다. 하지만 큰 틀에서 생각해 보면 리터럴 표기법으로 생성한 객체도 생성자 함수로 생성한 객체와 본질적인 면에서 큰 차이는 없다. 객체 리터럴에 의해 생성한 객체와 Object 생성자 함수에 의해 생성한 객체는 생성 과정에 차이는 있지만 결국 객체로서 동일한 특성을 갖는다. 함수 리터럴에 의해 생성한 함수와 Function 생성자 함수에 의해 생성한 함수는 생성 과정과 스코프, 클로저 등의 차이가 있지만 결국 함수로서 동일한 특성을 갖는다. 프로토타입의 constructor 프로퍼티로 연결되어 있는 생성자 함수를 리터럴 표기법으로 생성한 객체를 생성한 생성자 함수로 생각해도 크게 무리는 없다. 리터럴 표기법에 의해 생성된 객체의 생성자 함수와 프로토타입은 아래와 같다. 리터럴 표기법 생성자 함수 프로토타입 객체 리터럴 Object Object.prototype 함수 리터럴 Function Function.prototype 배열 리터럴 Array Array.prototype 정규 표현식 리터럴 RegExp RegExp.prototype 5.프로토타입의 생성 시점리터럴 표기법에 의해 생성된 객체도 생성자 함수와 연결되는 것을 살펴보았다. 객체는 리터럴 표기법 또는 생성자 함수에 의해 생성되므로 결국 모든 객체는 생성자 함수와 연결되어 있다. 생성자 함수는 사용자가 직접 정의한 사용자 정의 생성자 함수와 자바스크립트가 기본 제공하는 빌트인 생성자 함수로 구분할 수 있다. 프로토타입은 생성자 함수가 생성되는 시점에 더불어 생성된다. 5.1. 사용자 정의 생성자 함수와 프로토타입 생성 시점생성자 함수로서 호출할 수 있는 함수, 즉 constructor는 함수 정의가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다. 1234567// 함수 정의(constructor)가 평가되어 함수 객체를 생성하는 시점에 프로토타입도 더불어 생성된다.console.log(Person.prototype); // {constructor: ƒ}// 생성자 함수function Person(name) { this.name = name;} 생성자 함수로서 호출할 수 없는 함수, 즉 non-constructor는 프로토타입이 생성되지 않는다. 1234567// 화살표 함수는 non-constructor이다.const Person = name =&gt; { this.name = name;};// non-constructor는 프로토타입이 생성되지 않는다.console.log(Person.prototype); // undefined 함수 선언문은 다른 코드가 실행되기 이전에 자바스크립트 엔진에 의해 먼저 실행된다. 따라서 함수 선언문으로 정의된 Person 생성자 함수는 어떤 코드보다 먼저 평가되어 함수 객체가 된다. 이때 프로토타입도 더불어 생성된다. 생성된 프로토타입은 Person 생성자 함수의 prototype 프로퍼티에 바인딩된다.Person 생성자 함수와 더불어 생성된 프로토타입의 내부를 살펴보자. 생성된 프로토타입은 constructor 프로퍼티만을 갖는 객체이다. 프로토타입도 객체이고 모든 객체는 프로토타입을 갖으므로 프로토타입도 자신의 프로토타입을 갖는다. 생성된 프로토타입의 프로토타입은 Object.prototype이다. 5.2. 빌트인 생성자 함수와 프로토타입 생성 시점Object, String, Number, Function, Array, RegExp, Date, Promise 등과 같은 빌트인 생성자 함수도 일반 함수와 마찬가지로 빌트인 생성자 함수가 생성되는 시점에 프로토타입이 생성된다. 모든 빌트인 생성자 함수는 전역 객체가 생성되는 시점에 생성된다. 전역 객체는 누구보다도 먼저 생성된다. 이때 빌트인 생성자 함수와 더불어 프로토타입이 생성된다. 생성된 프로토타입은 빌트인 생성자 함수의 prototype 프로퍼티에 바인딩된다. 123// 전역 객체 window는 브라우저에 종속적이므로 아래 코드는 브라우저 혼경에서 실행해야 한다.// 빌트인 객체인 Object는 전역 객체 window의 프로퍼티이다.window.Object === Object // true 객체가 생성되기 이전에 생성자 함수와 프로토타입은 이미 객체화되어 존재하고 있다. 이후 생성자 함수 또는 리터럴 표기법으로 객체를 생성하면 프로토타입은 생성된 객체의 [[prototype]] 내부 슬롯에 할당된다. 이로써 생성된 객체는 프로토타입을 상속받는다. 6.객체 생성 방식과 프로토타입의 결정 객체 리터럴 Object 생성자 함수 생성자 함수 Object.create 메소드 클래스 (ES6) 이와 같이 다양한 방식으로 생성된 모든 객체는 각각의 방식 마다 세부적인 객체 생성 방식의 차이는 있으나 추상 연산 ObjectCreate에 의해 생성된다는 공통점을 갖는다. 6.1.객체 리터럴에 의해 생성된 객체의 프로토타입자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때, 추상 연산 ObjectCreate를 호출한다. 이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 Object.prototype이다. 즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다. 아래 예제를 살펴보자. 1const obj = { x: 1 }; 위 객체 리터럴이 평가되면 추상 연산 ObjectCreate에 의해 아래와 같이 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어 진다. 이처럼 객체 obj는 Object.prototype을 프로토타입으로 갖게 되며 이로써 Object.prototype을 상속받는다. obj 객체는 constructor 프로퍼티와 hasOwnProperty 메소드 등을 소유하지 않지만 자신의 프로토타입인 Object.prototype의 constructor 프로퍼티와 hasOwnProperty 메소드를 자신의 자산인 것처럼 자유롭게 사용할 수 있다. 이는 obj 객체가 자신의 프로토타입인 Object.prototype 객체를 상속받았기 때문이다. 12345const obj = { x: 1 };// 객체 obj는 Object.prototype을 상속받는다.console.log(obj.constructor === Object); // trueconsole.log(obj.hasOwnProperty('x')); // true 6.2. Object 생성자 함수에 의해 생성된 객체의 프로토타입명시적으로 Object 생성자 함수를 호출하여 객체를 생성하면 빈 객체가 생성된다. Object 생성자 함수를 호출하면 객체 리터럴과 마찬가지로 추상 연산 ObjectCreate를 호출한다. 12const obj = new Object();obj.x = 1; 추상 연산 ObjectCreate에 의해 아래와 같이 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어 진다. 객체 리터럴에 의해 생성된 객체와 동일한 구조를 갖는 것을 알 수 있다. 이처럼 객체 obj는 Object.prototype을 프로토타입으로 갖게 되며 이로써 Object.prototype을 상속받는다. 123456const obj = new Object();obj.x = 1;// 객체 obj는 Object.prototype을 상속받는다.console.log(obj.constructor === Object); // trueconsole.log(obj.hasOwnProperty('x')); // true 객체 리터럴과 Object 생성자 함수에 의한 객체 생성 방식의 차이는 프로퍼티를 추가하는 방식에 있다. 객체 리터럴 방식은 객체 리터럴 내부에 프로퍼티를 추가하지만 Object 생성자 함수 방식은 일단 빈객체를 생성한 이후 프로퍼티를 추가해야 한다. 6.3.생성자 함수에 의해 생성된 객체의 프로토타입new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하면 다른 객체 방식과 마찬가지로 추상 연산 ObjectCreate를 호출한다. 이때 추상 연산 ObjectCreate에 전달되는 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 즉, 생성자 함수에 의해 생성되는 객체의 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체이다. 아래 예제를 살펴보자. 12345function Person(name) { this.name = name;}const me = new Person('Lee'); 위 코드가 실행되면 추상 연산 ObjectCreate에 의해 아래와 같이 생성자 함수와 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체와 생성된 객체 사이에 연결이 만들어 진다. 빌트인 객체인 Object 생성자 함수와 더불어 생성된 프로토타입 Object.prototype은 다양한 빌트인 메소드(hasOwnProperty, propertyIsEnumerable 등)를 갖고 있다. 하지만 사용자 정의 생성자 함수 Person과 더불어 생성된 프로토타입 Person.prototype의 프로퍼티는 constructor 뿐이다. 프로토타입 Person.prototype에 프로퍼티를 추가하여 하위(자식) 객체가 상속받을 수 있도록 구현해보자. 프로토타입은 객체이다. 따라서 일반 객체와 같이 프로토타입에도 프로퍼티를 추가/삭제할 수 있다. 그리고 이렇게 추가/삭제된 프로퍼티는 프로토타입 체인에 즉각 반영된다. 1234567891011121314function Person(name) { this.name = name;}// 프로토타입 메소드Person.prototype.sayHello = function () { console.log(`Hi! My name is ${this.name}`);};const me = new Person('Lee');const you = new Person('Kim');me.sayHello(); // Hi! My name is Leeyou.sayHello(); // Hi! My name is Kim Person 생성자 함수를 통해 생성된 모든 객체는 프로토타입에 추가된 sayHello 메소드를 상속받아 자신의 메소드처럼 사용할 수 있다. 7. 프로토타입 체인아래 예제를 살펴보자. 12345678910111213function Person(name) { this.name = name;}// 프로토타입 메소드Person.prototype.sayHello = function () { console.log(`Hi! My name is ${this.name}`);};const me = new Person('Lee');// hasOwnProperty는 Object.prototype의 메소드이다.console.log(me.hasOwnProperty('name')); // true Person 생성자 함수에 의해 생성된 me 객체는 Object.prototype의 메소드인 hasOwnProperty를 호출할 수 있다. 이것은 me 객체가 Person.prototype 뿐만 아니라 Object.prototype도 상속받았다는 의미이다. me 객체의 프로토타입은 Person.prototype이다. 1console.log(Object.getPrototypeOf(me) === Person.prototype); // true Person.prototype의 프로토타입은 Object.prototype이다. 프로토타입의 프로토타입은 언제나 Object.prototype이다. 1console.log(Object.getPrototypeOf(Person.prototype) === Object.prototype); // true 따라서 위 예제를 그림으로 표현하면 아래와 같다. 자바스크립트는 객체의 프로퍼티(메소드 포함)에 접근하려고 할 때 해당 객체에 접근하려는 프로퍼티가 없다면 proto 접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모 역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색한다.이것을 프로토타입 체인이라 한다. 프로토타입 체인은 자바스크립트가 객체 지향 프로그래밍의 상속을 구현하는 메커니즘이다. 123// hasOwnProperty는 Object.prototype의 메소드이다.// me 객체는 프로토타입 체인을 따라 hasOwnProperty 메소드를 검색하여 사용한다.console.log(me.hasOwnProperty('name')); // true me.hasOwnProperty(‘name’)와 같이 메소드를 호출하면 자바스크립트 엔진은 아래와 같은 과정을 거쳐 메소드를 검색한다. 물론 프로퍼티를 검색하는 경우도 마찬가지다. 먼저 hasOwnProperty 메소드를 호출한 me 객체에서 hasOwnProperty 메소드를 검색한다. me 객체에는 hasOwnProperty 메소드가 없으므로 프로토타입 체인을 따라, 다시 말해 [[Prototype]] 내부 슬롯에 바인딩되어 있는 프로토타입(위 예제의 경우, Person.prototype)으로 이동하여 hasOwnProperty 메소드를 검색한다. Person.prototype에도 hasOwnProperty 메소드가 없으므로 프로토타입 체인을 따라, 다시 말해 [[Prototype]] 내부 슬롯에 바인딩되어 있는 프로토타입(위 예제의 경우, Object.prototype)으로 이동하여 hasOwnProperty 메소드를 검색한다. Object.prototype에는 hasOwnProperty 메소드가 존재한다. 자바스크립트 엔진은 Object.prototype.hasOwnProperty 메소드를 호출한다. 이때 Object.prototype.hasOwnProperty 메소드의 this에는 me 객체가 바인딩된다. 자바스크립트 엔진은 객체 간의 상속 관계로 이루어진 프로토타입의 계층적인 구조에서 객체의 프로퍼티를 검색한다. 따라서 프로토타입 체인은 상속과 프로퍼티 검색을 위한 메커니즘이라고 할 수 있다. 8. 캡슐화 아래의 예제를 살펴보자 12345678910111213141516const Person = (function () { // 생성자 함수 function Person(name) { this.name = name; } // 프로토타입 메소드 Person.prototype.sayHello = function () { console.log(`Hi! My name is ${this.name}`); }; // 생성자 함수를 반환 return Person;}());const me = new Person('Lee'); 위 패턴을 사용하면 캡슐화를 쉽게 구현할 수 있다. 캡슐화(encapsulation)는 정보의 일부를 외부에 감추어 은닉(정보 은닉(information hiding))하는 것을 말한다. 즉, 외부에 공개할 필요가 없는 구현의 일부를 외부에 노출되지 않도록 감추어 적절치 못한 접근으로부터 정보를 보호하고 객체간의 상호 의존성, 즉 결합도를 낮추는 효과가 얻는다. Java의 경우, 클래스를 정의하고 그 클래스를 구성하는 멤버에 대하여 public, private, protected와 같은 접근 제한자(access modifier)를 선언하여 노출 범위를 한정할 수 있다. public으로 선언된 프로퍼티/메소드는 클래스 외부에서 참조할 수 있지만 private으로 선언된 경우는 클래스 외부에서 참조할 수 없다. 자바스크립트는 public, private, protected와 같은 접근 제한자를 제공하지 않는다. 하지만 캡슐화가 불가능한 것은 아니다. 현재 name 프로퍼티는 현재 외부로 노출되어 있어서 자유롭게 변경할 수 있다. 123// name 프로퍼티는 public하다. 즉, 외부에서 자유롭게 접근하고 변경할 수 있다.me.name = 'Kim';me.sayHello(); // Hi! My name is Kim name 프로퍼티를 캡슐화하여 외부로 노출되지 않도록 수정해보자. 123456789101112131415161718192021const Person = (function () { // 자유 변수이며 private하다 let _name = ''; // 생성자 함수 function Person(name) { _name = name; } // 프로토타입 메소드 Person.prototype.sayHello = function () { console.log(`Hi! My name is ${_name}`); }; // 생성자 함수를 반환 return Person;}());const me = new Person('Lee');// _name은 지역 변수이므로 외부에서 접근하여 변경할 수 없다. 즉, private하다.me._name = 'Kim';me.sayHello(); // Hi! My name is Lee 9. 오버라이딩과 프로퍼티 쉐도잉 123456789101112131415161718192021222324const Person = (function () { // 생성자 함수 function Person(name) { this.name = name; } // 프로토타입 메소드 Person.prototype.sayHello = function () { console.log(`Hi! My name is ${this.name}`); }; // 생성자 함수를 반환 return Person;}());const me = new Person('Lee');// 인스턴스 메소드me.sayHello = function () { console.log(`Hey! My name is ${this.name}`);};// 인스턴스 메소드가 호출된다. 프로토타입 메소드는 인스턴스 메소드에 의해 가려진다.me.sayHello(); // Hey! My name is Lee 프로토타입이 소유한 프로퍼티(메소드 포함)를 프로토타입 프로퍼티, 인스턴스가 소유한 프로퍼티를 인스턴스 프로퍼티라고 부른다. 프로토타입 프로퍼티와 같은 이름의 프로퍼티를 인스턴스에 추가하면 프로토타입 체인을 따라 프로토타입 프로퍼티를 검색하여 프로토타입 프로퍼티를 덮어쓰는 것이 아니라 인스턴스 프로퍼티로 추가한다. 이때 인스턴스 메소드 sayHello는 프로토타입 메소드 sayHello를 오버라이딩하였고 프로토타입 메소드 sayHello는 가려진다. 이처럼 상속 관계에 의해 프로퍼티가 가려지는 현상을 프로퍼티 쉐도잉(property shadowing)이라 한다. 오버라이딩(Overriding) 상위 클래스가 가지고 있는 메소드를 하위 클래스가 재정의하여 사용하는 방식이다. 오버로딩(Overloading) 함수의 이름은 동일하지만 매개변수의 타입 또는 개수가 다른 메소드를 구현하고 매개변수에 의해 메소드를 구별하여 호출하는 방식이다. 자바스크립트는 오버로딩을 지원하지 않지만 arguments 객체를 사용하여 구현할 수는 있다.프로퍼티를 삭제하는 경우도 마찬가지다. 위 예제에서 추가한 인스턴스 메소드 sayHello를 삭제해보자. 1234// 인스턴스 메소드를 삭제한다.delete me.sayHello;// 인스턴스에는 sayHello 메소드가 없으므로 프로토타입 메소드가 호출된다.me.sayHello(); // Hi! My name is Lee 당연히 프로토타입 메소드가 아닌 인스턴스 메소드 sayHello가 삭제된다. 다시 한번 sayHello 메소드를 삭제하여 프로토타입 메소드의 삭제를 시도해보자. 1234// 프로토타입 메소드는 삭제되지 않는다.delete me.sayHello;// 프로토타입 메소드가 호출된다.me.sayHello(); // Hi! My name is Lee 하위 객체를 통해 프로토타입의 프로퍼티를 변경 또는 삭제하는 것은 불가능하다. 프로토타입 프로퍼티를 변경 또는 삭제하려면 하위 객체를 통해 프로토타입 체인으로 접근하는 것이 아니라 프로토타입에 직접 접근하여야 한다. 123456789// 프로토타입 메소드 변경Person.prototype.sayHello = function () { console.log(`Hey! My name is ${this.name}`);};me.sayHello(); // Hey! My name is Lee// 프로토타입 메소드 삭제delete Person.prototype.sayHello;me.sayHello(); // TypeError: me.sayHello is not a function 10. 프로토타입의 교체 프로토타입은 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체 간의 상속 관계를 동적으로 변경할 수 있다. 프로토타입은 생성자 함수 또는 인스턴스에 의해 교체할 수 있다. 10.1 생성자 함수에 의한 프로토타입의 교체아래 예제를 살펴보자 12345678910111213141516const Person = (function () { function Person(name) { this.name = name; } // ① 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체 Person.prototype = { sayHello() { console.log(`Hi! My name is ${this.name}`); } }; return Person;}());const me = new Person('Lee'); ①에서 Person.prototype에 객체 리터럴을 할당하였다. 이는 Person 생성자 함수가 생성할 객체의 프로토타입을 객체 리터럴로 교체한 것이다. 이를 그림으로 나타내면 아래와 같다. 프로토타입으로 교체한 객체 리터럴에는 constructor 프로퍼티가 없다. 따라서 me 객체의 생성자 함수를 검색하면 Person이 아닌 Object가 나온다. constructor 프로퍼티는 자바스크립트 엔진이 프로토타입을 생성할 때 암묵적으로 추가한 프로퍼티이다. 1234// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다.console.log(me.constructor === Person); // false// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.console.log(me.constructor === Object); // true 이처럼 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다. 파괴된 constructor 프로퍼티와 생성자 함수 간의 링크를 되살려 보자. 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하여 프로토타입의 constructor 프로퍼티를 되살린다. 12345678910111213141516171819202122const Person = (function () { function Person(name) { this.name = name; } // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체 Person.prototype = { // constructor 프로퍼티와 생성자 함수 간의 링크 설정 constructor: Person, sayHello() { console.log(`Hi! My name is ${this.name}`); } }; return Person;}());const me = new Person('Lee');// constructor 프로퍼티가 생성자 함수를 가리킨다.console.log(me.constructor === Person); // trueconsole.log(me.constructor === Object); // false 10.2. 인스턴스에 의한 프로토타입의 교체 12345678910111213141516171819function Person(name) { this.name = name;}const me = new Person('Lee');// 프로토타입으로 교체할 객체const parent = { sayHello() { console.log(`Hi! My name is ${this.name}`); }};// ① me 객체의 프로토타입을 parent 객체로 교체한다.Object.setPrototypeOf(me, parent);// 위 코드는 아래의 코드와 동일하게 동작한다.// me.__proto__ = parent;me.sayHello(); // Hi My name is Lee ①에서 me 객체의 프로토타입을 parent 객체로 교체하였다. 이를 그림으로 나타내면 아래와 같다. 프로토타입으로 교체한 객체에는 constructor 프로퍼티가 없다. 따라서 프로토타입의 constructor 프로퍼티로 me 객체의 생성자 함수를 검색하면 Person이 아닌 Object가 나온다. 1234// 프로토타입을 교체하면 constructor 프로퍼티와 생성자 함수 간의 링크가 파괴된다.console.log(me.constructor === Person); // false// 프로토타입 체인을 따라 Object.prototype의 constructor 프로퍼티가 검색된다.console.log(me.constructor === Object); // true 생성자 함수에 의한 프로토타입 교체와 마찬가지로 인스턴스에 의한 프로토타입 교체도 constructor 프로퍼티와 생성자 함수 간의 연결을 파괴한다. 생성자 함수에 의한 프로토타입 교체와 인스턴스에 의한 프로토타입 교체는 별다른 차이가 없어 보인다. 하지만 미묘한 차이가 있다. 프로토타입으로 교체한 객체 리터럴에 constructor 프로퍼티를 추가하고 생성자 함수의 prototype 프로퍼티를 재설정하여 파괴된 생성자 함수와 프로토타입 간의 연결을 되살려 보자. 12345678910111213141516171819202122232425262728293031function Person(name) { this.name = name;}const me = new Person('Lee');// 프로토타입으로 교체할 객체const parent = { // constructor 프로퍼티와 생성자 함수 간의 링크 설정 constructor: Person, sayHello() { console.log(`Hi! My name is ${this.name}`); }};// 생성자 함수의 prototype 프로퍼티와 프로토타입 간의 링크 설정Person.prototype = parent;// me 객체의 프로토타입을 parent 객체로 교체한다.Object.setPrototypeOf(me, parent);// 위 코드는 아래의 코드와 동일하게 동작한다.// me.__proto__ = parent;me.sayHello(); // Hi! My name is Lee// constructor 프로퍼티가 생성자 함수를 가리킨다.console.log(me.constructor === Person); // trueconsole.log(me.constructor === Object); // false// 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리킨다.console.log(Person.prototype === Object.getPrototypeOf(me)); // true 이처럼 프로토타입 교체를 통해 객체 간의 상속 관계를 동적으로 변경하는 것은 꽤나 번거롭다. 하지만 ES6에서 도입된 클래스를 사용하면 간편하고 직관적으로 상속 관계를 구현할 수 있다. 11. instanceof 연산자 instanceof 연산자는 이항 연산자로서 좌변에 객체를 가리키는 식별자, 우변에 생성자 함수를 가리키는 식별자를 피연산자로 받는다. 만약 우변의 피연산자가 함수가 아닌 경우, TypeError가 발생한다. 1객체 instanceof 생성자 함수 좌변의 객체가 우변의 생성자 함수와 연결된 인스턴스라면 true로 평가되고 그렇지 않은 경우에는 false로 평가된다. instanceof 연산자는 상속 관계를 고려한다는 것에 주의하기 바란다. 123456789101112function Person(name) { this.name = name;}const me = new Person('Lee');// me 객체는 Person 생성자 함수에 의해 생성된 인스턴스이다.console.log(me instanceof Person); // true// instanceof 연산자는 상속 관계를 고려한다.// me 객체는 Object.prototype을 상속받기 떄문에 아래의 코드는 true로 평가된다.console.log(me instanceof Object); // true instanceof 연산자가 어떻게 상속 관계를 파악하는지 이해하기 위해, 인스턴스에 의해 프로토타입을 교체한 경우, instanceof 연산자가 어떻게 동작하는지 살펴보자. 123456789101112131415161718192021// 생성자 함수function Person(name) { this.name = name;}const me = new Person('Lee');// 프로토타입으로 교체할 객체const parent = {};// 인스턴스에 의한 프로토타입의 교체// 교체된 프로토타입에는 constructor 프로퍼티가 없기 때문에// 프로토타입과 생성자 함수의 링크가 파괴된다.Object.setPrototypeOf(me, parent);// me 객체는 Person 생성자 함수에 의해 생성된 인스턴스이다.// 그러나 instanceof 연산자는 false를 반환한다.console.log(me instanceof Person); // false// instanceof 연산자는 상속 관계를 고려한다.// me 객체는 Object.prototype을 상속받기 때문에 아래의 코드는 true로 평가된다.console.log(me instanceof Object); // true me 객체는 비록 프로토타입이 교체되어 프로토타입과 생성자 함수의 링크가 파괴되었지만 Person 생성자 함수에 의해 생성된 인스턴스이다. 그러나 me instanceof Person 의 평가 결과는 flase이다. 프로토타입의 constructor 프로퍼티가 생성자 함수를 가리키지 않아서 이러한 문제가 발생할 지도 모르니 교체된 프로토타입의 constructor 프로퍼티가 생성자 함수를 가리키도록 재설정해보자. 12345678// 프로토타입으로 교체할 객체const parent = { constructor: person};console.log(me instanceof Person); // falseconsole.log(me instanceof Object); // true 여전히 me instanceof Person 의 평가 결과는 false이다. 이번에는 생성자 함수의 prototype 프로퍼티가 교체된 프로토타입을 가리키도록 재설정해보자. 12345678910// 프로토타입으로 교체할 객체const parent = { constructor: Person};// 생성자 함수의 prototype 프로퍼티와 프로토타입 간의 링크 설정Person.prototype = parent;console.log(me instanceof Person); // trueconsole.log(me instanceof Object); // true instanceof 연산자는 프로토타입의 constructor 프로퍼티가 가리키는 생성자 함수를 찾는 것이 아니라 프로토타입 체인 상에 존재하는 프로토타입에 영향을 받는 것을 알 수 있다. instanceof 연산자는 생성자 함수의 prototype 프로퍼티가 가리키는 객체가 프로토타입 체인 상에 존재하는지 확인한다. 아래 그림을 살펴보자. instanceof 연산자는 좌변 피연산자의 프로토타입 체인 상에 우변의 피연산자, 즉 생성자 함수의 prototype 프로퍼티에 바인딩된 객체가 존재하는 지 검색한다. me instanceof Person 의 경우, me 객체의 프로토타입 체인 상에 Person.prototype에 바인딩된 객체가 객체가 존재하는지 확인한다. me instanceof Object 의 경우도 마찬가지다. me 객체의 프로토타입 체인 상에 Object.prototype에 바인딩된 객체가 객체가 존재하는지 확인한다. 123456789101112131415161718192021const Person = (function () { function Person(name) { this.name = name; } // 생성자 함수의 prototype 프로퍼티를 통해 프로토타입을 교체 Person.prototype = { sayHello() { console.log(`Hi! My name is ${this.name}`); } }; return Person;}());const me = new Person('Lee');// constructor 프로퍼티와 생성자 함수 간의 링크가 파괴되어도// instanceof는 아무런 영향을 받지 않는다.console.log(me instanceof Person); // trueconsole.log(me instanceof Object); // true 12. 직접 상속 12.1 Object.create에 의한 직접 상속Object.create 메소드의 첫번째 매개변수에는 생성할 객체의 프로토타입으로 지정할 객체를 전달한다. 두번째 매개변수에는 생성할 객체의 프로퍼티를 갖는 객체를 전달한다.두번쨰 인수는 옵션이므로 생략 가능하다. 1234567/** * 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체를 생성하여 반환한다. * @param {Object} prototype - 생성할 객체의 프로토타입으로 지정할 객체 * @param {Object} [propertiesObject] - 생성할 객체의 프로퍼티를 갖는 객체 * @returns {Object} 지정된 프로토타입 및 프로퍼티를 갖는 새로운 객체 */Object.create(prototype[, propertiesObject]) 12345678910111213141516171819202122232425262728293031323334353637383940414243// 프로토타입이 null인 객체를 생성한다.// 즉, 생성된 객체는 프로토타입 체인의 종점이므로 프로토타입 체인이 생성되지 않는다.// obj → nulllet obj = Object.create(null);console.log(Object.getPrototypeOf(obj) === null); // true// Object.prototype를 상속받지 못한다.console.log(obj.toString()); // TypeError: obj.toString is not a function// obj = {};와 동일하다.// obj → Object.prototype → nullobj = Object.create(Object.prototype);console.log(Object.getPrototypeOf(obj) === Object.prototype); // true// obj = { x: 1 };와 동일하다.// obj → Object.prototype → nullobj = Object.create(Object.prototype, { x: { value: 1 }});// 위 코드는 아래와 동일하다.// obj = Object.create(Object.prototype);// obj.x = 1;console.log(obj.x); // 1console.log(Object.getPrototypeOf(obj) === Object.prototype); // trueconst myProto = { x: 10 };// 객체를 직접 상속받는다.// obj → myProto → Object.prototype → nullobj = Object.create(myProto);console.log(obj.x); // 10console.log(Object.getPrototypeOf(obj) === myProto); // true// 생성자 함수function Person(name) { this.name = name;}// obj = new Person('Lee')와 동일하다.// obj → Person.prototype → Object.prototype → nullobj = Object.create(Person.prototype);obj.name = 'Lee';console.log(obj.name); // Leeconsole.log(Object.getPrototypeOf(obj) === Person.prototype); // true Object.create 메소드는 첫번째 매개변수에 전달한 객체의 프로토타입 체인에 속하는 객체를 생성한다. 한마디로 객체를 생성하면서 상속을 구현한다. Object.create()의 장점은 new 연산자가 없이도 객체를 생성할 수 있다. 객체 리터럴에 의해 생성된 객체도 특정 객체를 상속받을 수 있다. 프로토타입을 지정하면서 객체를 생성할 수 있다. Object.prototype의 빌트인 메소드인 Object.prototype.hasOwnProperty, Object.prototype.isPrototypeOf, Object.prototype.propertyIsEnumerable 등은 모든 객체의 프로토타입 체인의 종점, 즉 Object.prototype의 메소드이므로 모든 객체가 상속받아 호출할 수 있다. 12345const obj = { a: 1 };console.log(obj.hasOwnProperty('a')); // trueconsole.log(obj.isPrototypeOf(child)); // trueconsole.log(obj.propertyIsEnumerable('a')); // true 그런데 ESLint에서는 위 예제와 같이 Object.prototype의 빌트인 메소드를 객체가 직접 호출하는 것을 비추천하고 있다. 그 이유는 Object.create 메소드를 통해 프로토타입 체인을 생성하지 않는 객체, 다시 말해 프로토타입의 종점에 위치하는 객체를 생성할 수 있기 때문이다. 이때 프로토타입 체인을 생성하지 않는 객체는 Object.prototype의 빌트인 메소드를 사용할 수 없다. 123456789// 프로토타입이 null인 객체를 생성한다.const obj = Object.create(null);obj.a = 1;// obj는 프로토타입 체인의 종점이므로 프로토타입 체인이 생성되지 않는다.console.log(Object.getPrototypeOf(obj === null); // true// obj는 Object.prototype의 빌트인 메소드를 사용할 수 없다.console.log(obj.hasOwnProperty('a')); // TypeError: obj.hasOwnProperty is not a function 따라서 이같은 에러를 발생시키는 가능성을 없애기 위해 Object.prototype의 빌트인 메소드는 아래와 같이 간접적으로 호출하는 것이 좋다. 12345678// 프로토타입이 null인 객체를 생성한다.const obj = Object.create(null);obj.a = 1;// console.log(obj.hasOwnProperty('a')); // TypeError: obj.hasOwnProperty is not a function// Object.prototype의 빌트인 메소드는 객체로 직접 호출하지 않는다.console.log(Object.prototype.hasOwnProperty.call(obj, 'a')); // true 12.2 객체 리터럴 내부에서 proto에 의한 직접 상속 Object.create 메소드는 직접 상속은 위와 같이 여러 장점이 있다. 하지만 두번째 인자로 프로퍼티를 정의하는 것은 번거롭다. 일단 객체를 생성한 이후, 프로퍼티를 추가하는 방법도 있으나 이 또한 깔끔한 방법은 아니다. ES6에서는 객체 리터럴 내부에서 proto 접근자 프로퍼티를 사용하여 직접 상속을 구현할 수 있다. 1234567891011121314const myProto = { x: 10 };// 객체 리터럴에 의해 객체를 생성하면서 프로토타입을 지정하여 직접 상속받을 수 있다.const obj = { y: 20, // 객체를 직접 상속받는다. // obj → myProto → Object.prototype → null __proto__: myProto};// 위 코드는 아래와 동일하다.// const obj = Object.create(myProto, { y: { value: 20 } });console.log(obj.x, obj.y); // 10 20console.log(Object.getPrototypeOf(obj) === myProto); // true 13. 정적 프로퍼티/메소드 정적(static) 프로퍼티/메소드는 생성자 함수로 인스턴스를 생성하지 않아도 참조/호출할 수 있는 프로퍼티/메소드를 말한다. 아래 예제를 살펴보자. 1234567891011121314151617181920212223242526// 생성자 함수function Person(name) { this.name = name;}// 프로토타입 메소드Person.prototype.sayHello = function () { console.log(`Hi! My name is ${this.name}`);};// Person 생성자 함수는 객체이므로 자신의 프로퍼티/메소드를 소유할 수 있다.// 정적 프로퍼티Person.staticProp = 'static prop';// 정적 메소드Person.staticMethod = function () { console.log('staticMethod');};const me = new Person('Lee');// 생성자 함수에 추가한 정적 프로퍼티/메소드는 생성자 함수로 참조/호출한다.Person.staticMethod(); // staticMethod// 정적 프로퍼티/메소드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다.// 인스턴스로 참조/호출할 수 있는 프로퍼티/메소드는 프로토타입 체인 상에 존재해야 한다.me.staticMethod(); // TypeError: me.staticMethod is not a function Person 생성자 함수는 객체이므로 자신의 프로퍼티/메소드를 소유할 수 있다. Person 생성자 함수 객체가 소유한 프로퍼티/메소드를 정적 프로퍼티/메소드라고 부른다. 정적 프로퍼티/메소드는 생성자 함수가 생성한 인스턴스로 참조/호출할 수 없다. 생성자 함수가 생성한 인스턴스는 자신의 프로토타입 체인에 속한 객체의 프로퍼티/메소드에 접근할 수 있다. 정적 프로퍼티/메소드는 인스턴스의 프로토타입 체인에 속한 객체의 프로퍼티/메소드가 아니므로 인스턴스로 접근할 수 없다. 앞에서 살펴본 Object.create 메소드는 Object 생성자 함수의 정적 메소드이고 Object.prototype.hasOwnProperty 메소드는 Object.prototype의 메소드이다. 따라서 Object.create 메소드는 인스턴스, 즉 Object 생성자 함수가 생성한 객체로 호출할 수 없다. 하지만 Object.prototype.hasOwnProperty 메소드는 모든 객체의 프로토타입 체인의 종점, 즉 Object.prototype의 메소드이므로 모든 객체가 호출할 수 있다. 12345// Object.create는 정적 메소드이다.const obj = Object.create({});// Object.prototype.hasOwnProperty는 프로토타입 메소드이다.console.log(obj.hasOwnProperty('name')); 만약 인스턴스/프로토타입 메소드 내에서 this를 사용하지 않는다면 그 메소드는 정적 메소드로 변경할 수 있다. 인스턴스가 호출한 인스턴스/프로토타입 메소드 내에서 this는 인스턴스를 가리킨다. 메소드 내에서 인스턴스를 참조할 필요가 없다면 정적 메소드로 변경하여도 동작한다. 프로토타입 메소드를 호출하려면 인스턴스를 생성해야 하지만 정적 메소드는 인스턴스를 생성하지 않아도 호출할 수 있다. 12345678910111213141516171819function Foo() {}// 프로토타입 메소드 내에서 this를 참조하지 않는다.// 이 메소드는 정적 메소드로 변경하여도 동일한 효과를 얻을 수 있다.Foo.prototype.x = function () { console.log('x');};const foo = new Foo();// 프로토타입 메소드를 호출하려면 인스턴스를 생성해야 한다.foo.x(); // x// 정적 메소드 내에서 this는 생성자 함수를 가리킨다.Foo.x = function () { console.log('x');};// 정적 메소드는 인스턴스를 생성하지 않아도 호출할 수 있다.Foo.x(); // x MDN과 같은 문서를 보면 아래와 같이 정적 프로퍼티/메소드와 프로토타입 프로퍼티/메소드를 구분하고 소개하고 있다. 따라서 표기법만으로도 정적 프로퍼티/메소드와 프로토타입 프로퍼티/메소드를 구별할 수 있어야 한다. 참고로 프로토타입 프로퍼티/메소드를 표기할 때 prototype을 #으로 표기(예를들어 Object.prototype.isPrototypeOf을 Object#isPrototypeOf으로 표기)하는 경우도 있으니 알아두도록 하자. 14. 프로퍼티 존재 확인in 연산자는 객체 내에 프로퍼티가 존재하는지 여부를 확인한다. in 연산자의 사용 방법은 아래와 같다. 12345/** * key: 프로퍼티 키를 나타내는 문자열 * object: 객체로 평가되는 표현식 */key in object 1234567891011const person = { name: 'Lee', address: 'Seoul'};// person 객체에 name 프로퍼티가 존재한다.console.log('name' in person); // true// person 객체에 address 프로퍼티가 존재한다.console.log('address' in person); // true// person 객체에 age 프로퍼티가 존재하지 않는다.console.log('age' in person); // false in 연산자는 확인 대상 객체(위 예제의 경우, person 객체)의 프로퍼티 뿐만 아니라 확인 대상 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인하므로 주의하기 바란다. person 객체에는 toString이라는 프로퍼티가 없지만 아래의 실행 결과는 true이다. 1console.log('toString' in person); // true 이는 in 연산자가 person 객체가 속한 프로토타입 체인 상에 존재하는 모든 프로토타입에서 toString 프로퍼티를 검색했기 때문이다. toString은 Object.prototype의 메소드이다. Object.prototype.hasOwnProperty 메소드를 사용해도 객체의 프로퍼티의 존재 여부를 확인할 수 있다. 12console.log(person.hasOwnProperty('name')); // trueconsole.log(person.hasOwnProperty('age')); // false Object.prototype.hasOwnProperty 메소드는 이름에서 알 수 있듯이 전달받은 프로퍼티 키가 객체 고유의 프로퍼티 키인 경우에만 true를 반환하고 상속받은 프로토타입의 프로퍼티 키인 경우 false를 반환한다. 1console.log(person.hasOwnProperty('toString')); // false 15. 프로퍼티 열거 15.1 for…in 문객체의 모든 프로퍼티를 순회하며 열거(enumeration)하려면 for…in 문을 사용한다. 1for (변수선언문 in 객체) { … } 1234567891011const person = { name: 'Lee', address: 'Seoul'};// for...in 문의 변수 prop에 person 객체의 프로퍼티 키가 할당된다. 단, 순서는 보장되지 않는다.for (const key in person) { console.log(key + ': ' + person[key]);}// name: Lee// address: Seoul for…in 문은 객체의 프로퍼티 개수만큼 반복하며 for…in 문의 변수 선언문에서 선언한 변수에 프로퍼티 키를 할당한다. 위 예제의 경우, person 객체에는 2개의 프로퍼티가 있으므로 객체를 2번 순회하면서 프로퍼티 키를 key 변수에 할당한 후 코드 블록을 실행한다. 첫번째 순회에서는 프로퍼티 키 ‘name’을 key 변수에 할당한 후 코드 블록을 실행하고 두번째 순회에서는 프로퍼티 키 ‘address’를 key 변수에 할당한 후 코드 블록을 실행한다. for…in 문은 in 연산자처럼 순회 대상 객체의 프로퍼티 뿐만 아니라 상속받은 프로토타입의 프로퍼티까지 열거한다. 하지만 위 예제의 경우, toString과 같은 Object.prototype의 프로퍼티가 열거되지 않는다. 1234567891011// in 연산자는 객체가 상속받은 모든 프로토타입의 프로퍼티를 확인한다.console.log('toString' in person); // true// for...in 문도 객체가 상속받은 모든 프로토타입의 프로퍼티를 열거한다.// 하지만 toString과 같은 Object.prototype의 프로퍼티가 열거되지 않는다.for (const prop in person) { console.log(prop + ': ' + person[prop]);}// name: Lee// address: Seoul 이는 toString 메소드가 열거할 수 없도록 정의되어 있는 프로퍼티이기 때문이다. 다시 말해, Object.prototype.string 프로퍼티의 프로퍼티 어트리뷰트 [[Enumerable]]의 값이 false이기 때문이다. 프로퍼티 어트리뷰트 [[Enumerable]]는 프로퍼티의 열거 가능 여부를 나타내며 불리언 값을 갖는다. 1234// Object.getOwnPropertyDescriptor 메소드는 프로퍼티 디스크립터 객체를 반환한다.// 프로퍼티 디스크립터 객체는 프로퍼티 어트리뷰트 정보를 담고 있는 객체이다.console.log(Object.getOwnPropertyDescriptor(Object.prototype, 'toString'));// {value: ƒ, writable: true, enumerable: false, configurable: true} for…in 문은 프로퍼티 키가 심볼인 프로퍼티는 열거하지 않는다. 12345678910const sym = Symbol();const obj = { a: 1, [sym]: 10};for (const key in obj) { console.log(key + ': ' + obj[key]);}// a: 1 상속받은 프로퍼티는 제외하고 객체 자신의 프로퍼티 만을 열거하려면 Object.prototype.hasOwnProperty 메소드를 사용하여 객체 자신의 프로퍼티인지 확인해야 한다. 12345678910111213const person = { name: 'Lee', address: 'Seoul', __proto__: { age: 20 }};for (const key in person) { // 객체 자신의 프로퍼티인지 확인한다. if (!person.hasOwnProperty(key)) continue; console.log(key + ': ' + person[key]);}// name: Lee// address: Seoul 모던 브라우저는 순서를 보장하고 숫자(사실은 문자열)인 프로퍼티 키에 대해서는 정렬을 실시한다. 1234567891011121314151617181920const obj = { 2: 2, 3: 3, 1: 1, b: 'b', a: 'a'};for (const key in obj) { if (!obj.hasOwnProperty(key)) continue; console.log(key + ': ' + obj[key]);}/*1: 12: 23: 3b: ba: a*/ 배열에는 for…in 문을 사용하지 말고 일반적인 for 문이나 for…of 문 또는 Array.prototype.forEach 메소드를 사용하기를 권장한다. 사실 배열도 객체이므로 프로퍼티와 상속받은 프로퍼티가 포함될 수 있다. 1234567891011121314151617181920const arr = [1, 2, 3];arr.x = 10; // 배열도 객체이므로 프로퍼티를 가질 수 있다.for (const i in arr) { // 프로퍼티 x도 출력된다. console.log(arr[i]); // 1 2 3 10};// arr.length는 3이다.for (let i = 0; i &lt; arr.length; i++) { console.log(arr[i]); // 1 2 3}// forEach 메소드는 요소가 아닌 프로퍼티는 제외한다.arr.forEach(v =&gt; console.log(v)); // 1 2 3// for...of는 변수 선언문에서 선언한 변수에 키가 아닌 값을 할당한다.for (const value of arr) { console.log(value); // 1 2 3}; 15.2 Object.keys/values/entries 메소드지금까지 살펴보았듯이 for…in 문은 객체 자신의 프로퍼티 뿐만 아니라 상속받은 프로퍼티도 열거한다. 따라서 Object.prototype.hasOwnProperty 메소드를 사용하여 객체 자신의 프로퍼티인지 확인하는 추가 처리가 필요하다. 객체 자신의 프로퍼티만을 열거하기 위해서는 for…in 문을 사용하는 것 보다 Object.keys/values/entries 메소드를 사용하는 것을 권장한다. Object.keys 메소드는 객체 자신의 열거 가능한(enumerable) 프로퍼티 키를 배열로 반환한다. ES8에서 도입된 Object.values 메소드는 객체 자신의 열거 가능한 프로퍼티 값을 배열로 반환한다. ES8에서 도입된 Object.entries 메소드는 객체 자신의 열거 가능한 프로퍼티 키와 값의 쌍의 배열을 배열에 담아 반환한다. 1234567891011121314151617const person = { name: 'Lee', address: 'Seoul', __proto__: { age: 20 }};console.log(Object.keys(person)); // [\"name\", \"address\"]console.log(Object.values(person)); // [\"Lee\", \"Seoul\"]console.log(Object.entries(person)); // [[\"name\", \"Lee\"], [\"address\", \"Seoul\"]]Object.entries(person).forEach(([key, value]) =&gt; console.log(key, value));/*name Leeaddress Seoul*/","link":"/2020/03/%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/"}],"tags":[{"name":"javaScript","slug":"javaScript","link":"/tags/javaScript/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Date","slug":"Date","link":"/tags/Date/"},{"name":"object","slug":"object","link":"/tags/object/"},{"name":"Math","slug":"Math","link":"/tags/Math/"},{"name":"RegExp","slug":"RegExp","link":"/tags/RegExp/"},{"name":"Number","slug":"Number","link":"/tags/Number/"},{"name":"ajax","slug":"ajax","link":"/tags/ajax/"},{"name":"graphic","slug":"graphic","link":"/tags/graphic/"},{"name":"canvas","slug":"canvas","link":"/tags/canvas/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"prototype","slug":"prototype","link":"/tags/prototype/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"algorism","slug":"algorism","link":"/tags/algorism/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"hof","slug":"hof","link":"/tags/hof/"},{"name":"module","slug":"module","link":"/tags/module/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"operator","slug":"operator","link":"/tags/operator/"},{"name":"attribute","slug":"attribute","link":"/tags/attribute/"},{"name":"property","slug":"property","link":"/tags/property/"},{"name":"HTML","slug":"HTML","link":"/tags/HTML/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"SASS","slug":"SASS","link":"/tags/SASS/"},{"name":"SCSS","slug":"SCSS","link":"/tags/SCSS/"},{"name":"Koala","slug":"Koala","link":"/tags/Koala/"},{"name":"scope","slug":"scope","link":"/tags/scope/"},{"name":"scopechain","slug":"scopechain","link":"/tags/scopechain/"},{"name":"present","slug":"present","link":"/tags/present/"},{"name":"statement","slug":"statement","link":"/tags/statement/"},{"name":"webpack","slug":"webpack","link":"/tags/webpack/"},{"name":"babel","slug":"babel","link":"/tags/babel/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"prettier","slug":"prettier","link":"/tags/prettier/"},{"name":"mvc","slug":"mvc","link":"/tags/mvc/"},{"name":"symbol","slug":"symbol","link":"/tags/symbol/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"let","slug":"let","link":"/tags/let/"},{"name":"const","slug":"const","link":"/tags/const/"},{"name":"var","slug":"var","link":"/tags/var/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"variable","slug":"variable","link":"/tags/variable/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"ide","slug":"ide","link":"/tags/ide/"},{"name":"editor","slug":"editor","link":"/tags/editor/"},{"name":"bable","slug":"bable","link":"/tags/bable/"},{"name":"destructuring","slug":"destructuring","link":"/tags/destructuring/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"browser","slug":"browser","link":"/tags/browser/"},{"name":"rendering","slug":"rendering","link":"/tags/rendering/"},{"name":"ExecutionContext","slug":"ExecutionContext","link":"/tags/ExecutionContext/"},{"name":"search","slug":"search","link":"/tags/search/"},{"name":"class","slug":"class","link":"/tags/class/"},{"name":"closer","slug":"closer","link":"/tags/closer/"},{"name":"bulitin","slug":"bulitin","link":"/tags/bulitin/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"firstclass","slug":"firstclass","link":"/tags/firstclass/"}],"categories":[{"name":"develop","slug":"develop","link":"/categories/develop/"},{"name":"JavaScript","slug":"develop/JavaScript","link":"/categories/develop/JavaScript/"},{"name":"git","slug":"develop/git","link":"/categories/develop/git/"},{"name":"algorism","slug":"algorism","link":"/categories/algorism/"},{"name":"npm & webpack","slug":"develop/npm-webpack","link":"/categories/develop/npm-webpack/"},{"name":"Sass","slug":"develop/Sass","link":"/categories/develop/Sass/"},{"name":"Study","slug":"Study","link":"/categories/Study/"},{"name":"With Js","slug":"algorism/With-Js","link":"/categories/algorism/With-Js/"},{"name":"React","slug":"develop/React","link":"/categories/develop/React/"},{"name":"practical study in JS","slug":"Study/practical-study-in-JS","link":"/categories/Study/practical-study-in-JS/"}]}